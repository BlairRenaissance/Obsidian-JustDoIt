## 动画简介

在 Godot 4.x 中，当你点击“新建动画”创建一个名为 Run 的动画时，底层发生的事情是：
- 在属于 Resource（资源）的一个 `AnimationLibrary`（容器）里新建了一个新的 `Animation` 文件 —— 也就是Clip（数据块）。
- 在这个 Run 里面，你可以创建 10 条 Track（头、手、脚、音效等）。
- 当你点击保存时，这 10 条 Track 会被打包存进这同一个文件里。
- 用最直白的一句话总结 **Clip** 和 **Track** 的关系： Clip 是“数据库表”，Track 是表里的“列（Column）”。或者用更程序的语言：Clip 是一个容器（Container），Track 是这个容器里的键值对（Key-Value Pair），Key 是“要修改谁”，Value 是“随时间变化的数据”。

![](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/202601231647856.png)


![](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/202601231646762.png)

后台执行了以下伪代码逻辑：

```C#
// 1. 创建一个新的、空白的 Animation 资源 (也就是 Clip)
var new_clip = Animation.new() 

// 2. 找到播放器当前挂载的 Library
// (如果没有，Godot 会自动帮你建一个默认的)
var current_library = my_animation_player.get_animation_library("") 

// 3. 把这个新 Clip 塞进 Library 里，名字叫 "Run"
current_library.add_animation("Run", new_clip)
```

---
## Clip


```
class AnimationSystem : SystemBase {
    
    // --- 1. 注入的依赖 (Dependencies) ---
    // 这些通常由 ECS 框架自动注入，或者在 System 初始化/Update时传入
    
    [Inject] TimeData _time;           // 注入：时间服务
    [Inject] AssetDatabase _assets;    // 注入：资源库（存着所有只读的 Clip 数据）
    [Inject] CommandBuffer _cmdBuffer; // 注入：用于记录修改
    
    // --- 2. 逻辑执行 ---
    protected override void OnUpdate() {
        
        float dt = _time.DeltaTime; // 使用注入的全局时间
        
        // 遍历所有带有 动画状态 和 骨骼 的实体
        Entities.ForEach((ref AnimationState state, ref Skeleton skel) => {
            
            // 使用注入的时间推进进度
            state.Time += dt * state.Speed;
            
            // 使用注入的资源库，通过 ID 获取实际数据（享元模式）
            var clipData = _assets.GetClip(state.ClipID);
            
            // 核心逻辑：采样曲线，写入骨骼组件
            skel.BoneTransforms = SampleAnimation(clipData, state.Time);
            
            // 使用注入的 CommandBuffer 处理逻辑变更
            if (state.Time >= clipData.Duration) {
                 _cmdBuffer.AddComponent(state.Entity, new AnimationFinishedTag());
            }
        });
    }
}
```

## Track

为了处理不同类型的数据和逻辑，设计了多种**Track（轨道）类型**。

之所以要分这么多类型，是因为**不同数据的插值算法（怎么算中间状态）和存储方式是完全不同的。**

![](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/202601231648583.png)

### 1. 属性轨道 (Property Track) —— 万能型

- **图标：** 绿色小方块。

- **作用：** 这是最通用的轨道。它可以控制任何对象的**公开变量**。

- **底层逻辑：**

    - 它可以存 `float`（透明度）、`Vector2`（UI位置）、`Color`（颜色）、`bool`（开关）等。
    
    - **插值：** 它使用通用的线性插值（Linear Interpolation）。比如颜色从红变蓝，它会算出中间的紫色。

### 2. 3D 位置/旋转/缩放轨道 (Position/Rotation/Scale 3D Track) —— 专用型

- **图标：** 立方体图标。

- **作用：** 专门用于 `Node3D` 的变换。

- **为什么不直接用“属性轨道”？（关键点！）**
    
    - **旋转（Rotation）是个大坑！** 如果你用普通的 Vector3 (x,y,z) 来存旋转，在做插值时会遇到“万向节死锁（Gimbal Lock）”或者旋转路径怪异的问题。
    
    - **底层优化：** 这种专用轨道在底层通常存储为 **四元数（Quaternion）**。它在计算插值时，不使用普通的线性插值（Lerp），而是使用 **球形插值（Slerp, Spherical Linear Interpolation）**。这能保证旋转是沿着最短路径平滑转过去的。
    
    - **性能：** 因为从一开始就知道数据格式是固定的（Transform），引擎可以对其内存布局进行极致优化（SIMD指令集加速）。

### 3. 贝塞尔曲线轨道 (Bezier Curve Track) —— 高精度型

- **图标：** 曲线图标。

- **作用：** 这就是我们之前讨论的“手搓贝塞尔曲线”。它允许你手动调节每一个关键帧的 **In-Tangent（入切线）** 和 **Out-Tangent（出切线）**。

- **区别：** 普通的“属性轨道”通常只给你提供几种预设的缓动模式（Ease-In, Ease-Out），而贝塞尔轨道允许你画出非常复杂的自定义曲线（比如弹簧效果、先冲过头再缩回来）。

### 4. 方法调用轨道 (Call Method Track) —— 逻辑型

- **图标：** 函数方块。

- **作用：** 在特定时间点调用脚本里的一个函数。

- **ECS 对比：**
    
    - 这相当于我们之前说的 **Timeline Events**。
    
    - 比如在动画播放到 0.5秒 时，轨道上有一个 Keyframe 写着 `PlaySound("Swoosh")`。
    
    - Godot 会利用反射机制（Reflection）在那个时间点去执行这个函数。这不需要插值，它是瞬发的。

### 5. 混合形状轨道 (Blend Shape Track) —— 表情/变形

- **作用：** 专门用于控制 3D 模型（MeshInstance3D）的变形器（Morph Targets）。

- **场景：** 捏脸系统、人物张嘴闭嘴、眨眼。它的数据通常是从 0.0（没变形）到 1.0（完全变形）。

### 6. 音频播放轨道 (Audio Playback Track)

- **作用：** 把声音和动作绑死。

- **优势：** 你不需要写代码“播放攻击动画时播放攻击音效”。你直接把音效拖进动画的时间轴里。动画走到那一帧，声音自动响。

### 7. 动画播放轨道 (Animation Playback Track) —— 俄罗斯套娃

- **作用：** 一个动画播放器可以控制另一个动画播放器。

- **场景：** 你有一个“过场动画（Cutscene）”，它是一个总的时间轴。这个轨道可以用来安排：“第1秒，让角色A播放‘走路’；第3秒，让角色B播放‘招手’”。


## 架构调研

这是一个非常关键的视角转换。如果你关注的是 **“如何优雅地将动画系统挂载到现有的OOP对象（如Tile/Building）上”**，而不是底层的SIMD数学优化，那么你实际上是在寻找一种 **“补间动画系统（Tweening System）”** 或 **“动作系统（Action System）”** 的架构设计。

这种架构的核心挑战在于：如何让一个独立的动画管理器（Manager）去控制那些它并不拥有的对象（OOP Objects）。

在这方面，有两个经典的 C++ 开源项目是教科书级别的参考，它们完美展示了“OOP + 独立动画系统”的结合：

### 1. Cocos2d-x 的 ActionManager (经典 OOP 方案)

为什么它是最佳参考？

Cocos2d-x 是一个纯 C++ 的引擎，它的核心架构和你描述的非常像：由 Director 控制主循环，场景中有大量的 Node（类似你的 Object）。它并没有把动画逻辑写死在 Node 里，而是设计了一个独立的 ActionManager。

- **架构模式**：组件式/外挂式。
    
- **工作流**：
    
    1. 你创建一个动作（如 `MoveTo`, `ScaleTo`）。
        
    2. 你调用 `object->runAction(action)`。
        
    3. `ActionManager` 接管这个动作，每帧更新它，并把计算结果写回 `object` 的 `setPosition`/`setScale`。
        

**源码“藏宝图” (GitHub: cocos2d/cocos2d-x)**

- **管理器 (ActionManager)**
    
    - 文件：`cocos/2d/CCActionManager.cpp`
        
    - **看点**：它是如何维护一个 `HashMap<Node*, Array*>` 的。这就是你需要的“实体注册表”的简单实现。它通过对象指针（`void*` 或 `Node*`）作为 Key，找到该对象当前正在运行的所有动画。
        
- **动作基类 (Action)**
    
    - 文件：`cocos/2d/CCAction.cpp`
        
    - **看点**：`step(dt)` 方法。这是动画更新的核心。注意它如何设计 `update(float time)` 虚函数，让子类去实现具体的逻辑（移动、旋转等）。
        
- **如何修改对象**
    
    - 文件：`cocos/2d/CCActionInterval.cpp` (查看 `MoveTo::update`)
        
    - **看点**：`_target->setPosition(...)`。这就是最直观的“写回”逻辑。
        

---

### 2. Godot Engine 的 Tween 系统 (现代 C++ 方案)

为什么它是最佳参考？

Godot 的 C++ 源码比 Cocos2d-x 更现代。Godot 的 Tween 类是一个非常强大的独立对象，它可以“绑定”到任何对象的任何属性上。这正是你想在 Tile 系统中做的事情（例如：让 Building A 的高度在 2 秒内从 0 变到 10）。

- **架构模式**：信号/属性绑定（Property Binding）。
    
- **核心优势**：它不依赖特定的基类，而是依赖“属性名”或“方法指针”，解耦更彻底。

**源码“藏宝图” (GitHub: godotengine/godot)**

- **Tween 实现**
    
    - 文件：`scene/animation/tween.cpp`
        
    - **看点**：查看 `Tween::interpolate_property` 方法。它展示了如何记录“起始值”、“目标值”、“持续时间”以及“目标对象的指针”。
        
- **更新逻辑**
    
    - 文件：`scene/animation/tween.cpp` 中的 `_process` 函数
        
    - **看点**：它是如何计算进度，然后通过 C++ 的 `Variant` 机制或直接的方法调用将新值赋予对象的。

---

### 3. 轻量级 C++ 方案：Tweeny

如果你觉得游戏引擎的代码太庞大，**Tweeny** 是一个 Header-only 的 C++ 库，它只做一件事：计算值。它完全不依赖你的 Object 结构，非常适合作为你系统的“核心计算内核”。

- **GitHub**: `mobius3/tweeny`
    
- **架构特点**：它把“动画”看作一种值的变化，而不是绑定在对象上的行为。你可以用它算出值，然后在你的 UpdateLogic 里赋值给 Object。

---

### 结合你的需求：推荐的“混合架构”蓝图

基于上述参考，针对你的 `Building/Tile` 系统，我建议的架构图如下。这比之前的 ECS 计划更侧重于**接口设计**：

**核心组件设计**

1. **AnimationHandle (句柄)**
    
    - 不要直接持有指针。返回一个 `int32_t` ID 给业务层。
        
    - 参考 EnTT 的 ID 设计。
        
2. **AnimationSystem (单例/管理器)**
    
    - **数据结构**：`struct ActiveAnim { void* targetObj; float timer; float duration; ... }`
        
    - **Update 循环**：
        
        C++
        
        ```
        void Update(float dt) {
            for (auto& anim : activeAnims) {
                anim.timer += dt;
                float progress = Ease(anim.timer / anim.duration);
        
                // 关键点：这里进行“桥接”
                // 可以在初始化时绑定 lambda，避免虚函数开销，也避免硬编码类型
                anim.applyCallback(anim.targetObj, progress); 
            }
        }
        ```
        
3. 桥接接口 (The Bridge)
    
    这是最关键的部分。你需要一个简洁的 API 来连接你的 OOP 对象和动画系统。
    
    C++
    
    ```
    // 你的业务代码 (OOP层)
    void BuildingObject::OnConstruct() {
        // 目标：让建筑物在 1 秒内从地下升起
    
        // 方案 A: 类似于 Godot/Cocos (简单直观)
        AnimSystem::Get()->Animate(this)
            .Property(&BuildingObject::SetHeight) // 绑定 Setter
            .From(0.0f)
            .To(10.0f)
            .Duration(1.0f)
            .Ease(Ease::OutBounce)
            .Play();
    
        // 方案 B: 使用 Lambda (最灵活，解耦最强)
        AnimSystem::Get()->Run(1.0f, [this](float progress) {
            // 动画系统不需要知道 BuildingObject 是什么
            // 它只负责回调这个 lambda，传入 0.0~1.0 的进度
            float currentH = Lerp(0.0f, 10.0f, progress);
            this->SetHeight(currentH);
        });
    }
    ```


## 引擎现状

渲染线程做 Update。

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层（NAPI/JNI）                        │
│                  NativeMapView::DrawFrame()                  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      C API 层                                │
│              MapUpdate(world_ptr_, duration)                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   MapSystem 层（渲染系统）                   │
│         MapSystem::UpdateFrame(duration)                     │
│              ↓                                               │
│         MapSystem::updateFrameImpl()                         │
│              ├─ 计算帧时间                                   │
│              ├─ 更新帧号                                     │
│              └─ 调用 World::updateFrame()                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   World 层（业务逻辑）                       │
│              World::updateFrame(duration)                    │
│              ├─ MailboxReceive()                             │
│              ├─ AnimationManager::updateFrame()              │
│              ├─ OverlayManager::updateFrame()                │
│              ├─ DynamicFPSControllerSystem::Update() ← 稳帧 │
│              ├─ VectorMapManager::update()                   │
│              └─ updateCamera()                               │
└─────────────────────────────────────────────────────────────┘

```



```
渲染线程 DrawFrame()
  ↓
MapUpdate(world_ptr_, duration)  [napi_mapview.cc:224]
  ↓
MapSystem::UpdateFrame(duration)  [glmaplib.cc:420]
  ↓
MapSystem::updateFrameImpl()  [map_system.cc:337]
  ↓
world->updateFrame(mFrameDuration)  [map_system.cc:381]
  ↓
┌─────────────────────────────────────────────────────────────┐
│ World::updateFrame(duration)  [world.cc:959]                │
├─────────────────────────────────────────────────────────────┤
│ 1. MailboxReceive()                                         │
│ 2. mpAnimationManager->updateTimeStamp(duration)            │
│ 3. mpAnimationManager->updateFrame(getFrameNumber())        │
│ 4. mpScanManager->Update(duration)                          │
│ 5. mpAllOverlayManager->updateFrame(duration)               │
│ 6. mSkyboxPro->UpdateFps()                                  │
│ 7. mStylizationSys->Update()                                │
│ 8. getBuildingManager()->UpdateFps()                        │
│ 9. mpFpsControllerSys->Update(duration)  ← 稳帧动画        │
│10. mpFpsControllerSys->Clear()                              │
│11. mScenerManagers[i]->update(duration)                     │
│12. mpVectorMapManager->update(duration)                     │
│13. mpAnnotationManager->updateAnnotationAnimation(duration) │
│14. mpRouteManager->updateRoutesAnimation()                  │
│15. globe_manager_ptr_->update()                             │
│16. MailboxReceive()  (第二次)                               │
│17. updateCamera()                                           │
└─────────────────────────────────────────────────────────────┘

```