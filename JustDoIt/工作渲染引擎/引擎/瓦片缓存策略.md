
`ScenerManager` 管理-> `MapLayerCacheManager` 管理-> `ScenerLRUCache` 管理-> `Scener`。


`ScenerManager` 类中持有了一个 `MapLayerCacheManager` 的shared_ptr类指针：
`mutable std::shared_ptr<MapLayerCacheManager> mMapLayerCacheManager;`

有一个 `getMapLayerCacheManager` 函数将该shared_ptr透传给了其他地方：
```C++
std::shared_ptr<MapLayerCacheManager> ScenerManager::getMapLayerCacheManager() const {  
    return mMapLayerCacheManager;  
}
```

`MapLayerCacheManager` 类包含管理缓存的各种操作包括瓦片缓存对象 `ScenerLRUCache` ：
`std::unique_ptr<cache::ScenerLRUCache> recycle_cache_layers_;`

`ScenerLRUCache` 的实例化可以有一个或三个参数：

```C++
ScenerLRUCache(size_t max_size);

ScenerLRUCache(
		size_t max_size, 
		std::function<void(const std::shared_ptr<Scener>&)> on_delete_callback,  
        std::function<bool(const std::shared_ptr<Scener>&)> is_resident_policy);
```

在 `MapLayerCacheManager` 类的构造函数 `MapLayerCacheManager::MapLayerCacheManager` 中 `recycle_cache_layers_` 被实例化：

```C++
recycle_cache_layers_ =  
  std::make_unique<cache::ScenerLRUCache>(  
    cache_mem_siz, 
    [&](const std::shared_ptr<Scener>& scener) {  
      DelayDestroyScener(scener);  
    },  
    [&](const std::shared_ptr<Scener>& scener) {  
        auto ret = scener->getScenerID()->isOverlapArea(mResidentArea);    
        return ret;  
    });
```


`ScenerLRUCache` 中管理着一个缓存List `cache_items_list_` ：
`std::list<std::shared_ptr<Scener>> cache_items_list_;`






`VectorMapManager` 中管理着  `NerdTileManager` 和 `BaseTileManager` ：

```C++
   typedef  std::shared_ptr<NerdTileManager> NerdTileMgrPtr;
   typedef  std::shared_ptr<BaseTileManager> BaseTileMgrPtr;
   
   // 持有mgr保证运行过程中不会有mgr的销毁，否则handleTask执行产生野指针风险
   NerdTileMgrPtr mHDWPMgr[WP_LOD_NUM] = {nullptr, nullptr, nullptr};  
   BaseTileMgrPtr mSDWPMgr[WP_LOD_NUM] = {nullptr, nullptr, nullptr};
```

`BaseTileManager` 是用于管理瓦块的父类，相应子类有 TrafficTileManager / StreetViewTileManager / VectorTileManager等，继承了 `SceneManager` 。

`NerdTileManager` 继承了`BaseTileManager` 。