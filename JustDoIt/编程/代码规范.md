
## 头文件

**1. 头文件保护**

所有头文件都应该使用 `#define` 或 `#pragma once` 来防止头文件被多重包含。其中`#define`的命名格式当是： `<PROJECT>_<PATH>_<FILE>_H_`。

**2. 头文件应该自足**


**3. 避免使用前置声明**

尽可能地避免使用前置声明。使用 `#include` 包含需要的头文件。
前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。极端情况下，用前置声明代替 `include` 甚至都会不知情的情况下改变代码的含义：
```
// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
```

如果 `#include` 被 `B` 和 `D` 的前置声明替代，我们只有B和D的前置声明，编译器无法确定D是B的派生类，因为它没有完整的定义。因此，编译器会选择匹配参数类型更精确的函数，即f(void*)。`test()` 就会调用 `f(void*)`：
```
// bad_user.cc:
struct B;
struct D;
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(void*)
```

**4. 内联函数不包循环**

只有当函数只有 10 行甚至更少时才将其定义为内联函数。

谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！

另一个实用的经验准则：内联那些包含循环或 `switch` 语句的函数常常是得不偿失 (除非在大多数情况下，这些循环或 `switch` 语句从不被执行)。

重要的是知道，有些函数即使声明为内联函数，也不一定总会被编译器内联。例如：虚函数和递归函数一般不会被正常内联。

**5.  `#include` 的路径及顺序**

使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：`本文件的相关头文件`、`C 库`、`C++ 库`、`其他库的 .h`、`本项目内的 .h`。

**6. 命名空间**

命名空间中注意不要使用缩进。

不要在命名空间 `std` 内声明任何东西，包括标准库的类前置声明。在 `std` 命名空间声明实体是未定义的行为，会导致不可移植。声明标准库下的实体，需要包含对应的头文件。

禁止在头文件的全局作用域中使用using namespace foo，会污染命名空间。在头文件的局部作用域或者实现文件（cc 或者 cpp 文件）中，允许适当使用。

**7. 局部变量**

应使用初始化的方式替代声明再赋值。