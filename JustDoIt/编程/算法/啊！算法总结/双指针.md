## 双指针

> [!Tip]
> 在运行 `fast = fast.next.next` 之前，需要检查 `fast` 和 `fast.next` 不为空

### Q：两链表交点

小巧思是 a+c+b = b+c+a，ptrA 和 ptrB 都从另一个串串🍢的头部再来一次。

![400](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/Clipboard_Screenshot_1751351528.png)

#### List


---
## 快慢指针

### Q：链表环的起点

小巧思是：

```
slow = a+b
fast = a + n(b+c) + b // n是假设fast指针已经转了n圈
fast = 2 * slow

==> a = c + (n−1)(b+c)
```

意味着新起两个指针，分别从head和相遇点开始走，直到相遇，就是一个走了a一个走了c。

![400](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/202507011634629.png)

#### List

LC 287. 寻找重复数 

---
## 假脑袋

当结果链表有可能为空的时候，就需要假脑袋。
``` cpp
ListNode* dummy = new ListNode(-1);
...
return dummy->next;
```

如果还设计拼接新的链表，那么假脑袋需要一个新的迭代器。
注意新链表的每个节点不能浅拷贝，而是需要新构建节点。
``` cpp
ListNode *iter = dummy; // 从 iter->next 开始赋有效值
iter->next = ptr1->val; // ❌
iter->next = new ListNode(ptr1->val); // ✅
```

#### List

LC 2. 两数相加
LC 21. 合并两个有序链表