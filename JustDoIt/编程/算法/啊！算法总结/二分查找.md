## 二分模板

### 左闭右闭 \[ ]

适用于查找可以通过访问数组中的**单个索引**来确定的元素或条件。

⚠️特别注意：
- 适用于精确查找目标值（`nums[mid] == target`）。
- 左闭右闭，right 也必须是有效的索引值，所以是 size - 1：`int right = nums.size() - 1;`
- 每次迭代会排除mid（因为mid已经检查过）。
- 终止时left > right，表示未找到目标值。

``` cpp
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0;
  int right = nums.size() - 1; // 特别注意，由于是左闭右闭，所以这里要是size-1
  while(left <= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```


⚠️特别注意：
- 适用于查找插入位置或最接近的值（如findClosestElements）。
- 左闭右闭，right 也必须是有效的索引值，所以是 size - 1：`int right = nums.size() - 1;`
- right = mid保留mid在区间内（可能为目标值）。
- 终止时left == right，指向唯一候选位置。

``` cpp
int left = 0, right = arr.size() - 1;  
while (left < right) {  
    int mid = left + (right - left) / 2;  
    if(arr[mid] < x) {  
        left = mid + 1;  
    } else {  
        right = mid;  
    }  
}
return left;
```

### 左闭右开 \[ )

适用于查找需要访问数组中**当前索引及其直接右邻居索引**的元素或条件。

⚠️特别注意：
- 左闭右开，所以 right 是 size：`int right = nums.size();`
- 向下取整：`int mid = left + (right - left) / 2; // 向下取整`

``` cpp
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0;
  int right = nums.size();
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.size() && nums[left] == target) return left;
  return -1;
}
```

### 左开右闭 (]

适用于查找需要访问数组中**当前索引及其直接左邻居索引**的元素或条件。

⚠️特别注意：
- 左开右闭，right 也必须是有效的索引值，所以是 size - 1：`int right = nums.size() - 1;`
- 向上取整：`int mid = left + (right - left + 1) / 2; // 向上取整`

``` cpp
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;
    
  int left = 0;
  int right = nums.size() - 1;
  
  while(left < right){
    // 重点差异在这里，因为是把右侧作为主体，和左侧元素比较
	// 所以这里向上取整很关键
    int mid = left + (right - left + 1) / 2;
    ...
  }
}
```

### 左开右开 ( )

适用于查找需要访问数组中**当前索引及其直接左右邻居索引**的元素或条件。

``` cpp
int binarySearch(vector<int>& nums, int target){
    if (nums.size() == 0)
        return -1;

    int left = 0, right = nums.size() - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

## 经典题型

### 旋转数组

LC 33 /  153 / 162

> [!Tip]
> 重点是看什么时候“摔下悬崖”。

比如`nums = [4,5,6,7,0,1,2]`：
- `if nums[0] <= nums[I]` 那么 `nums[0]` 到 `nums[i]` 为有序数组。
- `if nums[i] < nums[0]` 那么在 0～i 区间的某个点处摔下了悬崖，那么 i+1 到最后一个数字的区间为有序数组，并且所有的数字都小于 `nums[0]` 且大于 `nums[i]`。

``` cpp
int findMin(vector<int>& nums) {  
    int len = nums.size();  
    int left = 0, right = len - 1;  
    while(left < right) {  
        int pivot = left + (right - left) / 2;  
        if(nums[pivot] < nums[right]) {  
            // 当 nums[pivot] < nums[right] 时，pivot 本身可能就是最小值  
            // 所以不可跳过
            right = pivot;  
        } else {  
            // 已知nums互不相同，left+1 跳过无效区间
            // pivot已经不可能是我们在寻找的最小值
            // 说明最小值必然在 pivot 右侧（含 pivot+1）  
            left = pivot + 1;  
        }  
    }  
    return nums[left];  
}

int findMax(vector<int>& nums) {  
    int len = nums.size();  
    int left = 0, right = len - 1;  
    while(left < right) {  
	    // 因为是把右侧作为主体，和左侧元素比较
	    // 所以这里向上取整很关键
        int pivot = left + (right - left + 1) / 2;
        // pivot滚下悬崖，left留在最高峰
        if(nums[left] < nums[pivot]) {
            // 当 nums[left] < nums[pivot] 时，pivot 本身可能就是最大值
            // 所以不可跳过  
            left = pivot;  
        } else {  
            // 已知nums互不相同，pivot已经不可能是我们在寻找的最大值
            // 说明最大值必然在pivot左侧
            right = pivot - 1;  
        }  
    }  
    return nums[left];  
}
```