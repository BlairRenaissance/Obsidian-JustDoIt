
字符串匹配中，要在更长的字串中找出是否包含模式串，使用 KMP 算法，本质上是通过获知模式串中的重复字符串，记录前一个重复字符串的末尾位置，进行跳转，来减少重复。

- 比如待匹配的模式串是 `s = "ABCABD"`
- 对于第二个A来说，第一个A是重复字串，则记录其末尾位置1
- 对于第二个AB来说，第一个AB是重复字串，则记录其末尾位置2
- 当最后D和别的字串没匹配上时，显然能走到这里说明此时两个字串前面都有AB，（比如...ABE和...ABD没匹配上）
- 因此，模式串中的指针先不跳到头部开始重新匹配，而是跳到第一个AB结尾处进行尝试。

想要被匹配的字串是 `ABCABDABCABC`。
当匹配到 ABG 所以失败时，我们先不从头尝试，而是往前挪到上一个有重复字符串（也就是AB）出现的位置末尾（前缀尾）开始尝试。

对应题目：
- [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

---
### KMP算法的主要步骤

1. 预处理模式串，生成一个部分匹配表（next数组）。

2. 使用这个表进行高效的字符串匹配。

#### 部分匹配表（next数组）

对于模式串W（长度为m），部分匹配表next是一个长度为m的数组。`next[i]`表示在子串`W[0:i]`（前i+1个字符）中，最长的相等真前缀与真后缀的长度（不包括整个子串）。例如：

模式串: "ABCDABD"

对应的next数组：

```
- next[0] = 0（单个字符，没有真前缀和真后缀）

- next[1] = 0（"AB"，真前缀"A"，真后缀"B"，没有相等）

- next[2] = 0（"ABC"，没有相等的真前缀和真后缀）

- next[3] = 0（"ABCD"，同上）

- next[4] = 1（"ABCDA"，真前缀"A"和真后缀"A"相等，长度为1）

- next[5] = 2（"ABCDAB"，真前缀"AB"和真后缀"AB"相等，长度为2）

- next[6] = 0（"ABCDABD"，没有相等的真前缀和真后缀）
```

#### 构建next数组的步骤（预处理）

```
1. 初始化两个指针：i（后缀末尾）和j（前缀末尾，也表示当前最长相等前后缀的长度）

2. 初始化next[0] = 0

3. 遍历模式串（i从1到m-1）：

- 如果当前字符W[i]等于W[j]，则j增加1，next[i]=j，然后i增加1。

- 如果不相等：

- 如果j为0，则next[i]=0，i增加1。

- 否则，令j = next[j-1]（回退到前一个位置的最长前缀处）
```

#### 匹配过程

```
1. 初始化两个指针：i（主串S的指针）和j（模式串W的指针）

2. 遍历主串S（i从0到n-1）：

- 如果S[i]等于W[j]，则i和j同时增加1。

- 如果不相等：

- 如果j大于0，则j = next[j-1]（利用部分匹配表跳过一些字符）

- 否则（j为0），i增加1（模式串已经无法回退，主串指针后移）

1. 如果j等于模式串长度m，则匹配成功，返回匹配的起始位置i-m；然后为了继续匹配，可以令j = next[j-1]（寻找下一个可能的匹配）
```

---
### KMP算法的时间复杂度

- 预处理：O(m)，其中m是模式串的长度。

- 匹配：O(n)，其中n是主串的长度。

因此总时间复杂度为O(n+m)。

---
### 示例

#### 构建next数组

模式串：W = "ABABC"

```
- m = 5

- next[0] = 0（初始化）

- i=1, j=0: W[1]='B' != W[0]='A' -> j=0, 所以next[1]=0, i++

- i=2, j=0: W[2]='A' == W[0]='A' -> j=1, next[2]=1, i++

- i=3, j=1: W[3]='B' == W[1]='B' -> j=2, next[3]=2, i++

- i=4, j=2: W[4]='C' != W[2]='A' -> j>0, 所以j=next[1]=0（因为next[j-1]=next[1]=0）

然后比较W[4]和W[0]：不相等，且j=0，所以next[4]=0, i++（结束）

next数组：[0, 0, 1, 2, 0]
```

#### 匹配过程

主串S = "ABABABABC"

```
模式串W = "ABABC", next = [0,0,1,2,0]

i=0, j=0: S[0]='A'==W[0] -> i=1, j=1

i=1, j=1: S[1]='B'==W[1] -> i=2, j=2

i=2, j=2: S[2]='A'==W[2] -> i=3, j=3

i=3, j=3: S[3]='B'==W[3] -> i=4, j=4

i=4, j=4: S[4]='A'!=W[4]='C' -> j>0, j=next[3]=2

现在比较S[4]和W[2]：S[4]='A'==W[2]='A' -> i=5, j=3

i=5, j=3: S[5]='B'==W[3]='B' -> i=6, j=4

i=6, j=4: S[6]='A'!=W[4]='C' -> j>0, j=next[3]=2

比较S[6]和W[2]：相等，i=7, j=3

i=7, j=3: S[7]='B'==W[3]='B' -> i=8, j=4

i=8, j=4: S[8]='C'==W[4]='C' -> j=5，匹配成功，返回位置8-4=4

所以匹配位置从4开始（即S[4]到S[8]）。
```