
 ## 🛠️ C++ 构建流水线概览
1. 在 C++ 中，从源代码到最终的二进制文件（如 .exe）通常要经历一个“流水线”过程。我们可以将其简化为以下几个核心阶段：
	 * 预处理 (Preprocessing) 📝：处理所有以 # 开头的指令（如 `#include`）。实际上是一个文本处理工具。会直接把被包含文件的内容“复制并粘贴”到当前位置。
	 * 编译 (Compilation) ⚙️：将预处理后的代码转换为机器代码，生成目标文件 (Object Files, .obj)。它独立处理每一个 .cpp 文件。如果你的代码中有语法错误，编译器会在这个阶段报错。
		 * Debug (调试)：不进行优化，运行较慢，但方便调试代码。
		 * Release (发布)：编译器会进行大量优化以提升运行速度，适用于最终用户。
	 * 链接 (Linking) 🔗：将所有的 .obj 文件“缝合”在一起，形成最终的可执行程序。当你在 main.cpp 中调用了定义在 log.cpp 里的函数时，链接器负责把这两个文件关联起来。如果找不到定义，就会出现令人头疼的“无法解析的外部符号”错误。


 ## ⚙️ 编译器
2. 编译器的唯一职责是将文本形式的源代码转换成一种中间格式，即目标文件 (Object File, .obj)。在这个过程中，编译器会完成几件大事：
	 * 预处理 (Preprocessing)：处理宏、包含文件等。预处理只是简单的文本替换。
	 * 词法/语法分析 (Tokenizing & Parsing)：将代码整理成编译器能理解的结构。
	 * 生成抽象语法树 (AST)：代码的逻辑表示。
	 * 代码生成 (Code Generation)：将 AST 转换为机器码（CPU 指令）。
3. 翻译单元 (Translation Unit) 
	- 在 C++ 中，编译器并不直接处理“项目”，它只处理翻译单元。
	- 什么是翻译单元？ 当你告诉编译器编译一个 .cpp 文件时，这个文件加上它所包含（#include）的所有内容，合起来被称为一个翻译单元。
	- 文件无关性：C++ 实际上并不关心文件。文件只是向编译器提供源码的载体。你可以创建后缀名为 .cherno 的文件，只要告诉编译器将其视为 C++ 代码，它就能正常工作。
	 * 一对一关系：通常情况下，每个 .cpp 文件都会生成一个对应的 .obj 文件。
4. 目标文件 (.obj) 与汇编代码
	- 编译后的机器码是二进制的，人类无法阅读。为了理解编译器做了什么，我们可以让它输出汇编代码（.asm）。
 5. 调试 (Debug) 模式的行为：
	   * 在不开启优化的情况下，编译器会生成非常冗余的代码，以确保代码逻辑与你写的每一行文本严格对应，方便调试。
	   * 常量折叠 (Constant Folding)：如果你写 return 5 * 2;，优秀的编译器不会在运行时计算乘法，而是在编译阶段直接将其替换为 10。
	   * 函数调用：当你在一个文件中调用另一个文件的函数时，编译器会生成一条 call 指令。由于此时编译器不知道函数的具体地址，它会留下一个“占位符”，等待链接器来填补这个地址。
6. 优化 (Optimization) 
	- 在 Release 模式（或开启最大速度优化）下，编译器的行为会发生剧变。
	 * 死代码删除：如果编译器发现你调用了一个函数但没有使用它的返回值，且该函数没有副作用，它可能会直接把这行代码删掉。
	 * 寄存器优化：它会极力减少对内存的读写，尽可能在寄存器中完成所有操作，使生成的指令集变得非常精简。


 ## 🧩 链接器 (Linker) 的核心职责
7. 在编译器独立处理完每一个 .cpp 文件并生成 .obj 目标文件后，链接器接过接力棒。它的主要工作是：
	 * 符号解析：找到代码中引用的每个函数或变量的具体位置。
	 * 合并文件：将所有 .obj 文件以及引用的库（如 C++ 标准库）合并成一个最终的可执行文件（.exe）或库文件。
	 * 确定入口点：告诉操作系统程序从哪里开始运行（通常是 main 函数）。
8. 报错代码的“翻译官”：C 开头 vs LNK 开头 🚩
	 * C 开头的错误（如 C2143）：编译阶段错误。通常是语法错误（漏分号、拼写错误等）。此时链接器还没开始工作。
	 * LNK 开头的错误（如 LNK1104）：链接阶段错误。这意味着你的语法没问题，但链接器在拼图时发现“缺了块”或“多了块”。


 ## 📦 变量 (Variables)：内存中的数据
9. 变量的本质是什么？
	- 在 C++ 中，变量的本质就是内存（RAM）。当你创建一个变量时，你实际上是在告诉编译器：“请在内存中帮我留出一块空间，并给它起个名字，这样我以后就能找到它。”
	 * 程序运行逻辑：代码被加载到内存中，变量也存储在内存里。CPU 从内存中读取这些数据，进行处理，然后再写回内存。
	 * 强类型语言：C++ 是一门强类型语言，这意味着每个变量都必须明确它的类型。类型决定了这块内存的大小以及计算机如何解释这些二进制位。
10. 变量只是我们为了方便而给内存地址起的“绰号”。
	 * 类型决定了分配多少内存。类型只是对内存中二进制数据的一种“解释方式”。
	 * 名字让我们能找到这块内存。
	 * 值就是这块内存里存储的二进制数据。



 ## 📥 函数 (Functions)：逻辑的封装
 * 返回类型 (Return Type)：函数执行完后给你的“结果”是什么类型的？
 * 函数名 (Name)：我们如何调用这个逻辑？
 * 参数列表 (Parameters)：这个函数需要哪些“输入数据”才能工作？
 * 函数体 (Body)：在大括号 {} 之间运行的实际代码。


 ## 📍 指针 (Pointers)：内存的地址簿
1. 指针其实只是一个存储内存地址的数字。仅此而已。
2. 内存：一张巨大的地图 🗺️。可以把计算机的内存（RAM）想象成一条长长的街道，街道上有很多房子。
	 * 每个房子都有一个门牌号（内存地址）。
	 * 每个房子里面住着数据（变量的值）。
	- 指针就是一个地图路线，上面记录了某个房子的门牌号。
3. 指针的声明与类型 🖊️
	- 在 C++ 中，我们用星号 * 来表示指针。
	 * 指针只是一个地址数字。它本身并不包含数据，它只是告诉你去哪里找数据。
	 * void*：这意味着我们不在乎这个地址里存的是什么数据类型。因为指针本身只是一个地址（数字），无论它指向的是 int 还是 double，地址本身的大小在同一个系统上总是一样的（64位系统上通常是 8 字节）。
	 * 类型化的指针：如果我们写 int* ptr，这并不是说指针本身变了，而是我们告诉编译器：“在这个地址里存的是一个整数”。这会影响我们后续如何读写这块内存。
	- 如何获取地址？取地址符 & 🔍 `int* ptr = &a; // ptr 现在存的是 a 的内存地址`
	- 如何使用地址？解引用 * 🔓 `*ptr = 10; // 顺着 ptr 找到内存位置，把里面的值改成 10`


 ## ⛓️ 引用 (References)：指针的“孪生兄弟”
1. 引用的本质是：。
	 * 指针：是一个新的变量，里面存着别人的地址。
	 * 引用：不是新变量，只是给现有的变量起了一个别名 (Alias)。它在底层通常也是通过指针实现的，但在语法层面上，它表现得就像是变量本身。
2. 引用与指针的三大区别：
	 * 必须初始化：不能创建一个空的引用，它必须在创建时就“依附”于一个已有的变量。
	 * 不可更改指向：一旦一个引用成了 a 的绰号，它这辈子就只能是 a 的绰号，不能中途变成 b 的。
	 * 语法更简洁：不需要使用 * 来解引用，直接像普通变量一样用就行了。


 ## 🏗️ C++ 类 (Classes) 与结构体 (Structs)
1. 结构体 vs 类 在 C++ 中几乎完全一样，唯一的区别是默认可见性：
	 * Class：默认是 private（私有的），除非你手动改为 public。
	 * Struct：默认是 public（公开的）。
2. 既然我们已经定义了类，接下来就要讨论如何“初始化”它。构造函数是一种特殊的成员函数，它在每次你创建一个类的新对象时自动运行。
	 * 主要任务：初始化类中的变量，防止它们包含随机的内存垃圾值。
	 * 语法特点：它的名字必须与类名完全相同。它没有返回类型（连 void 都不写）。
3. 当一个对象超出了它的作用域（比如函数运行结束，局部变量被销毁）时，析构函数 (Destructor) 就会被调用。它通常用于清理资源（比如释放内存、关闭文件）。


  ## 🧬 继承 (Inheritance)：构建类的层级
1. 在内存中，派生类对象实际上就是基类变量和派生类变量的组合。
	- 只要 Player 继承了 Entity，它就自动获得了 Entity 的所有非私有功能，不需要再写一遍。
	 * 当创建一个 Player 对象时，它在内存中的空间包含了 Entity 的 x, y 以及 Player 自己的 Name。
	 * 多态基础：因为 Player 包含了一个完整的 Entity，所以任何接受 Entity 的地方（比如函数参数），通常也可以接受一个 Player。

> [!Tips]
> 如果我们写出这样的代码：
> ```
> Entity* e = new Player("Cherno");
> std::cout << e->GetName() << std::endl;
> ```
>
> 你觉得在没有做任何特殊处理的情况下，程序会打印出什么？
>  * "Entity"（调用了指针类型 Entity 对应的函数）
>  * "Cherno"（调用了实际对象 Player 对应的函数）
> 
> 其实，在没有进行“特殊处理”的情况下，答案是 "Entity" 🏠。
> 虽然你创建的是一个 Player 对象，但由于指针的类型是 Entity*，C++ 默认会去 Entity 类里寻找 GetName。这种行为被称为 静态联编 (Static Dispatch) ⚡，编译器在编译阶段就根据指针类型决定了调用哪个函数，因为这样运行速度最快。
> 
> 如果要让程序在运行时“聪明”一点，识别出它其实是一个 Player 并打印出 "Cherno"，我们就需要用到一个核心内容：虚函数 (Virtual Functions)。


 ## 🎭 虚函数与动态联编
1. 我们在基类函数前加上 virtual 关键字，就开启了 动态联编 (Dynamic Dispatch)。
	 * 虚表 (V-Table) 📜：当一个类包含虚函数时，编译器会为它创建一个“虚函数表”。这个表就像一个索引，记录了该类及其派生类中所有虚函数的实际地址。
	 * 虚表指针 (vptr) 📍：每个对象实例都会多出一个隐藏的指针，指向它所属类的虚表。
	 * 运行时的查找：当通过 Entity* 调用 GetName 时，程序会先通过 vptr 找到虚表，再从表中找到 Player 版本的函数地址。
	- 虽然这带来了一点点性能开销（多了一次内存查找），但它实现了 C++ 中极其重要的**多态 (Polymorphism)**。
2. 纯虚函数：有时候，父类的某个行为根本没有默认实现。这时，我们就可以在基类中定义一个纯虚函数：
3. 抽象类：一旦类中包含至少一个纯虚函数，这个类就变成了抽象类。
	 * 不能实例化：不能写 Shape s;，因为编译器不知道如何为一个没有 GetArea 实现的对象分配逻辑。
	 * 强制实现：任何继承 Shape 的子类（如 Circle）必须实现 GetArea，否则子类也会变成抽象类，无法创建对象。
4. 接口：在 C++ 中，如果一个类只包含纯虚函数，而没有成员变量，我们通常称之为接口 (Interface)。它就像一份“合同”，规定了子类必须具备哪些功能。


 ## 🧵 字符串 (Strings) 
1. C 风格字符串 (C-Style Strings) 📜
	- 在最底层，字符串只是一个 字符数组 (char array)。
	- 当写下 `const char* name = "Cherno";` 时，内存里发生的事情是这样的：每一个字母占用 1 个字节；在字符串的末尾，编译器会自动添加一个值为 0 的特殊字符，称为空终止符 (Null Terminator)，写作 \0。
2. std::string 📦
	- 由于直接操作 char* 指针既麻烦又容易出错（比如合并两个字符串时），C++ 标准库提供了一个强大的类：std::string。
	 * 它是一个容器，会自动处理内存分配。
	 * 可以使用 + 号直接拼接字符串，也可以用 .size() 获取长度。
	- 如果要使用它，我们需要在代码顶部添加：`#include <string>`。


 ## 🔐 const
1. const 的本质是一份不改变的合同。当把一个变量声明为 const 时，是在告诉编译器以及其他程序员：“我保证这个变量的值在初始化之后永远不会被改变。”
	 * 代码安全。如果不小心尝试修改一个 const 变量，编译器会立刻报错，拦截潜在的 Bug。
	 * 性能优化：编译器知道这个值不会变，有时可以进行更激进的优化 🏎️。
2. 指针与 const 的“绕口令” 是 C++ 中最容易让人困惑的地方 😵。const 放在指针的不同位置，意义完全不同。
3. 类方法中的 const ：函数名后面跟着一个 const，这里的 const 意味着这个方法是一个只读方法。它保证不会修改类中的任何成员变量。这在传递“常量引用”对象时非常有用，因为你只能调用那些被标记为 const 的方法。

| 语法                 | 含义          | 顺口溜/记忆法           |
| ------------------ | ----------- | ----------------- |
| const int* a       | 指针指向的内容不能变  | 左定内容：const 在 * 左边 |
| int* const a       | 指针本身存的地址不能变 | 右定地址：const 在 * 右边 |
| const int* const a | 内容和地址都不能变   | 左右都定              |


 ## 💥 mutable
正如我们之前看到的，一个 const 方法承诺不会修改类中的任何成员变量。但在某些特殊情况下，你可能需要修改一些“幕后”数据，而这些数据并不影响对象的逻辑状态——比如为了调试而记录某个函数被调用了多少次。
```cpp
class Entity {
private:
    int x, y;
    mutable int debugCount = 0; // 注意这个关键字！
public:
    int GetX() const {
        debugCount++; // 即使在 const 方法中，这也是允许的！
        return x;
    }
};
```

为什么我们要针对这种“调试计数器”使用 const + mutable，而不是直接把整个 GetX() 方法改为非 const 的呢？
如果把函数声明为非 const，它就拥有了修改类中任何成员变量的权限。这听起来很自由，但在实际编程中会遇到一个巨大的障碍。想象一下，你写了一个打印实体的函数： 
```cpp
void PrintEntity(const Entity& e) {
    // 这里的 e 是常量引用，保证不会修改对象
    std::cout << e.GetX() << std::endl; 
}
```
* 如果 GetX() 是非 const 的：上面的代码会报错 ❌。编译器会说：“你承诺不修改 e，但你调用的 GetX 却有权修改它，这不安全！”
 * 如果 GetX() 是 const 的：代码完美运行 ✅。

> [!Tips]
> 假设你的类有一个非常复杂的计算任务 CalculatePath()，每次调用都要耗时 2 秒。为了提速，你决定：
>  * 第一次计算后把结果存起来（缓存）。
>  * 下次调用时如果数据没变，直接返回缓存的结果。
> 
> 如果你希望这个 CalculatePath() 对外表现为一个只读的 const 函数，你觉得你会把哪个变量标记为 mutable？
>  * 最终的路径结果（用于缓存）。
>  * 计算所需的原始数据。
> 
> 如果我们把原始数据标记为 mutable，那就意味着我们可以在一个承诺“不改变对象”的 const 函数里修改这些核心数据。这通常会破坏对象的逻辑一致性。🏠
> 相反，我们应该把缓存的结果标记为 mutable。
>  * 逻辑上：计算出来的路径结果只是原始数据的另一种表现形式。只要原始数据不变，路径就不变。
>  * 技术上：为了让 CalculatePath() const 能够把计算好的结果“偷偷”存起来（以便下次直接用），我们需要权限去修改这个缓存变量。
> 
> 所以，mutable 经常用于这种“逻辑上没变，但物理上需要修改”的场景，比如缓存、互斥锁（Mutex）或调试计数器。


 ## 🏎️ 成员初始化列表 (Member Initializer Lists)
 1. 为什么初始化列表更快？
	 * 在构造函数大括号里赋值：编译器会先调用 m_Name 的默认构造函数创建一个空字符串，然后再在大括号里调用“赋值运算符”把 "Unknown" 存进去。这相当于做了两次工作。
	 * 使用初始化列表：编译器直接调用 m_Name 的构造函数并传入 "Unknown"。这只做了一次工作。
	- 对于简单的 int 可能差别不大，但对于像 std::string 这样复杂的类对象，这种性能差异会变得非常明显。
	- C++ 总是按照成员变量在类中声明的顺序进行初始化，而完全不管你在初始化列表中是怎么排的。
```
class Entity {
private:
    std::string m_Name;
public:
    Entity() {
        m_Name = "Unknown"; // 在大括号里赋值
    }
};
```
但更推荐（且更快）的做法是使用初始化列表：
```cpp
class Entity {
private:
    std::string m_Name;
public:
    // 注意冒号后面的部分
    Entity() : m_Name("Unknown") {
        // 大括号里什么都不用做
    }
};
```


 ## 🏗️ 栈 (Stack) 和 堆 (Heap)。
1. 栈分配 (Stack Allocation) 
	- 最简单、最常用的方式。它的特点是“自动管理”。
	 * 优点：速度极快（只需移动一下栈指针），且不需要担心内存泄漏。
	 * 缺点：一旦离开所在的作用域（大括号 {}），对象就会被自动回收，数据就没了。
2. 堆分配 (Heap Allocation) 
	- 如果希望对象在函数结束后依然存在，或者对象非常庞大，就需要用到 new 关键字。
	 * 优点：对象的生命周期由你控制，可以跨函数、跨作用域存在。
	 * 缺点：速度较慢，而且你必须手动调用 delete e; 来释放内存，否则会导致内存泄漏。
3. 栈与堆的对比

| 特性   | 栈 (Stack)  | 堆 (Heap)                  |
| ---- | ---------- | ------------------------- |
| 分配速度 | 极快         | 较慢                        |
| 生命周期 | 自动（由作用域决定） | 手动（由 new 和 delete 决定）     |
| 使用方式 | Entity e;  | Entity* e = new Entity(); |
| 返回类型 | 对象本身       | 指向对象的指针                   |


 ## 🧠 智能指针 (Smart Pointers)  
 - 虽然 new 很强大，但在现代 C++（C++11 及以后）中，资深的开发者会告诉你：“尽量避免直接写 new 和 delete。”如果你的代码逻辑非常复杂，中间发生了一个错误或者提前 return 了，导致程序没执行到 delete 那一行，内存泄漏就发生了。
 - 为了解决这个问题，C++ 提供了智能指针。既能让我们享受堆内存的灵活性，又能像栈一样在不需要时自动帮我们销毁对象。


 ## 🔑 `std::unique_ptr`：独占所有权
1. unique_ptr 是唯一拥有它所指向的对象的指针。
	- 不可复制：不能把一个 unique_ptr 赋值给另一个指针。如果允许复制，那么两个指针都会认为自己拥有这块内存，当它们都尝试释放内存时，程序就会崩溃。
	- 自动释放：它是基于 RAII（资源获取即初始化）设计的。当 unique_ptr 本身超出作用域被销毁时，它会自动调用 delete 释放它管理的堆内存。
	- 虽然可以直接用 new 初始化，但强烈建议使用 std::make_unique（C++14 引入），因为它更安全且效率稍高。
	- unique_ptr 内部删除了复制构造函数。这样设计的目的就是为了消除“谁该负责释放这块内存”的歧义。
```cpp
#include <memory> // 必须包含这个头文件

{
    // 创建一个管理 Entity 对象的唯一指针
    std::unique_ptr<Entity> entity = std::make_unique<Entity>();
	std::unique_ptr<Entity> e2 = entity; // ❌ 编译错误！
    
    entity->Print(); // 像普通指针一样使用 ->
} // 离开大括号，entity 自动销毁，堆内存自动释放！
```
2. 所有权
	- std::move 🚛 的作用就是转移所有权。一旦你对一个 unique_ptr 使用了 std::move，原来的指针就会变为空（nullptr），而目标指针则接管了那块堆内存。
	- 借用（Borrowing）
		- 在实际开发中，我们经常遇到这样的情况：希望另一个函数帮我处理这个对象，但还想继续拥有它。在不失去所有权的情况下如何让其他函数访问 `unique_ptr` 管理的对象？
		- 传递引用（最推荐的做法）：如果你确定对象一定存在（即指针不为空），直接传递对象的引用是最安全、最简洁的方式。这样函数只需要操作对象本身，完全不需要关心它是被什么指针管理的。
		- 传递原始指针（使用 .get()）：如果你希望函数能够处理“可能为空”的情况，可以使用 unique_ptr 的 .get() 方法。它会返回一个原始指针，但不会转移所有权。

```cpp
void ProcessEntity(Entity& entity) {
    entity.Print(); // 直接使用
}

// 调用时：
ProcessEntity(*entity); // 解引用后传递
```

```cpp
void ProcessEntity(Entity* entity) {
    if (entity) {
        entity->Print();
    }
}

// 调用时：
ProcessEntity(entity.get()); // 获取原始指针地址
```


 ## 🤝 `std::shared_ptr`：共享所有权
1. 引用计数 (Reference Counting) 🔢
	- shared_ptr 的核心是一块被称为 Control Block（控制块）的内存，它记录了当前有多少个 shared_ptr 指向同一个对象。
	 * 创建/拷贝：每当你拷贝一个 shared_ptr，计数器就 +1。
	 * 销毁：每当一个 shared_ptr 离开作用域，计数器就 -1。
	 * 释放：当计数器归零时，它会自动调用 delete 释放内存。
	- 和 unique_ptr 类似，强烈建议使用 std::make_shared创建。
```cpp
#include <memory>

{
    std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
    {
        std::shared_ptr<Entity> copy = sharedEntity; // 拷贝是允许的！计数器变为 2
        copy->Print();
    } // copy 离开作用域，计数器回到 1，内存不会被释放
} // sharedEntity 离开作用域，计数器变为 0，内存正式释放 ♻️
```
2. 引用计数的开销 📉
	- `std::shared_ptr` 虽然方便，但天下没有免费的午餐。它的这些“消耗”和“陷阱”正是 C++ 程序员在性能优化时需要权衡的地方。更新引用计数确实是有消耗的，主要体现在两个方面：
	 * 原子操作 (Atomic Operations)：为了确保在多线程环境下安全，shared_ptr 的计数增加和减少必须是“原子性”的。这意味着 CPU 需要执行特殊的指令来保证操作不被干扰，这比普通的加减法要慢得多。
	 * 内存开销 (Control Block)：当你创建一个 shared_ptr 时，系统不仅要为对象分配内存，还要额外分配一块控制块 (Control Block) 🧠。这个块里存着：
		   * 引用计数 (Reference Count)
		   * 弱引用计数 (Weak Count)
		   * 自定义删除器等其他信息
3. 循环引用问题 (Circular Dependency) 🔄
	- 当两个对象互相持有对方的 shared_ptr 时，就会发生悲剧。
	- A 想释放，但 B 还抓着它；B 想释放，A 也抓着它。两个对象的引用计数永远不会降到 0，内存永远无法释放。这就是内存泄漏 💧。


 ## 🦸‍♂️ std::weak_ptr：救星
1. 为了解决循环引用，C++ 引入了 std::weak_ptr。
	 * 特点：它指向一个由 shared_ptr 管理的对象，但不会增加引用计数。
	 * 作用：它只是一个“观察者”。它不拥有对象，所以不会阻止对象被销毁。
	- 当你想使用 weak_ptr 指向的对象时，你不能直接用 ->。你必须先调用 .lock() 方法。如果对象还活着，.lock() 会返回一个新的 shared_ptr；如果对象已经被销毁了，它会返回一个空的 shared_ptr。
```cpp
struct Player {
    std::weak_ptr<Player> friendPlayer; // 改用 weak_ptr
};
```

> [!Tips]
> 假设你正在写一个“成就系统”。每个Player对象持有一个shared_ptr指向它的Achievement（成就）列表；而每个Achievement为了知道是谁达成了自己，也需要指向Player。
> 为了避免循环引用，你觉得应该把哪一方的指针设为 weak_ptr 比较合理？
>  * Player 指向 Achievement 的指针。
>  * Achievement 指向 Player 的指针。
> 
> 想一想，谁才是这个关系中真正的“主人”？
> 
> Achievement 指向 Player 的指针设为 weak_ptr。在这种所有权明确的关系中，Player 拥有 Achievement（通过 shared_ptr），而 Achievement 只需要知道它属于谁，并不需要控制 Player 的生死。因此，Achievement 使用 weak_ptr 指向 Player 既能安全地访问玩家数据，又打破了循环引用，确保内存能正常释放。


 ## 📚 库与链接 (Libraries & Linking)
1. 实际开发中，我们不可能从零开始写每一个功能。这时候我们就需要使用库。有两大类：
	 * 静态链接 (Static Linking)：在编译阶段，就把库的代码直接“塞”进你的 .exe 文件里。
	 * 动态链接 (Dynamic Linking)：库的代码留在外面（比如 .dll 或 .so 文件），程序运行的时候再去“找”它。


 ## 🧬 C++ 模板 (Templates)
1. 模板并不是真正的函数或类，它是交给编译器的一份“图纸”。
	- 写一个模板时，你是在告诉编译器：“我不知道这个类型是什么，我先管它叫 T。当你看到我真正调用这个函数时，请根据我传进去的类型，帮我现场生成一个对应的函数。”
	 * `template<typename T>`：声明“我要开始画图纸了”，T 就是那个占位符。
	 * 编译器魔法：如果你调用 Print(5)，编译器会偷偷帮你写一个 int 版的函数；如果你调用 Print("Hello")，它会再帮你写一个 string 版的。
```cpp
template<typename T>
void Print(T value) {
    std::cout << value << std::endl;
}
```


📣 宏 (Macros) 
1. 宏是预处理器 (Preprocessor) 的一部分。
	- 在编译器真正开始分析你的 C++ 语法（检查类型、检查括号等）之前，预处理器会先跑一遍。它做的工作本质上非常“暴力”，就是简单的文本替换。
	- 最常见的宏：#define


 ## 🧙 static：“精神分裂”的关键字
1. 在 C++ 中，static 的意义取决于它被写在哪里。其核心用法分成了两大类。
2. 类/函数之外的 static（影响“可见性”）🌐
	- 当你在全局作用域（比如在所有大括号之外）定义一个 static 变量或函数时，它的意思是：“这个变量或函数只在这个文件里可见。”
	 * 这被称为内部链接 (Internal Linkage)。
	 * 如果你在 A.cpp 里定义了一个 static int x，那么 B.cpp 里即便也定义一个 int x，两者也不会打架。它们就像两个重名的邻居，各自住在自己的院子里。🏡
3. 函数内部的 static（影响“生命周期”）⏳
	- 值得重点讨论的是局部静态变量 (Local Static)。
	- 通常情况下，函数内部定义的变量是“随用随毁”的。函数执行完，变量就从栈上消失了。但如果你在它前面加上 static，奇迹就发生了：
		 * 只初始化一次：这行 int i = 0 只会在程序第一次运行到这里时执行。
		 * 长生不老：当函数运行结束时，变量 i 不会销毁。它会一直躲在内存的某个角落，保留着它的值，直到下一次函数被调用。
```cpp
void Increment() {
    static int i = 0; // 局部静态变量
    i++;
    std::cout << i << std::endl;
}
```
4. 类中的 static 🏛️
	- 在类里声明一个 static 变量时，它不再属于某个具体的“对象”，而是属于整个类本身。
	- 静态成员变量 (Static Data Members)
		- 想象创建了 100 个 Entity 对象。如果其中有一个变量被标记为 static，那么在内存中：
		 * 普通变量：会有 100 份（每个对象各有一份）。
		 * static 变量：只有 1 份。所有的对象都共享这同一个变量。
	- 静态成员函数 (Static Methods)
		- 静态函数也属于类。由于它不属于任何具体的对象，它有一个非常重要的限制：它没有 this 指针。
		- 这就意味着静态函数不能访问类里的非静态成员变量，因为它不知道该去读哪个对象的变量。
```cpp
class Player {
public:
    static int x, y; // 静态变量

    void Print() {
        std::cout << x << ", " << y << std::endl;
    }
};

// 静态变量需要在类外定义（Cherno 提到过这个烦人的小细节）
int Player::x;
int Player::y;
```


 ## 🛑 explicit 关键字
```cpp
class Entity {
private:
    std::string m_Name;
    int m_Age;
public:
    Entity(const std::string& name) : m_Name(name), m_Age(-1) {}
    Entity(int age) : m_Name("Unknown"), m_Age(age) {}
};
```
原本你应该这样创建对象：`Entity a("Cherno")`;。但因为有隐式转换，你甚至可以这样写：
```
Entity a = "Cherno"; // 字符串隐式转换为 Entity 对象
Entity b = 22;       // 整数隐式转换为 Entity 对象
```
编译器会认为：“既然你需要一个 Entity，而你给了一个 int，我刚好有一个接受 int 的构造函数，那我就帮你偷偷造一个吧！”
有时候这种“自动转换”会产生意想不到的 Bug。如果你想禁止这种行为，强制要求必须显式调用构造函数，你可以在构造函数前加上 explicit：
```cpp
class Entity {
public:
    explicit Entity(int age) : m_Age(age) {} // 禁止隐式转换
};
```
加上之后，`Entity b = 22;` 就会报错了，你必须写成 `Entity b(22);`。



