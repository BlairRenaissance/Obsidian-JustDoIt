## 构造函数

一旦我们将任何成员变量设为私有（以隐藏我们的数据），我们的类类型就不再是聚合（因为聚合不能有私有成员）。这意味着我们无法再使用聚合初始化：

```cpp
class Foo // Foo is not an aggregate (has private members)
{
    int m_x {};
    int m_y {};
};

int main()
{
    Foo foo { 6, 7 }; // compile error: can not use aggregate initialization

    return 0;
}
```

这时就需要构造函数。

与普通成员函数不同，构造函数的命名有特定的规则： 
- 构造函数的名称必须与类名相同（大小写一致）。对于模板类，此名称不包括模板参数。
- 构造函数没有返回类型（甚至没有 void）。

后续会讨论使用复制、直接和列表初始化来使用构造函数初始化对象之间的区别。

在前面的章节我们了解到，如果需要的话，编译器为了匹配参数为不同类型的函数定义，可能会在函数调用中执行参数的隐式转换。[[3.5 隐式类型转换 Implicit Type Conversion]]

```cpp
void foo(int, int)
{
}

int main()
{
    foo('a', true); // will match foo(int, int)

    return 0;
}
```

构造函数同样会如此：

```cpp
class Foo
{
public:
    Foo(int x, int y)
    {
    }
};

int main()
{
    Foo foo{ 'a', true }; // will match Foo(int, int) constructor

    return 0;
}
```

---
## 构造函数体

构造函数函数体中的语句是在成员初始化列表 [[8.3 Class initialization 初始化]] 执行之后执行的。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x { 0 };
    int m_y { 1 };

public:
    Foo(int x, int y)
    {
        m_x = x; // incorrect: this is an assignment, not an initialization
        m_y = y; // incorrect: this is an assignment, not an initialization
    }
};
```

如果需要初始化成员（例如对于 const 或引用的数据成员），则构造函数体内赋值将不起作用。

一旦成员初始化列表执行完毕，对象即被视为已初始化。一旦函数体执行完毕，对象即被视为已构造。

> [!Best practice] 
> 建议使用成员初始化列表来初始化成员，而不是在构造函数主体中赋值。

对于异常值（比如给除数赋值为0），我们通常不会在成员初始化列表中进行任何验证——我们只会直接使用传入的值来初始化成员，然后在构造函数主体内部使用 `assert` 或 `static_assert` 来检测和处理错误。

---
## 默认构造函数
### 默认构造函数

默认构造函数是不接受任何参数的构造函数。

```cpp
#include <iostream>

class Foo
{
public:
    Foo() // default constructor
    {
        std::cout << "Foo default constructed\n";
    }
};

int main()
{
    Foo foo{}; // No initialization values, calls Foo's default constructor

    return 0;
}
```

如果类类型具有默认构造函数，则值初始化和默认初始化都会调用默认构造函数。因此，对于像上面例子中的 Foo 类这样的类，以下内容本质上是等效的：

```cpp
Foo foo{}; // value initialization, calls Foo() default constructor
Foo foo2;  // default initialization, calls Foo() default constructor
```

那么应该选择哪种呢？

根据前文 [[7.3 Struct#初始化]] 我们可知，值初始化的情况更安全，因为它能确保所有没有默认值的成员都会被值初始化（尽管我们始终应该为成员提供默认值，但这种做法可以防止遗漏默认值的情况）。

> [!Best practice]
> 对于所有类类型，优先使用值初始化，而不是默认初始化。

---
### 隐式默认构造函数 

如果没有用户声明的构造函数，编译器将生成一个公共默认构造函数（以便该类可以进行值初始化或默认初始化）。此构造函数称为隐式默认构造函数。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x{};
    int m_y{};

    // Note: no constructors declared
};

int main()
{
    Foo foo{};

    return 0;
}
```

隐式默认构造函数相当于没有参数、没有成员初始化列表、构造函数主体中也没有语句的构造函数。换句话说，对于上面的 Foo 类，编译器会生成如下代码：

```cpp
public:
    Foo() // implicitly generated default constructor
    {
    }
```

隐式默认构造函数主要用于类没有数据成员的情况。如果类有数据成员，我们可能希望它们能够使用用户提供的值进行初始化，而隐式默认构造函数不足以满足这一需求。

---
### 显式默认构造函数

如果我们想要编写一个与隐式生成的默认构造函数等效的默认构造函数，也就是一个什么参数都没有也什么都不干的摆烂默认构造函数。更好的方法是 **explicitly defaulted default constructor** 显式默认构造函数，可以使用 ` = default`语法生成：

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() = default; // generates an explicitly defaulted default constructor

    Foo(int x, int y)
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo{}; // calls Foo() default constructor

    return 0;
}
```

这和用户自行定义的函数体为空的默认构造函数有一点点区别：

对类进行值初始化时，如果该类具有用户定义的默认构造函数，则该对象将被默认初始化。但是，如果该类具有非用户提供的默认构造函数（即隐式定义或使用 = default 定义的默认构造函数），则该对象将在默认初始化之前进行零初始化。

```cpp
#include <iostream>

class User
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    User() {} // user-defined empty constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Default
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    Default() = default; // explicitly defaulted default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Implicit
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    // implicit default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

int main()
{
    User user{}; // default initialized
    std::cout << user.a() << ' ' << user.b() << '\n';

    Default def{}; // zero initialized, then default initialized
    std::cout << def.a() << ' ' << def.b() << '\n';

    Implicit imp{}; // zero initialized, then default initialized
    std::cout << imp.a() << ' ' << imp.b() << '\n';

    return 0;
}
```

```
782510864 0
0 0
0 0
```

但其实差别不大，因为有成员变量的话一般不用这种默认构造函数。

不过真用的话，从上面也能看出来最佳选择还是 ` = default`。

---
## 带默认参数的构造函数

```cpp
#include <iostream>

class Foo
{
private:
    int m_x { };
    int m_y { };

public:
    Foo(int x=0, int y=0) // has default arguments
        : m_x { x }
        , m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo1{};     // calls Foo(int, int) constructor using default arguments
    Foo foo2{6, 7}; // calls Foo(int, int) constructor

    return 0;
}
```

```
Foo(0, 0) constructed
Foo(6, 7) constructed
```

如果构造函数中的所有参数都有默认参数，则该构造函数为默认构造函数。因为它可以在没有参数的情况下调用。

---
## 重载构造函数

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() // default constructor
    {
        std::cout << "Foo constructed\n";
    }

    Foo(int x, int y) // non-default constructor
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo1{};     // Calls Foo() constructor
    Foo foo2{6, 7}; // Calls Foo(int, int) constructor

    return 0;
}
```

> [!Warning]
> 一个类应该只有一个默认构造函数。如果提供了多个默认构造函数，编译器将无法区分应该使用哪个。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() // default constructor
    {
        std::cout << "Foo constructed\n";
    }

    Foo(int x=1, int y=2) // default constructor
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo{}; // compile error: ambiguous constructor function call

    return 0;
}
```

在上面的例子中，我们实例化 foo 时没有传入任何参数，因此编译器会查找默认构造函数。它会找到两个，并且无法区分应该使用哪个构造函数。这将导致编译错误。

---
## 委托构造函数

重载的构造函数经常会有函数体内容重复的问题：

```cpp
    Employee(std::string_view name, int id) // Employees must have a name and an id
        : m_name{ name }, m_id { id }
    {
        std::cout << "Employee " << m_name << " created\n";
    }

    Employee(std::string_view name, int id, bool isManager) // They can optionally be a manager
        : m_name{ name }, m_id{ id }, m_isManager { isManager }
    {
        std::cout << "Employee " << m_name << " created\n";
    }
```

解决代码重复我们熟呀，封装函数就可以。恰好构造函数可以调用其他函数，包括类的其他成员函数。

但如果调用的是构造函数，则很有可能出错：

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
    std::string m_name { "???" };
    int m_id { 0 };
    bool m_isManager { false };

public:
    Employee(std::string_view name, int id)
        : m_name{ name }, m_id { id } // this constructor initializes name and id
    {
        std::cout << "Employee " << m_name << " created\n"; // our print statement is back here
    }

    Employee(std::string_view name, int id, bool isManager)
        : m_isManager { isManager } // this constructor initializes m_isManager
    {
        // Call Employee(std::string_view, int) to initialize m_name and m_id
        Employee(name, id); // this doesn't work as expected!
    }

    const std::string& getName() const { return m_name; }
};

int main()
{
    Employee e2{ "Dave", 42, true };
    std::cout << "e2 has name: " << e2.getName() << "\n"; // print e2.m_name
}
```

```
Employee Dave created
e2 has name: ???
```

我们原本期望 Employee(name, id) 调用构造函数来继续初始化当前隐式对象 (e2)。但是，类对象的初始化在成员初始化器列表执行完成后就完成了。当我们开始执行构造函数的主体时，再进行其他初始化就太晚了。 

当从函数主体调用构造函数时，看起来像函数调用的构造函数通常会创建并直接初始化一个临时对象（在另一种情况下，你会得到一个编译错误）。在上面的例子中，`Employee(name, id);` 会创建一个临时的（未命名的）Employee 对象。这个临时对象的 `m_name` 设置为 Dave，并且会打印“Employee Dave created”。然后，这个临时对象会被销毁。e2 的 `m_name` 或 `m_id` 永远不会改变默认值。

> [!Warning]
> 构造函数不应该直接从另一个函数的主体中调用。

在 C++ 中，直接调用构造函数（如 `ClassName()`）通常会导致以下两种情况：
- **编译错误**：如果构造函数被标记为 `explicit`（显式构造函数），直接调用会引发错误。
- **创建临时对象**：如果构造函数是隐式的，直接调用会创建一个未命名的临时对象（即 **直接初始化**）。

```cpp
class Point {
public:
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}  // 隐式构造函数
};

void func() {
    // 直接调用构造函数，创建临时对象（未命名）
    Point(10, 20);  // 临时对象，语句结束后销毁
}
```

**推荐使用列表初始化（List-Initialization）创建临时对象**

列表初始化（使用花括号 `{}`）比直接调用构造函数更清晰，因为它明确表达了 “创建一个对象” 的意图：

```cpp
void func() {
    // 使用列表初始化创建临时对象，更清晰
    Point{10, 20};  // 临时对象，等价于 Point(10, 20)
}
```

---
那么，如果我们不能从一个构造函数的主体中调用另一个构造函数，面对构造函数的函数体重复时我们又该怎么做呢？

这时就该委托函数上场了。

构造函数可以将初始化委托（转移责任）给同一类类型的另一个构造函数。这个过程有时称为构造函数链，而这样的构造函数称为委托构造函数。

要让一个构造函数将初始化委托给另一个构造函数，只需调用成员初始化器列表中的构造函数即可：

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
    std::string m_name { "???" };
    int m_id { 0 };

public:
    Employee(std::string_view name)
        : Employee{ name, 0 } // delegate initialization to Employee(std::string_view, int) constructor
    {
    }

    Employee(std::string_view name, int id)
        : m_name{ name }, m_id { id } // actually initializes the members
    {
        std::cout << "Employee " << m_name << " created\n";
    }

};

int main()
{
    Employee e1{ "James" };
    Employee e2{ "Dave", 42 };
}
```

⚠️ 注意，通常情况下，我们让参数较少的构造函数委托给参数较多的构造函数。因为构造函数只能委托或初始化，而不能同时进行。

> [!Warning]
> 构造函数只能委托或初始化，而不能同时进行。

---
## 拷贝构造函数

### 拷贝构造函数 

拷贝构造函数是一种使用现有同类型的对象来初始化对象的构造函数。拷贝构造函数执行后，新创建的对象应该是作为初始化器传入的对象的副本。

```cpp
// Copy constructor
    Fraction(const Fraction& fraction)
        // Initialize our members using the corresponding member of the parameter
        : m_numerator{ fraction.m_numerator }
        , m_denominator{ fraction.m_denominator }
    {
        std::cout << "Copy constructor called\n"; // just to prove it works
    }
```

如果用户没有为类提供拷贝构造函数，C++ 将创建一个公共的隐式拷贝构造函数。

除非有特殊原因需要自行创建拷贝构造函数，否则优先使用 C++ 提供的隐式拷贝构造函数。

> [!Tip]
> 优先使用 C++ 提供的隐式拷贝构造函数。

---
### 拷贝构造函数的调用场景

1. 显式对象初始化（如 `Class obj2(obj1)`）。
2. 函数参数按值传递。
3. 函数返回值按值返回。
4. 容器插入元素。
5. 对象数组初始化。
6. 异常处理。

当类对象通过值传递，且实参形参类型一致时，调用的是拷贝构造函数。

```cpp
void printFraction(Fraction f) // f is pass by value
{
    f.print();
}

int main()
{
    Fraction f{ 5, 3 };
    printFraction(f); // f is copied into the function parameter using copy constructor
    return 0;
}
```

当函数按值返回一个对象时，会通过拷贝构造函数创建返回值的副本：

```cpp
Class createObject() {
    Class obj;
    return obj;  // 返回时复制obj到临时对象
}

Class obj1 = createObject();  // 临时对象被复制到obj1
```

**注意**：现代编译器通常会通过**返回值优化（RVO/NRVO）** 省略复制构造函数的调用。

当对象被插入到容器（如 `std::vector`、`std::list`）时，容器会复制元素：

```cpp
std::vector<Class> vec;
Class obj;
vec.push_back(obj);  // obj被复制到vector内部
```

当使用对象初始化列表时，会调用拷贝构造函数：

```cpp
Class arr[3] = { obj1, obj2, obj3 };  // 每个元素通过复制构造函数初始化
```

当抛出或捕获异常时，可能会复制异常对象：

```cpp
try {
    throw Class();  // 抛出临时对象（可能复制）
} catch (Class e) { // 捕获时复制异常对象到e
    // ...
}
```

---
### 拷贝构造函数的参数必须是左值引用

拷贝构造函数的参数必须是左值引用或 const 左值引用。不然值传递会调用拷贝构造函数，拷贝构造函数再调用值传递，就无限递归起来了。

> [!Warning]
> 拷贝构造函数的参数必须是左值引用或 const 左值引用。
> 由于拷贝构造函数不应修改参数，因此最好使用 const 左值引用。

1. 避免无限递归：值传递会导致递归调用拷贝构造函数。
2. 支持右值绑定：const 左值引用可接收所有类型的对象（左值 / 右值）。
	- 左值引用（`Class&`）：只能绑定到可修改的左值（如变量），但无法绑定到右值（如临时对象）。
	- const 左值引用（`const Class&`）：可以绑定到所有类型的对象（左值、右值、常量），因此更通用。
	- [[6.1 Lvalue references 左值引用#为什么Const左值引用可以绑定到右值？]]
3. 语义正确性：复制操作通常不应修改原对象，使用 const 符合逻辑。
4. 支持移动语义：与移动构造函数（右值引用）共同实现资源的高效转移。

---
>[!Tip]
>三原则是一条众所周知的 C++ 原则，它指出：如果一个类需要用户自定义的拷贝构造函数、析构函数或拷贝赋值运算符，那么它很可能需要同时定义这三个函数。在 C++11 中，这一原则被扩展为 “五法则”，新增了移动构造函数和移动赋值运算符（即需要同时定义这五个函数）。
>
>不遵循三原则/五原则可能会导致代码运行异常。我们将在讨论动态内存分配时重新讨论三原则和五原则。

---
## 转换构造函数

**转换构造函数（Converting Constructor）** 和 **移动构造函数（Move Constructor）** 是两回事噢。

编译器根据需要将一种类型的值隐式转换为另一种类型的值。 这使我们能够执行以下操作：

```cpp
#include <iostream>

void printDouble(double d) // has a double parameter
{
    std::cout << d;
}

int main()
{
    printDouble(5); // we're supplying an int argument

    return 0;
}
```

当类型之一是程序定义的类类型时，C++ 标准没有特定的规则来告诉编译器如何转换。相反，编译器会检查我们是否定义了一些可以用来执行此类转换的函数。这样的函数称为用户定义转换。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x{};
public:
    Foo(int x)
        : m_x{ x }
    {
    }

    int getX() const { return m_x; }
};

void printFoo(Foo f) // has a Foo parameter
{
    std::cout << f.getX();
}

int main()
{
    printFoo(5); // we're supplying an int argument
    // Implicitly convert int value 5 into a Foo
    return 0;
}
```

printFoo 有一个 Foo 参数，但我们传入的是一个 int 类型的实参。由于这些类型不匹配，编译器会找到一个函数，允许它将 int 值 5 转换为 Foo 对象。

该函数就是 Foo(int) 构造函数。

- 在 C++17 之前，调用 printFoo(5) 时，会使用 Foo(int) 构造函数将 5 隐式转换为临时 Foo。然后，该临时 Foo 会被复制构造到参数 f 中。 
- 在 C++17 及更高版本中，复制操作被强制省略。参数 f 会使用值 5 进行复制初始化，无需调用复制构造函数（即使删除了复制构造函数，复制操作仍然有效）。

---
### 只能应用一个用户定义的转换

比如下面这个例子会编译错误。

因为既需要把 C 风格字符串转换为 `std::string_view`（使用 `std::string_view` 转换构造函数），又需要把 `std::string_view` 转换为 Employee 类类型（使用 `Employee(std::string_view)` 转换构造函数）。

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
    std::string m_name{};

public:
    Employee(std::string_view name)
        : m_name{ name }
    {
    }

    const std::string& getName() const { return m_name; }
};

void printEmployee(Employee e) // has an Employee parameter
{
    std::cout << e.getName();
}

int main()
{
    printEmployee("Joe"); // we're supplying an string literal argument

    return 0;
}
```

有两种方法可以使此示例正常工作：

1. 使用 `std::string_view` 类型的字面量：

```cpp
int main()
{
    using namespace std::literals;
    printEmployee( "Joe"sv); // now a std::string_view literal

    return 0;
}
```

这之所以可行，是因为现在只需要一次用户定义的转换（从 `std::string_view` 转换为 `Employee`）。

2. 显式构造 `Employee` 对象，而非隐式创建：

```cpp
int main()
{
    printEmployee(Employee{ "Joe" });

    return 0;
}
```

这同样可行，因为现在只需要一次用户定义的转换（从 C-style string 转换为 `std::string_view`）。将显式构造的 `Employee` 对象传递给函数时，不需要进行第二次转换。

---
### **如何避免隐式转换？**`explicit` 关键字

使用 `explicit` 关键字修饰构造函数，禁止编译器执行隐式转换。

将构造函数声明为 `explicit` 会产生两个重要影响：

1. **禁止拷贝初始化和拷贝列表初始化**
    显式构造函数无法用于拷贝初始化或拷贝列表初始化，必须使用直接初始化或直接列表初始化。因为拷贝初始化需要隐式转换：
    ```cpp
    Class obj = value;        // 拷贝初始化（错误）
    Class obj = {value};      // 拷贝列表初始化（错误）
    
    Class obj(value);         // 直接初始化（正确）
    Class obj{value};         // 直接列表初始化（正确）
    ```
	
	当我们从函数返回一个值时，如果该值与函数的返回类型不匹配，则会发生隐式转换。与值传递一样，此类转换不能使用显式构造函数。
	
	显然禁止了一切拷贝构造场景呢：[[8.2 Constructors 构造函数#拷贝构造函数的调用场景]]

2. **禁止隐式类型转换**  
    显式构造函数无法参与隐式转换，例如：
    ```cpp
    void func(Class obj);     // 接受Class类型的函数
    
    func(value);              // 错误：无法隐式转换
    func(Class(value));       // 正确：显式转换
    ```

**示例说明**

```cpp
class MyClass {
public:
    explicit MyClass(int value)  // 显式构造函数
        : data{value} {}
private:
    int data;
};

int main() {
    // 错误：拷贝初始化需要隐式转换
    MyClass obj1 = 42;          // ❌ 编译错误
    
    // 正确：直接初始化
    MyClass obj2(42);           // ✅
    
    // 正确：直接列表初始化
    MyClass obj3{42};           // ✅
    
    // 错误：隐式转换失败
    void func(MyClass);
    
    func(42);                   // ❌ 编译错误
    
    // 正确：显式转换
    func(MyClass(42));          // ✅
    func(static_cast<MyClass>(42));  // ✅
}
```

  

  

![](data:image/png;base64,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)