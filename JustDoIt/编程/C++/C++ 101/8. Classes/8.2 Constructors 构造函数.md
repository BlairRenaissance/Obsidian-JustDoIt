## 构造函数

一旦我们将任何成员变量设为私有（以隐藏我们的数据），我们的类类型就不再是聚合（因为聚合不能有私有成员）。这意味着我们无法再使用聚合初始化：

```cpp
class Foo // Foo is not an aggregate (has private members)
{
    int m_x {};
    int m_y {};
};

int main()
{
    Foo foo { 6, 7 }; // compile error: can not use aggregate initialization

    return 0;
}
```

这时就需要构造函数： 
- 构造函数的名称必须与类名相同（大小写一致）。对于模板类，此名称不包括模板参数。
- 构造函数没有返回类型（甚至没有 void）。

在前面的章节我们了解到，编译器可能会在函数调用中执行参数的隐式转换。[[3.5 隐式类型转换 Implicit Type Conversion]]

```cpp
void foo(int, int)
{
}

int main()
{
    foo('a', true); // will match foo(int, int)

    return 0;
}
```

构造函数同样会如此：

```cpp
class Foo
{
public:
    Foo(int x, int y)
    {
    }
};

int main()
{
    Foo foo{ 'a', true }; // will match Foo(int, int) constructor

    return 0;
}
```

| 类型     | 特点                                 |
| ------ | ---------------------------------- |
| 默认构造函数 | `ClassName() = default;`           |
| 拷贝构造函数 | `ClassName(const ClassName&);`     |
| 移动构造函数 | `ClassName(ClassName&&);` (C++11+) |
| 转换构造函数 | 单参数非explicit构造函数                   |
| 委托构造函数 | 构造函数可以调用同类其他构造函数 (C++11+)          |
| 继承构造函数 | `using Base::Base;` (C++11+)       |

---
## 构造函数体

构造函数函数体中的语句是在成员初始化列表 [[8.3 Class initialization 初始化]] 执行之后执行的。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x { 0 };
    int m_y { 1 };

public:
    Foo(int x, int y)
    {
        m_x = x; // incorrect: this is an assignment, not an initialization
        m_y = y; // incorrect: this is an assignment, not an initialization
    }
};
```

如果需要初始化成员（例如对于 const 或引用的数据成员），则构造函数体内赋值将不起作用。

一旦成员初始化列表执行完毕，对象即被视为已初始化。一旦函数体执行完毕，对象即被视为已构造。

> [!Best practice] 
> 建议使用成员初始化列表来初始化成员，而不是在构造函数主体中赋值。

对于异常值（比如给除数赋值为0），我们通常不会在成员初始化列表中进行任何验证——我们只会直接使用传入的值来初始化成员，然后在构造函数主体内部使用 `assert` 或 `static_assert` 来检测和处理错误。

---


| 场景      | 推荐方案          | 避免方案         |
| ------- | ------------- | ------------ |
| 简单对象初始化 | 直接构造函数        | 过度设计         |
| 多版本构造函数 | 委托构造函数        | 重复初始化代码      |
| 继承体系扩展  | 继承构造函数        | 手动转发所有基类构造函数 |
| 复杂对象创建  | 工厂模式 + 智能指针   | 直接new操作      |
| 菱形继承    | 虚继承 + 最派生类初始化 | 多层非虚继承       |
| 跨模块对象创建 | 抽象工厂 + DLL接口  | 暴露具体类实现      |



## 默认构造函数
### 默认构造函数

默认构造函数是不接受任何参数的构造函数。

```cpp
#include <iostream>

class Foo
{
public:
    Foo() // default constructor
    {
        std::cout << "Foo default constructed\n";
    }
};

int main()
{
    Foo foo{}; // No initialization values, calls Foo's default constructor

    return 0;
}
```

如果类类型具有默认构造函数，则值初始化和默认初始化都会调用默认构造函数。因此，对于像上面例子中的 Foo 类这样的类，以下内容本质上是等效的：

```cpp
Foo foo{}; // value initialization, calls Foo() default constructor
Foo foo2;  // default initialization, calls Foo() default constructor
```

那么应该选择哪种呢？

根据前文 [[7.3 Struct#初始化]] 我们可知，值初始化的情况更安全，因为它能确保所有没有默认值的成员都会被值初始化（尽管我们始终应该为成员提供默认值，但这种做法可以防止遗漏默认值的情况）。

> [!Best practice]
> 对于所有类类型，优先使用值初始化，而不是默认初始化。

---
### 隐式默认构造函数 

如果没有用户声明的构造函数，编译器将生成一个公共默认构造函数（以便该类可以进行值初始化或默认初始化）。此构造函数称为隐式默认构造函数。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x{};
    int m_y{};

    // Note: no constructors declared
};

int main()
{
    Foo foo{};

    return 0;
}
```

隐式默认构造函数相当于没有参数、没有成员初始化列表、构造函数主体中也没有语句的构造函数。换句话说，对于上面的 Foo 类，编译器会生成如下代码：

```cpp
public:
    Foo() // implicitly generated default constructor
    {
    }
```

隐式默认构造函数主要用于类没有数据成员的情况。如果类有数据成员，我们可能希望它们能够使用用户提供的值进行初始化，而隐式默认构造函数不足以满足这一需求。

---
### 显式默认构造函数

如果我们想要编写一个与隐式生成的默认构造函数等效的默认构造函数，也就是一个什么参数都没有也什么都不干的摆烂默认构造函数。更好的方法是 **explicitly defaulted default constructor** 显式默认构造函数，可以使用 ` = default`语法生成：

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() = default; // generates an explicitly defaulted default constructor

    Foo(int x, int y)
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo{}; // calls Foo() default constructor

    return 0;
}
```

这和用户自行定义的函数体为空的默认构造函数有一点点区别：

对类进行值初始化时，如果该类具有用户定义的默认构造函数，则该对象将被默认初始化。但是，如果该类具有非用户提供的默认构造函数（即隐式定义或使用 = default 定义的默认构造函数），则该对象将在默认初始化之前进行零初始化。

```cpp
#include <iostream>

class User
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    User() {} // user-defined empty constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Default
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    Default() = default; // explicitly defaulted default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Implicit
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    // implicit default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

int main()
{
    User user{}; // default initialized
    std::cout << user.a() << ' ' << user.b() << '\n';

    Default def{}; // zero initialized, then default initialized
    std::cout << def.a() << ' ' << def.b() << '\n';

    Implicit imp{}; // zero initialized, then default initialized
    std::cout << imp.a() << ' ' << imp.b() << '\n';

    return 0;
}
```

```
782510864 0
0 0
0 0
```

但其实差别不大，因为有成员变量的话一般不用这种默认构造函数。

不过真用的话，从上面也能看出来最佳选择还是 ` = default`。

---
## 带默认参数的构造函数

```cpp
#include <iostream>

class Foo
{
private:
    int m_x { };
    int m_y { };

public:
    Foo(int x=0, int y=0) // has default arguments
        : m_x { x }
        , m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo1{};     // calls Foo(int, int) constructor using default arguments
    Foo foo2{6, 7}; // calls Foo(int, int) constructor

    return 0;
}
```

```
Foo(0, 0) constructed
Foo(6, 7) constructed
```

如果构造函数中的所有参数都有默认参数，则该构造函数为默认构造函数。因为它可以在没有参数的情况下调用。

---
## 拷贝构造函数

拷贝构造函数是一种使用现有同类型的对象来初始化对象的构造函数。拷贝构造函数执行后，新创建的对象应该是作为初始化器传入的对象的副本。

```cpp
    Fraction(const Fraction& fraction)
        : m_numerator{ fraction.m_numerator }
        , m_denominator{ fraction.m_denominator }
    {
        std::cout << "Copy constructor called\n";
    }
```

如果用户没有为类提供拷贝构造函数，C++ 将创建一个公共的隐式拷贝构造函数。

除非有特殊原因需要自行创建拷贝构造函数，否则优先使用 C++ 提供的隐式拷贝构造函数。

> [!Tip]
> 优先使用 C++ 提供的隐式拷贝构造函数。

---
### 拷贝构造函数的调用场景

1. 显式对象初始化（如 `Class obj2(obj1)`）。
2. 函数参数按值传递。
3. 函数返回值按值返回。
4. 容器插入元素。
5. 对象数组初始化。
6. 异常处理。

当类对象通过值传递，且实参形参类型一致时，调用的是拷贝构造函数。

```cpp
void printFraction(Fraction f) // f is pass by value
{
    f.print();
}

int main()
{
    Fraction f{ 5, 3 };
    printFraction(f); // f is copied into the function parameter using copy constructor
    return 0;
}
```

当函数按值返回一个对象时，会通过拷贝构造函数创建返回值的副本：

```cpp
Class createObject() {
    Class obj;
    return obj;  // 返回时复制obj到临时对象
}

Class obj1 = createObject();  // 临时对象被复制到obj1
```

**注意**：现代编译器通常会通过**返回值优化（RVO/NRVO）** 省略复制构造函数的调用。

当对象被插入到容器（如 `std::vector`、`std::list`）时，容器会复制元素：

```cpp
std::vector<Class> vec;
Class obj;
vec.push_back(obj);  // obj被复制到vector内部
```

当使用对象初始化列表时，会调用拷贝构造函数：

```cpp
Class arr[3] = { obj1, obj2, obj3 };  // 每个元素通过复制构造函数初始化
```

当抛出或捕获异常时，可能会复制异常对象：

```cpp
try {
    throw Class();  // 抛出临时对象（可能复制）
} catch (Class e) { // 捕获时复制异常对象到e
    // ...
}
```

---
### 拷贝构造函数的参数必须是左值引用

拷贝构造函数的参数必须是左值引用或 const 左值引用。不然值传递会调用拷贝构造函数，拷贝构造函数再调用值传递，就无限递归起来了。

> [!Warning]
> 拷贝构造函数的参数必须是左值引用或 const 左值引用。
> 由于拷贝构造函数不应修改参数，因此最好使用 const 左值引用。

1. 避免无限递归：值传递会导致递归调用拷贝构造函数。
2. 支持右值绑定：const 左值引用可接收所有类型的对象（左值 / 右值）。
	- 左值引用（`Class&`）：只能绑定到可修改的左值（如变量），但无法绑定到右值（如临时对象）。
	- const 左值引用（`const Class&`）：可以绑定到所有类型的对象（左值、右值、常量），因此更通用。
	- [[6.1 Lvalue references 左值引用#为什么Const左值引用可以绑定到右值？]]
3. 语义正确性：复制操作通常不应修改原对象，使用 const 符合逻辑。
4. 支持移动语义：与移动构造函数（右值引用）共同实现资源的高效转移。

---

>[!Tip]
>三原则是一条众所周知的 C++ 原则，它指出：如果一个类需要用户自定义的拷贝构造函数、析构函数或拷贝赋值运算符，那么它很可能需要同时定义这三个函数。在 C++11 中，这一原则被扩展为 “五法则”，新增了移动构造函数和移动赋值运算符（即需要同时定义这五个函数）。
>
>不遵循三原则/五原则可能会导致代码运行异常。我们将在讨论动态内存分配时重新讨论三原则和五原则。

---
## 转换构造函数

**转换构造函数（Converting Constructor）** 和 **移动构造函数（Move Constructor）** 是两回事噢。

编译器根据需要将一种类型的值隐式转换为另一种类型的值。 这使我们能够执行以下操作：

```cpp
#include <iostream>

void printDouble(double d) // has a double parameter
{
    std::cout << d;
}

int main()
{
    printDouble(5); // we're supplying an int argument

    return 0;
}
```

当类型之一是程序定义的类类型时，C++ 标准没有特定的规则来告诉编译器如何转换。相反，编译器会检查我们是否定义了一些可以用来执行此类转换的函数。这样的函数称为用户定义转换。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x{};
public:
    Foo(int x)
        : m_x{ x }
    {
    }

    int getX() const { return m_x; }
};

void printFoo(Foo f) // has a Foo parameter
{
    std::cout << f.getX();
}

int main()
{
    printFoo(5); // we're supplying an int argument
    // Implicitly convert int value 5 into a Foo
    return 0;
}
```

printFoo 有一个 Foo 参数，但我们传入的是一个 int 类型的实参。由于这些类型不匹配，编译器会找到一个函数，允许它将 int 值 5 转换为 Foo 对象。

该函数就是 Foo(int) 构造函数。

- 在 C++17 之前，调用 printFoo(5) 时，会使用 Foo(int) 构造函数将 5 隐式转换为临时 Foo。然后，该临时 Foo 会被复制构造到参数 f 中。 
- 在 C++17 及更高版本中，复制操作被强制省略。参数 f 会使用值 5 进行复制初始化，无需调用复制构造函数（即使删除了复制构造函数，复制操作仍然有效）。

---
### 只能应用一个用户定义的转换

比如下面这个例子会编译错误。

因为既需要把 C 风格字符串转换为 `std::string_view`（使用 `std::string_view` 转换构造函数），又需要把 `std::string_view` 转换为 Employee 类类型（使用 `Employee(std::string_view)` 转换构造函数）。

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
    std::string m_name{};

public:
    Employee(std::string_view name)
        : m_name{ name }
    {
    }

    const std::string& getName() const { return m_name; }
};

void printEmployee(Employee e) // has an Employee parameter
{
    std::cout << e.getName();
}

int main()
{
    printEmployee("Joe"); // we're supplying an string literal argument

    return 0;
}
```

有两种方法可以使此示例正常工作：

1. 使用 `std::string_view` 类型的字面量：

```cpp
int main()
{
    using namespace std::literals;
    printEmployee( "Joe"sv); // now a std::string_view literal

    return 0;
}
```

这之所以可行，是因为现在只需要一次用户定义的转换（从 `std::string_view` 转换为 `Employee`）。

2. 显式构造 `Employee` 对象，而非隐式创建：

```cpp
int main()
{
    printEmployee(Employee{ "Joe" });

    return 0;
}
```

这同样可行，因为现在只需要一次用户定义的转换（从 C-style string 转换为 `std::string_view`）。将显式构造的 `Employee` 对象传递给函数时，不需要进行第二次转换。

---
### 如何避免隐式转换？`explicit` 关键字

使用 `explicit` 关键字修饰构造函数，禁止编译器执行隐式转换。

将构造函数声明为 `explicit` 会产生两个重要影响：

1. **禁止拷贝初始化和拷贝列表初始化**
    显式构造函数无法用于拷贝初始化或拷贝列表初始化，必须使用直接初始化或直接列表初始化。因为拷贝初始化需要隐式转换：
    ```cpp
    Class obj = value;        // 拷贝初始化（错误）
    Class obj = {value};      // 拷贝列表初始化（错误）
    
    Class obj(value);         // 直接初始化（正确）
    Class obj{value};         // 直接列表初始化（正确）
    ```
	
	当我们从函数返回一个值时，如果该值与函数的返回类型不匹配，则会发生隐式转换。与值传递一样，此类转换不能使用显式构造函数。
	
	显然禁止了一切拷贝构造场景呢：[[8.2 Constructors 构造函数#拷贝构造函数的调用场景]]

2. **禁止隐式类型转换**  
    显式构造函数无法参与隐式转换，例如：
    ```cpp
    void func(Class obj);     // 接受Class类型的函数
    
    func(value);              // 错误：无法隐式转换
    func(Class(value));       // 正确：显式转换
    ```

**示例说明**

```cpp
class MyClass {
public:
    explicit MyClass(int value)  // 显式构造函数
        : data{value} {}
private:
    int data;
};

int main() {
    // 错误：拷贝初始化需要隐式转换
    MyClass obj1 = 42;          // ❌ 编译错误
    
    // 正确：直接初始化
    MyClass obj2(42);           // ✅
    
    // 正确：直接列表初始化
    MyClass obj3{42};           // ✅
    
    // 错误：隐式转换失败
    void func(MyClass);
    
    func(42);                   // ❌ 编译错误
    
    // 正确：显式转换
    func(MyClass(42));          // ✅
    func(static_cast<MyClass>(42));  // ✅
}
```
  ---

## 委托构造函数

重载的构造函数经常会有函数体内容重复的问题。解决代码重复我们熟呀，封装函数就可以。恰好构造函数可以调用其他函数，包括类的其他成员函数。

但如果调用的是构造函数，则很有可能出错。

我们期望在构造函数的函数体中调用其它同名重载的构造函数来继续初始化当前隐式对象。但是，类对象的初始化在成员初始化器列表执行完成后就完成了。当我们开始执行构造函数的主体时，再进行其他初始化就太晚了。 

更多时候会看起来像函数调用的构造函数创建并直接初始化了一个临时对象，在另一种情况下，你会得到一个编译错误。

> [!Warning]
> 构造函数不应该直接从另一个函数的主体中调用。

在 C++ 中，直接调用构造函数（如 `ClassName()`）通常会导致以下两种情况：
- **编译错误**：如果构造函数被标记为 `explicit`（显式构造函数），直接调用会引发错误。
- **创建临时对象**：如果构造函数是隐式的，直接调用会创建一个未命名的临时对象（即 **直接初始化**）。

```cpp
class Point {
public:
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}  // 隐式构造函数
};

void func() {
    // 直接调用构造函数，创建临时对象（未命名）
    Point(10, 20);  // 临时对象，语句结束后销毁
}
```

PS. **推荐使用列表初始化（List-Initialization）创建临时对象**

列表初始化（使用花括号 `{}`）比直接调用构造函数更清晰，因为它明确表达了 “创建一个对象” 的意图：

```cpp
void func() {
    // 使用列表初始化创建临时对象，更清晰
    Point{10, 20};  // 临时对象，等价于 Point(10, 20)
}
```

---
那么，如果我们不能从一个构造函数的主体中调用另一个构造函数，面对构造函数的函数体重复时我们又该怎么做呢？

这时就该委托函数上场了。

构造函数可以将初始化委托（转移责任）给同一类类型的另一个构造函数。这个过程有时称为构造函数链，而这样的构造函数称为委托构造函数。

传统方式的问题：

```C++
class Config {
public:
    Config() { 
        init(0, "");  // 重复初始化逻辑
    }
    Config(int v) {
        init(v, "");
    }
    Config(string s) {
        init(0, s);
    }
private:
    void init(int v, string s) { /*...*/ }
};
```

现代解决方案（C++11起）：

```C++
class Config {
public:
    Config() : Config(0, "") {}  // 委托主构造函数
    Config(int v) : Config(v, "") {}
    Config(string s) : Config(0, s) {}

    // 主构造函数
    Config(int v, string s) { 
        /* 统一初始化逻辑 */
    }
};
```

要让一个构造函数将初始化委托给另一个构造函数，只需调用成员初始化器列表中的构造函数即可。

⚠️ 注意，通常情况下，我们让参数较少的构造函数委托给参数较多的构造函数。因为构造函数只能委托或初始化，而不能同时进行。

> [!Warning]
> 构造函数只能委托或初始化，而不能同时进行。

---

## 重载构造函数

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() // default constructor
    {
        std::cout << "Foo constructed\n";
    }

    Foo(int x, int y) // non-default constructor
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo1{};     // Calls Foo() constructor
    Foo foo2{6, 7}; // Calls Foo(int, int) constructor

    return 0;
}
```

> [!Warning]
> 一个类应该只有一个默认构造函数。如果提供了多个默认构造函数，编译器将无法区分应该使用哪个。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo() // default constructor
    {
        std::cout << "Foo constructed\n";
    }

    Foo(int x=1, int y=2) // default constructor
        : m_x { x }, m_y { y }
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
    }
};

int main()
{
    Foo foo{}; // compile error: ambiguous constructor function call

    return 0;
}
```

在上面的例子中，我们实例化 foo 时没有传入任何参数，因此编译器会查找默认构造函数。它会找到两个，并且无法区分应该使用哪个构造函数。这将导致编译错误。

---

# 四、继承体系初始化

## 继承构造函数

```C++
class Base {
public:
    explicit Base(int) {}
    Base(double, const char*) {}
};

class Derived : public Base {
public:
    using Base::Base;  // 继承所有Base构造函数
    
    // 可扩展新构造函数
    Derived(const string& s) : Base(s.size()) {}
};
```
- 继承的构造函数不会初始化派生类新增成员。
- 如果基类构造函数有默认参数，继承时会保留默认参数。

---

## 4.1 派生类构造顺序

1. 虚基类构造（按继承顺序）
2. 直接基类构造（按声明顺序）
3. 成员对象构造（按声明顺序）
4. 派生类构造函数体执行

```C++
class VirtualBase {
public:
    VirtualBase() { std::cout << "VirtualBase\n"; }
};

class Base1 : virtual public VirtualBase {
public:
    Base1() { std::cout << "Base1\n"; }
};

class Base2 : virtual public VirtualBase {
public:
    Base2() { std::cout << "Base2\n"; }
};

class Member {
public:
    Member() { std::cout << "Member\n"; }
};

class Final : public Base1, public Base2 {
    Member m;
public:
    Final() { std::cout << "Final\n"; }
};

/* 构造顺序：
VirtualBase → Base1 → Base2 → Member → Final */
```

## 4.2 虚基类构造

```C++
class Base {
public:
    Base(int) { std::cout << "Base\n"; }
};  

class V1 : virtual public Base {
public:
    V1() : Base(1) { std::cout << "V1\n"; }
};

class V2 : virtual public Base {
public:
    V2() : Base(2) { std::cout << "V2\n"; }
};

class Derived : public V1, public V2 {
public:
    // 必须直接初始化虚基类
    Derived() : Base(0), V1(), V2() { 
        std::cout << "Derived\n"; 
    }
};

/* 输出：
Base(0)  // 虚基类只初始化一次
V1
V2
Derived */
```

**虚基类构造规则**：
- 由最派生类直接初始化。
- 中间类的虚基类初始化会被忽略。
- 初始化顺序按继承图深度优先、从左到右。

---
问：为什么菱形继承必须使用虚继承？
问题场景
```C++
     File
    /   \
Input  Output
    \   /
     IO

// 传统继承导致File重复
class File { /*...*/ };
class Input : public File { /*...*/ };
class Output : public File { /*...*/ };
class IO : public Input, public Output {
    // 包含两个File子对象！
};
```

解决方案
```C++
class File { /*...*/ };
class Input : virtual public File { /*...*/ };  // 虚继承
class Output : virtual public File { /*...*/ }; // 虚继承
class IO : public Input, public Output {
    // 只包含一个File子对象
};
```

---
问：为什么要避免在基类的构造函数中调用虚函数？

当创建一个派生类的对象时，基类的构造函数会先被调用，然后是派生类的构造函数。在基类构造函数执行期间，派生类的部分还没有初始化。这时候如果基类构造函数调用了一个虚函数，根据C++的动态绑定机制，这个调用应该指向基类自己的虚函数实现，而不是派生类的。而如果基类的虚函数是纯虚函数，也就是没有实现的话，这时候调用就会导致未定义行为，通常是程序崩溃。

> 标准规定（ISO C++ §15.7）
> ”当从构造函数或析构函数直接或间接调用虚函数时，被调用的函数是构造函数或析构函数自身类或其基类中定义的版本，而不是派生类中的覆盖版本。“

```C++
class Base {
public:
    Base() {
        // 危险
        virtualMethod(); 
    }
    
    virtual void virtualMethod() = 0;
};
```

解决方案1：两阶段初始化模式

```C++
class SafeBase {
public:
    SafeBase() = default;
    
    template<typename T, typename... Args>
    static std::unique_ptr<T> create(Args&&... args) {
        auto obj = std::make_unique<T>(std::forward<Args>(args)...);
        obj->postInit();  // 对象完全构造后调用
        return obj;
    }

protected:
    virtual void postInit() {}  // 空实现
};

class SafeDerived : public SafeBase {
protected:
    void postInit() override {
        // 安全访问派生类成员
    }
};
```

解决方案2：编译期多态（CRTP模式）

```C++
template<typename Derived>
class CRTPBase {
public:
    CRTPBase() {
        // 编译期绑定，无虚函数开销
        static_cast<Derived*>(this)->safeInit();
    }
};

class CRTPDerived : public CRTPBase<CRTPDerived> {
    friend class CRTPBase<CRTPDerived>;
private:
    void safeInit() { /* 安全初始化 */ }
};
```

## 4.3 直接基类构造

```C++
class Base {
public:
    explicit Base(int) {}
};

class Derived : public Base {
public:
    // 必须显式调用基类构造函数
    Derived() : Base(42) {} 
    
    // 错误：Base没有默认构造函数
    // Derived() {}
};
```
