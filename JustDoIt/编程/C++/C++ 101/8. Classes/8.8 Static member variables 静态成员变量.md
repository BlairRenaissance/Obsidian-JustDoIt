之前讲过 [[4.2 Static]] 关键字。

类的静态成员不关联类对象。使用类名和范围解析运算符 :: 访问静态成员。

```cpp
class Something
{
public:
    static int s_value; // declare s_value as static
};

int Something::s_value{ 1 }; // 定义并将 s_value 初始化为 1
```

---
## 静态成员变量初始化

| 类型                   | 类内初始化 | 类外定义➕初始化                   | 备注                                   |
| -------------------- | ----- | -------------------------- | ------------------------------------ |
| static int           | ×     | √                          | 必须类外定义和初始化                           |
| static const int     | √     | 可选*                        | 类内初始化后，编译期常量场合可省略类外定义，**取地址需类外定义**   |
| static const 非整型     | √     | √                          | 类内初始化后，仍需类外定义（如 static const double） |
| static constexpr int | √     | C++11/14:可选*<br>C++17+:不需要 | C++17+类内初始化即可，取地址也不需要类外定义            |
| static constexpr 非整型 | √     | C++11/14:可选*<br>C++17+:不需要 | C++17+类内初始化即可，取地址也不需要类外定义            |
- 在 C++98/03 时代，`const int` 静态成员变量就已经可以作为编译期常量了（只限于整型）。
- “可选”是指，只作为编译期常量使用的话就无需类外定义，但如果需要取地址就需要类外定义。
- C++17 及以后 **static constexpr 成员** 可以仅类内初始化，哪怕取地址也不需要类外定义（编译器自动生成定义）。

``` cpp
struct S {
    static int a;                    // 只是声明，需要类外定义
    static const int b = 1;          // 可以类内初始化，取地址需类外定义
    static const double c = 3.14;    // c++11之后可以类内初始化，但必须类外定义
    static constexpr int d = 2;      // C++11/14 取地址需类外定义，C++17+不需要
    static constexpr double e = 3.5; // 同上
};

int S::a = 10;
const double S::c = 2.5;
```

**总结口诀**

- **普通 static**：只能类外初始化
- **static const 整型**：类内初始化，编译期常量场合可省略类外定义，取地址需类外定义
- **static const 非整型**：类内初始化后，仍需类外定义
- **static constexpr**：C++17+ 类内初始化即可，C++11/14 取地址需类外定义

---
## 警惕重定义

非模板类：
- 如果类是在头文件（.h）中定义的，静态成员的定义通常放在该类对应的源文件（例如 Something.cpp）中。
- ==不要把静态成员的定义放在头文件中==（就像全局变量一样，如果头文件被多次包含，就会产生多个定义，从而导致链接错误）。

模板类：
- 带模板的静态成员定义通常直接放在头文件中模板类定义的下方（这不会违反 ODR，因为这样的定义会被隐式地视为 inline）。

---
## 静态成员函数

当 static 成员变量是 private 类型时，就需要静态成员函数。

```cpp
class Something
{
private:
    static inline int s_value { 1 };

public:
    static int getValue() { return s_value; } // static member function
};
```

1. 静态成员函数没有 `this` 指针。（这是显然的，因为不操作对象）

2. 静态成员函数可以直接访问其他 static 成员（变量或函数），但不能访问 non-static 成员。

3. 静态成员函数在类声明之外定义。
```cpp
class IDGenerator
{
private:
    static inline int s_nextID { 1 };

public:
     static int getNextID(); // 这是静态函数的声明
};

// 这是类外部静态函数的定义。⚠️注意，这里我们没有使用 static 关键字。
int IDGenerator::getNextID() { return s_nextID++; }
```
⚠️注意：类定义内部定义的成员函数是隐式内联的，但类定义外部定义的成员函数不是隐式内联的。因此，如果头文件中定义的静态成员函数被包含在多个翻译单元中，则应将其设置为内联，以免违反“单一定义规则 (ODR)”。

---
## C++ 不支持 `Static` 构造函数

如果我们的静态变量可以直接初始化，则不需要构造函数：

```cpp
#include <iostream>

struct Chars
{
    char first{};
    char second{};
    char third{};
    char fourth{};
    char fifth{};
};

struct MyClass
{
	static inline Chars s_mychars { 'a', 'e', 'i', 'o', 'u' }; // initialize static variable at point of definition
};

int main()
{
    std::cout << MyClass::s_mychars.third; // print i

    return 0;
}
```

如果初始化静态成员变量需要执行代码，一种适用于所有变量（无论是否为静态变量）的方法是使用函数创建一个对象，向其填充数据，然后将其返回给调用者。返回的值可以复制到正在初始化的对象中：

```cpp
struct Chars
{
    char first{};
    char second{};
    char third{};
    char fourth{};
    char fifth{};
};

class MyClass
{
private:
    static Chars generate()
    {
        Chars c{}; // create an object
        c.first = 'a'; // fill it with values however you like
        c.second = 'e';
        c.third = 'i';
        c.fourth = 'o';
        c.fifth = 'u';

        return c; // return the object
    }

public:
	static inline Chars s_mychars { generate() }; // copy the returned object into s_mychars
};

int main()
{
    std::cout << MyClass::s_mychars.third; // print i

    return 0;
}
```

