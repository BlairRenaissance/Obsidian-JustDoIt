
1. 当我们调用 `simple.setID(2)` 时，编译器实际上会调用 `Simple::setID(&simple, 2)`，此时 `simple` 是以地址的形式传递给函数的。  

2. 该函数有一个隐藏参数，名为 `this`，它接收 `simple` 的地址。  

3. 在 `setID()` 函数内部，成员变量前面会加上 `this->` 前缀，这里的 `this` 指向 `simple`。所以当编译器计算 `this->m_id` 时，实际上就是在访问 `simple.m_id`。

---
## 返回 `*this` 指针

让成员函数返回 this 有时很有用。这样做的主要原因是支持“链式调用”。

无法链式调用：
``` cpp
class Calc
{
private:
    int m_value{};

public:

    void add(int value) { m_value += value; }
    void sub(int value) { m_value -= value; }
    void mult(int value) { m_value *= value; }

    int getValue() const { return m_value; }
};

int main()
{
    Calc calc{};
    calc.add(5); // returns void
    calc.sub(3); // returns void
    calc.mult(4); // returns void

    std::cout << calc.getValue() << '\n';

    return 0;
}
```

实现链式调用：
``` cpp
class Calc
{
private:
    int m_value{};

public:
    Calc& add(int value) { m_value += value; return *this; }
    Calc& sub(int value) { m_value -= value; return *this; }
    Calc& mult(int value) { m_value *= value; return *this; }

    int getValue() const { return m_value; }
};

int main()
{
    Calc calc{};
    calc.add(5).sub(3).mult(4); // method chaining

    std::cout << calc.getValue() << '\n';

    return 0;
}
```

---
## 将类重置回默认状态

``` cpp
#include <iostream>

class Calc
{
private:
    int m_value{};

public:
    Calc& add(int value) { m_value += value; return *this; }
    Calc& sub(int value) { m_value -= value; return *this; }
    Calc& mult(int value) { m_value *= value; return *this; }

    int getValue() const { return m_value; }

	void reset()
	{
	    *this = {}; // value initialize a new object and overwrite the implicit object
	}
};


int main()
{
    Calc calc{};
    calc.add(5).sub(3).mult(4);

    std::cout << calc.getValue() << '\n'; // prints 8

    calc.reset();

    std::cout << calc.getValue() << '\n'; // prints 0

    return 0;
}
```

---
## `this` and `const` 

- For non-const member functions, `this` is a const pointer to a non-const value. **非 const 成员函数**里，`this` 是“指向可修改对象的常量指针”。
- For const member functions, `this` is a const pointer to a const value. **const 成员函数**里，`this` 是“指向不可修改对象的常量指针”。
- 如果用 const 对象调用非 const 成员函数，会报错，原因是类型不匹配，编译器不能自动去掉 const 限定。

**详细解释**

1. **const 对象和 const 成员函数**
	- 如果你写 `const Something a;`，这个对象不能被修改。
	- 如果你写 `int getValue() const;`，这个成员函数承诺不会修改对象内容。
	
2. **`this` 的类型**
	- 在**普通成员函数**里，`this` 的类型是 `Something* const`，意思是“常量指针，指向可修改的 Something 对象”。
	- 在**const 成员函数**里，`this` 的类型是 `const Something* const`，意思是“常量指针，指向不可修改的 Something 对象”。
	
3. **为什么 const 对象不能调用非 const 成员函数？**
	- 如果你有 `const Something a;`，然后写 `a.getValue();`，而 `getValue()` 不是 const 成员函数，编译器会报错。
	- 因为此时 `this` 的类型是 `const Something* const`，但非 const 成员函数需要 `Something* const`。
	- 这就像你有一个“只读”指针，却要传给一个“可写”指针，编译器不允许这样做，因为这会破坏 const 的承诺。

---
## 为什么 `this` 是指针而不是引用

由于 `this` 指针总是指向隐式对象（除非我们做了导致未定义行为的事情，否则它永远不会是空指针），你可能会好奇为什么 `this` 是指针而不是引用。答案很简单：当 `this` 被加入到 C++ 时，引用这种语法还不存在。

如果 `this` 是在今天被加入到 C++ 语言中的，它一定会被设计为引用而不是指针。在其他一些更现代的类 C++ 语言（比如 Java 和 C#）中，`this` 就是作为引用实现的。

---
## 嵌套类与对外部类成员的访问

类中嵌套另一个类的情况相对少见，但在 C++ 中是允许的。

在 C++ 中，嵌套类**无法访问**外部类的 `this` 指针，因此嵌套类**不能直接访问**外部类的成员。这是因为嵌套类可以独立于外部类被实例化（在这种情况下，根本就没有外部类成员可供访问！）。

然而，由于嵌套类是外部类的成员，它们**可以访问**外部类作用域内的任何私有成员。

``` cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
public:
    using IDType = int;

    class Printer
    {
    public:
        void print(const Employee& e) const
        {
            // Printer can't access Employee's `this` pointer
            // so we can't print m_name and m_id directly
            // Instead, we have to pass in an Employee object to use
            // Because Printer is a member of Employee,
            // we can access private members e.m_name and e.m_id directly
            std::cout << e.m_name << " has id: " << e.m_id << '\n';
        }
    };

private:
    std::string m_name{};
    IDType m_id{};
    double m_wage{};

public:
    Employee(std::string_view name, IDType id, double wage)
        : m_name{ name }
        , m_id{ id }
        , m_wage{ wage }
    {
    }

    // removed the access functions in this example (since they aren't used)
};

int main()
{
    const Employee john{ "John", 1, 45000 };
    const Employee::Printer p{}; // instantiate an object of the inner class
    p.print(john);

    return 0;
}
```

---
**Q：为什么嵌套类型（nested type）不能在外部类定义之前进行前向声明？**

A：因为嵌套类型的作用域属于外部类A的作用域。在外部类A定义之前，**A的作用域还不存在**，因此无法在A的作用域下声明B。

``` cpp
#include <iostream>

class outer;         // okay: can forward declare non-nested type
class outer::inner1; // ❌ 不可以 error: can't forward declare nested type prior to outer class definition

class outer
{
public:
    class inner1{}; // note: nested type declared here
};

class outer::inner1; // Emmm可以但没必要 okay (but redundant) since nested type has already been declared as part of outer class definition

int main()
{
    return 0;
}
```