## 模板类

前面我们有了解 [[5.4 Function templates 函数模板]] 和 [[7.4 Struct templates 结构体模板]]。

那么类模板有什么特别之处呢：

1. **私有成员和聚合初始化**
	- C++的聚合类型（aggregate，如struct）要求所有成员都是public，没有用户自定义的构造函数等。
	- 只要有private成员，就不是聚合类型，不能用`Pair<int> p{1, 2};`这种方式初始化，只能用构造函数。
	
2. **构造函数参数类型选择** 
	- 由于类的数据成员类型是T，我们将构造函数的参数类型设为==`const T&`==。
	- 因为T的拷贝可能开销较大，所以用const引用传递比传值更安全。
	
3. **类内成员函数定义不需要再写模板参数声明**
	- 当我们在类模板定义内部定义成员函数时，不需要为成员函数单独提供模板参数声明（`template <typename T>`）。
	- 类模板的参数声明适用于成员函数。
	
4. **非聚合类不需要deduction guide**
	- 对于非聚合类（有构造函数的类），CTAD（类模板实参推导）不需要deduction guide。  编译器会根据构造函数参数类型自动推导模板参数。
	
 5. **类外定义成员函数时要注意两点！！**
	 - 需要重新写`template <typename T>` 告诉编译器T是什么。  
	 - 成员函数名要用全名 `Pair<T>::isEqual`，不能只写 `Pair::isEqual`。

---

```cpp
#include <ios>       // for std::boolalpha
#include <iostream>

template <typename T>
class Pair
{
private:
    T m_first{};
    T m_second{};

public:
    // 当我们在类定义内部定义成员函数时，
    // 类模板的参数声明同样适用于该成员函数。
    Pair(const T& first, const T& second)
        : m_first{ first }
        , m_second{ second }
    {
    }

    bool isEqual(const Pair<T>& pair); // 不需要再写template <typename T>
};

// 当我们在类定义外部定义成员函数时，需要重新提供模板参数声明
template <typename T>
bool Pair<T>::isEqual(const Pair<T>& pair) // ⚠️ 注意这里的类型是 Pair<T>
{
    return m_first == pair.m_first && m_second == pair.m_second;
}

int main()
{
    Pair p1{ 5, 6 }; // uses CTAD to infer type Pair<int>
    std::cout << std::boolalpha << "isEqual(5, 6): " << p1.isEqual( Pair{5, 6} ) << '\n';
    std::cout << std::boolalpha << "isEqual(5, 7): " << p1.isEqual( Pair{5, 7} ) << '\n';

    return 0;
}
```

---
## Injected class names 注入类名

在之前的文章中，我们提到构造函数的名字必须与类名相同。但在上面 `Pair<T>` 的类模板中，我们的构造函数名是 `Pair`，而不是 `Pair<T>`。尽管名字看起来不匹配，这样写依然可以工作。

在类的作用域内，类的未限定名被称为**注入类名**。在类模板中，注入类名可以作为完整模板名的简写。

因为 `Pair` 是 `Pair<T>` 的注入类名，所以在 `Pair<T>` 类模板的作用域内，任何对 `Pair` 的使用都会被当作 `Pair<T>`。因此，虽然我们把构造函数命名为 `Pair`，编译器会把它当作 `Pair<T>`，名字就匹配了！

这意味着我们也可以像下面这样定义成员函数 `isEqual()`：
``` cpp
template <typename T>
bool Pair<T>::isEqual(const Pair& pair) // ⚠️ 注意这里的类型是 Pair, 而不是Pair<T>
{
    return m_first == pair.m_first && m_second == pair.m_second;
}
```

因为这是 `Pair<T>` 的成员函数定义，所以我们处于 `Pair<T>` 类模板的作用域内。此时，任何对 `Pair` 的使用都等价于 `Pair<T>`！

---

> [!Tip]
> 任何在类定义外部定义的成员函数模板，都应该在类定义的下方（同一个文件中）进行定义。

`Pair.h`：
``` cpp
template <typename T>
class Pair {
public:
    Pair(T first, T second);
    bool isEqual(const Pair& other);
};

template <typename T>
Pair<T>::Pair(T first, T second) : m_first(first), m_second(second) {}
  
template <typename T>
bool Pair<T>::isEqual(const Pair& other) {
    return m_first == other.m_first && m_second == other.m_second;
}
```

Q：为什么不分别写在 .h 和 .cpp 中？

A：
- 如果把模板的声明放在 .h 文件，把实现放在 .cpp 文件，其他文件包含 .h 时，编译器只看到声明，看不到实现，**无法实例化模板**，就会报链接错误（undefined reference）。
- 只有把实现也放在 .h 文件里，编译器在实例化模板时才能看到完整代码，生成对应类型的代码。

> [!Warning]
> 把模板类/函数的声明和实现都写在同一个头文件里。