## Member Function

对于非成员函数，我们必须显式地将一个对象传递给函数使用，并且成员可以通过该对象显式访问。 

对于成员函数，我们隐式地将一个对象传递给函数使用，并且成员可以通过该对象隐式访问。

---
## Const class objects

Modifying the data members of const objects is disallowed.
Const objects may not call non-const member functions.（Const 对象不能调用非 const 成员函数）

---
## Const member functions

 A **const member function** is a member function that guarantees it will not modify the object or call any non-const member functions (as they may modify the object).

Making `print()` a const member function is easy -- we simply append the `const` keyword to the function prototype, after the parameter list, but before the function body:

```cpp
#include <iostream>

struct Date
{
    int year {};
    int month {};
    int day {};

    void print() const // now a const member function
    {
        std::cout << year << '/' << month << '/' << day;
    }
};

int main()
{
    const Date today { 2020, 10, 14 }; // const

    today.print();  // ok: const object can call const member function

    return 0;
}
```

> [!Tip]
> A const member function may not: 
> modify the implicit object, call non-const member functions.  
> 
> A const member function may: 
> modify objects that aren’t the implicit object, call const member functions, call non-member functions.

1. const 成员函数不允许修改当前类实例（即隐式对象）：
	  ==`当前类对象会作为const成员函数的隐式参数，显然const函数不会修改函数参数`==
	- 不能修改非 const 的普通成员变量（除非变量被声明为 mutable）
	  ==`const成员函数只能保证不修改自己类的成员`==
	- 不能调用本类的非 const 成员函数
	  ==`const成员函数内的this指针是const类型的，所以不能通过它调用本类的非const成员函数。`==
	
2. 但是可以对别的类为所欲为
	- 可修改全局变量
	- 可修改静态变量
	- 可通过指针/引用修改其他对象
	- 可调用任何可能改变外部状态的函数
	`虽然语法允许，但这种行为会破坏 const 成员函数的「不修改状态」的语义暗示，最好还是避免。`

> [!Warning]
> const 成员函数不能返回数据成员的非 const 引用。

const 成员函数不允许返回成员的非 const 引用，这是有道理的 —— const 成员函数不允许修改对象的状态，也不允许调用会修改对象状态的函数。它不应该执行任何可能导致对象被修改的操作。 如果允许 const 成员函数返回成员的非 const 引用，那么它就等于为调用者提供了一种直接修改该成员的方法。这违反了 const 成员函数的初衷。

const 和非 const 重载：虽然这种情况并不常见，但可以重载一个成员函数，使其拥有同一函数的 const 和非 const 版本。这是因为 const 限定符被视为函数签名的一部分，因此两个仅在 const 性上不同的函数被视为不同的函数。

---

## 返回左值引用

返回引用的成员函数，应该保证返回的类型与规定的引用类型相同，以避免不必要的转换。因此，使用 auto 是更好的选择。
从：
```cpp
const std::string& getName() const { return m_name; }
```
改为：
```cpp
const auto& getName() const { return m_name; }
```

---

> [!Warning]
> 如果对**临时对象**（rvalue）调用getter，临时变量销毁后返回的引用会悬垂，导致未定义行为。

三种安全的方式：

1. **立即使用返回值**（推荐）

直接用getter的返回值做表达式的一部分，不保存引用。
`std::cout << createEmployee("Alice").getName() << std::endl;`
这里`getName()`返回的引用只在这一行用，临时对象还没销毁，安全。

2. **不要保存引用，除非确定对象是lvalue**

不要把getter返回的引用保存下来，除非你确定对象的生命周期比引用长。
**危险例子：**
```CPP
const std::string& name = createEmployee("Bob").getName(); // 错误！悬垂引用
```
`createEmployee("Bob")`是临时对象，用完就销毁，`name`变成悬垂引用。
**安全例子：**
```CPP
Employee e("Bob"); 
const std::string& name = e.getName(); // 安全，e是lvalue
```
这里`e`的生命周期比`name`长，安全。

3. **如果不确定对象类型，拷贝一份**

如果不确定getter是对lvalue还是rvalue调用，**用非引用变量接收**，这样会拷贝一份，安全。
`std::string name = createEmployee("Carol").getName(); // 安全，拷贝了一份`
即使`createEmployee("Carol")`返回的是临时对象，`name`也有自己的副本。

---

## Initialization

Data members are initialized in order of declaration. If the initialization of a data member accesses another data member that isn’t declared until later (and thus hasn’t been initialized yet), the initialization will result in undefined behavior.

```cpp
struct Bad
{
    int m_bad1 { m_data }; // undefined behavior: m_bad1 initialized before m_data
    int m_bad2 { fcn() };  // undefined behavior: m_bad2 initialized before m_data (accessed through fcn())

    int m_data { 5 };
    int fcn() { return m_data; }
};
```

For this reason, it’s generally a good idea to avoid using other members inside default member initializers.