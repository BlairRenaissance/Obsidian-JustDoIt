## 初始化方式

前面的章节中我们列举过6种数据初始化方式：[[3.0 数据初始化 Initialization]]

对于类对象均有效：

```cpp
#include <iostream>

class Foo
{
public:

    // Default constructor
    Foo()
    {
        std::cout << "Foo()\n";
    }

    // Normal constructor
    Foo(int x)
    {
        std::cout << "Foo(int) " << x << '\n';
    }

    // Copy constructor
    Foo(const Foo&)
    {
        std::cout << "Foo(const Foo&)\n";
    }
};

int main()
{
    // Calls Foo() default constructor
    Foo f1;           // default initialization
    Foo f2{};         // value initialization (preferred)

    // Calls foo(int) normal constructor
    Foo f3 = 3;       // copy initialization (non-explicit constructors only)
    Foo f4(4);        // direct initialization
    Foo f5{ 5 };      // direct list initialization (preferred)
    Foo f6 = { 6 };   // copy list initialization (non-explicit constructors only)

    // Calls foo(const Foo&) copy constructor
    Foo f7 = f3;      // copy initialization
    Foo f8(f3);       // direct initialization
    Foo f9{ f3 };     // direct list initialization (preferred)
    Foo f10 = { f3 }; // copy list initialization

    return 0;
}
```

---
### 初始化列表

Member initialization list.

短的时候推荐这种写法：
```cpp
Foo(int x, int y)
    : m_x { x }, m_y { y }
{
}
```

长的时候推荐这种写法：
```cpp
Foo(int x, int y)
    : m_x { x }
    , m_y { y }
{
}
```

据 C++ 标准，成员初始化列表中的成员始终按照它们在类内部的**定义顺序**进行初始化的，而不是按照它们在成员初始化列表中的定义顺序。

> [!Best Practice] 
> 成员初始化列表中的成员变量应按照它们在类中定义的顺序列出。

---
### 默认初始化

成员可以通过几种不同的方式初始化：
- 如果成员在成员初始化列表中，则使用该初始化值。 
- 否则，如果成员具有初始化值，则使用该初始化值。 
- 否则，该成员将被默认初始化。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};    // default member initializer (will be ignored)
    int m_y { 2 }; // default member initializer (will be used)
    int m_z;      // no initializer

public:
    Foo(int x)
        : m_x { x } // member initializer list
    {
        std::cout << "Foo constructed\n";
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ", " << m_z << ")\n";
    }
};

int main()
{
    Foo foo { 6 };
    foo.print();

    return 0;
}
```

以上会打印结果：
```
Foo constructed
Foo(6, 2, -858993460)
```

---
### 构造函数体

如果需要初始化成员（例如对于 const 或引用的数据成员），则构造函数体内赋值将不起作用。[[8.2 Constructors 构造函数#Constructor function bodies]]

一旦成员初始化列表执行完毕，对象即被视为已初始化。一旦函数体执行完毕，对象即被视为已构造。

> [!Best practice] 
> 建议使用成员初始化列表来初始化成员，而不是在构造函数主体中赋值。

---

## 非静态成员初始化

(1) 类内初始化（C++11+）

```C++
class Widget {  
	int value = 42; // 合法（C++11起）  
	std::string name{"default"};  
};
```

(2) 构造函数初始化列表（推荐方式）

```C++
class Example {  
public:  
    Example(int x, double y) : m_x(x), m_y(y) {}  
private:  
    int m_x;  
    double m_y;
};
```

(3) 构造函数体内赋值（不推荐）

```C++
class BadPractice {
public:
    BadPractice(int x) {
        m_x = x;  // 先默认构造，再赋值
    }

private:
    int m_x;
};
```

---
## 特殊成员初始化

``` C++
// 必须使用初始化列表的情况
class MustUseInitList {
    const int const_member;  // const成员
    std::vector<int>& vec_ref; // 引用成员
    NoDefaultCtorClass obj; // 无默认构造的类
    
public:
    MustUseInitList(int c, std::vector<int>& v, NoDefaultCtorClass o) 
        : const_member(c), vec_ref(v), obj(o) {} // ✅ 必须用初始化列表
};
```

| 成员类型       | 初始化要求                         |
| ---------- | ----------------------------- |
| `const` 成员 | 必须通过初始化列表初始化                  |
| 引用成员       | 必须通过初始化列表初始化                  |
| 无默认构造的类    | 必须通过初始化列表初始化                  |
| 类类型成员      | 推荐使用初始化列表直接构造                 |
| 数组成员       | C++11起支持直接初始化（C风格数组需构造时逐个初始化） |
| 位域         | 必须通过初始化列表初始化                  |
* ==C++标准规定，所有成员变量必须在构造函数体执行前完成初始化。==
* ==初始化列表在构造函数体执行之前被处理。==
* 引用成员必须通过初始化列表进行初始化。
	* 引用必须在其创建时被绑定到一个有效的对象，并且在其生命周期内不能被重新绑定。
	* C++语言规范要求引用在声明时必须被初始化。这是为了确保引用在任何时候都指向一个有效的对象或变量。编译器会强制执行这一规则，以防止引用未初始化或指向无效对象。
- 当类成员没有默认构造函数时，如果不在初始化列表中显式初始化，编译器会尝试调用不存在的默认构造函数，导致编译错误。
* 类内初始化（C++11起）不适用于引用成员，因为引用的初始化需要在构造函数中进行。

```C++
class SpecialMembers {
public:
    SpecialMembers(int cv, int& ref, unsigned value) 
        : constValue(cv), refValue(ref), 
          arr{1,2,3}, bitfield(value) {}

private:
    const int constValue;
    int& refValue;
    int arr[3];
    unsigned bitfield : 4;
};
```

> [!Warning]
> 如果成员变量没有默认构造函数，必须通过初始化列表来提供必要的参数进行初始化。

当编译器生成构造函数代码时，它会按照以下步骤进行：
1. 调用基类构造函数（如果有）。
2. 调用成员变量的构造函数。
3. 执行构造函数体。

如果成员变量没有默认构造函数，编译器在步骤2中无法完成成员变量的初始化，从而导致编译错误。使用初始化列表可以在步骤2中提供必要的参数，确保成员变量被正确初始化。

```C++
class Database {
public:
    Database(int port) { /*...*/ }
};

class Service {
    Database db;
public:
    // 必须通过初始化列表构造
    Service() : db(3306) {} 

    // 错误：Database没有默认构造函数
    // Service() { db = Database(3306); } 
};
```

---
## 静态成员初始化

### 静态常量成员

```C++
class Constants {
public:
    static const int MAX_SIZE = 100;        // 类内声明
    static constexpr double PI = 3.14159;   // C++11起
    static const double staticConstDouble;  // 非整型常量静态成员，不能在类内初始化

};
// 类外定义（当需要取地址时）
const int Constants::MAX_SIZE;
constexpr double Constants::PI;
// 在类外定义非整型常量静态成员 
const double Example::staticConstDouble = 3.14;
```

问：什么时候能类内定义，什么时候必须类外定义？
- 想要能够类内定义，需要编译器可以在编译时确定这些值。
1. **类内初始化**：
	- **C++11之前**：在C++11之前，类内只能为静态整型常量提供初始值。这是因为编译器可以在编译时确定这些值，不需要在类外定义。
	- **C++11及之后**：C++11引入了`constexpr`关键字，并允许类内初始化更广泛的常量类型，包括非整型常量。这意味着你可以在类内为`constexpr`静态成员提供初始值，而不需要在类外定义。
2. **`const`和`constexpr`的区别**：
	- **`const`**：`const`关键字用于声明一个变量为常量，表示其值在初始化后不能被修改。`const`变量的值可以在运行时确定。
	- **`constexpr`**：`constexpr`关键字用于声明一个变量或函数可以在编译时求值。`constexpr`变量的值必须在编译时确定，因此它比`const`更严格。

问：“当需要取地址时”指的是什么？
1. **编译时常量优化**：
    - 对于`static const`和`static constexpr`成员，编译器通常会在编译时直接将它们的值内联到使用它们的地方。这意味着在大多数情况下，这些常量不需要实际的存储空间。
2. **取地址的需求**：
    - 当你需要获取一个静态常量成员的地址时，编译器不能再简单地内联其值，因为地址需要指向一个实际的内存位置。
    - 例如，如果你尝试获取`Constants::MAX_SIZE`的地址（`&Constants::MAX_SIZE`），编译器需要为`MAX_SIZE`分配存储空间，以便返回一个有效的地址。
3. **类外定义的必要性**：
    - **编译时优化**：静态常量通常在编译时内联，不需要存储空间。
	- **取地址需求**：当需要获取常量的地址时，必须在类外定义以分配存储空间。
	- **类外定义**：提供一个空定义即可满足取地址的需求。

---
### 静态非常量成员

```C++
class Counter {
public:
    static int count;  // 类内声明
};
// 类外定义（必须）
int Counter::count = 0;


// C++17起可用inline
class ModernCounter {
public:
    inline static int count = 0;  // 无需类外定义
};
```

问：为什么静态非常量成员必须类外定义？
1. **静态成员的特性**：
	- **类级别的成员**：静态成员变量属于类本身，而不是类的某个具体对象。它们在内存中只存在一份，无论创建多少个类的实例，静态成员变量都共享同一份数据。
	- **存储分配**：静态成员变量需要在类外定义，以便为其分配存储空间。类内的声明只是告诉编译器这个成员的存在，但不分配存储空间。
2. **链接要求**：
	- **链接器的需求**：在C++中，静态成员变量的定义需要在类外提供，以便链接器能够找到并分配存储空间。类内的声明只是一个声明，而不是定义。
	- **全局可见性**：在类外定义静态成员变量可以确保它在整个程序中是可见的，并且可以被正确地链接。

---
## 初始化错误处理

对于异常值（比如给除数赋值为0），我们通常不会在成员初始化列表中进行任何验证——我们只会直接使用传入的值来初始化成员，然后在构造函数主体内部使用 `assert` 或 `static_assert` 来检测和处理错误。

那么如果是在 Release 状态下，又如何知道是否构造成功了呢？

之前的章节中我们提出了 4 种处理此类错误的策略：
- 在函数内解决错误。 
- 将错误返回给调用者处理。 
- 暂停程序。 
- 抛出异常。

大多数情况下，我们没有足够的信息来在构造函数中彻底解决此类问题。因此，修复此类问题通常不是一个可行的选择。

对于非成员函数和非特殊成员函数，我们可以将错误传回给调用者处理。但是构造函数没有返回值，所以我们没有好的办法来做到这一点。

在一些情况下，我们可以添加一个 `isValid()` 成员函数，返回当前对象是否处于有效状态。但如果访问语义无效的对象，很可能会导致 bug。所以，虽然这总比没有强，但并非最佳选择。

在某些类型的程序中，我们可以暂停整个程序，让用户输入正确的信息后重新运行程序……但大多数情况下，这是不可接受的。所以可能不会。
  
那么就只剩下抛出异常了。异常会完全中止构造过程，这意味着用户永远无法访问语义无效的对象。所以在大多数情况下，抛出异常是最佳选择。

> [!Important]
> 当构造函数失败（并且无法恢复）时，抛出异常通常是最好的做法。

We discuss this further in lessons [27.5 -- Exceptions, classes, and inheritance](https://www.learncpp.com/cpp-tutorial/exceptions-classes-and-inheritance/) and [27.7 -- Function try blocks](https://www.learncpp.com/cpp-tutorial/function-try-blocks/).
