## 成员初始化列表

Member initialization list.

短的时候推荐这种写法：
```cpp
Foo(int x, int y)
    : m_x { x }, m_y { y }
{
}
```

长的时候推荐这种写法：
```cpp
Foo(int x, int y)
    : m_x { x }
    , m_y { y }
{
}
```

据 C++ 标准，成员初始化列表中的成员始终按照它们在类内部的**定义顺序**进行初始化的，而不是按照它们在成员初始化列表中的定义顺序。

> [!Best Practice] 
> 成员初始化列表中的成员变量应按照它们在类中定义的顺序列出。

---
## 初始化方式

前面的章节中我们列举过6种数据初始化方式：[[3.0 数据初始化 Initialization]]

所有这些初始化方式对于类类型的对象均有效：

```cpp
#include <iostream>

class Foo
{
public:

    // Default constructor
    Foo()
    {
        std::cout << "Foo()\n";
    }

    // Normal constructor
    Foo(int x)
    {
        std::cout << "Foo(int) " << x << '\n';
    }

    // Copy constructor
    Foo(const Foo&)
    {
        std::cout << "Foo(const Foo&)\n";
    }
};

int main()
{
    // Calls Foo() default constructor
    Foo f1;           // default initialization
    Foo f2{};         // value initialization (preferred)

    // Calls foo(int) normal constructor
    Foo f3 = 3;       // copy initialization (non-explicit constructors only)
    Foo f4(4);        // direct initialization
    Foo f5{ 5 };      // direct list initialization (preferred)
    Foo f6 = { 6 };   // copy list initialization (non-explicit constructors only)

    // Calls foo(const Foo&) copy constructor
    Foo f7 = f3;      // copy initialization
    Foo f8(f3);       // direct initialization
    Foo f9{ f3 };     // direct list initialization (preferred)
    Foo f10 = { f3 }; // copy list initialization

    return 0;
}
```

---
## 初始化方式对比

### VS 默认成员初始化

成员可以通过几种不同的方式初始化：
- 如果成员在成员初始化列表中，则使用该初始化值。 
- 否则，如果成员具有初始化值，则使用该初始化值。 
- 否则，该成员将被默认初始化。

```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};    // default member initializer (will be ignored)
    int m_y { 2 }; // default member initializer (will be used)
    int m_z;      // no initializer

public:
    Foo(int x)
        : m_x { x } // member initializer list
    {
        std::cout << "Foo constructed\n";
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ", " << m_z << ")\n";
    }
};

int main()
{
    Foo foo { 6 };
    foo.print();

    return 0;
}
```

以上会打印结果：
```
Foo constructed
Foo(6, 2, -858993460)
```

---
### VS 构造函数体

如果需要初始化成员（例如对于 const 或引用的数据成员），则构造函数体内赋值将不起作用。[[8.2 Constructors 构造函数#Constructor function bodies]]

一旦成员初始化列表执行完毕，对象即被视为已初始化。一旦函数体执行完毕，对象即被视为已构造。

> [!Best practice] 
> 建议使用成员初始化列表来初始化成员，而不是在构造函数主体中赋值。

---
## 初始化错误处理

对于异常值（比如给除数赋值为0），我们通常不会在成员初始化列表中进行任何验证——我们只会直接使用传入的值来初始化成员，然后在构造函数主体内部使用 `assert` 或 `static_assert` 来检测和处理错误。

那么如果是在 Release 状态下，又如何知道是否构造成功了呢？

之前的章节中我们提出了 4 种处理此类错误的策略：
- 在函数内解决错误。 
- 将错误返回给调用者处理。 
- 暂停程序。 
- 抛出异常。

大多数情况下，我们没有足够的信息来在构造函数中彻底解决此类问题。因此，修复此类问题通常不是一个可行的选择。

对于非成员函数和非特殊成员函数，我们可以将错误传回给调用者处理。但是构造函数没有返回值，所以我们没有好的办法来做到这一点。

在一些情况下，我们可以添加一个 `isValid()` 成员函数，返回当前对象是否处于有效状态。但如果访问语义无效的对象，很可能会导致 bug。所以，虽然这总比没有强，但并非最佳选择。

在某些类型的程序中，我们可以暂停整个程序，让用户输入正确的信息后重新运行程序……但大多数情况下，这是不可接受的。所以可能不会。
  
那么就只剩下抛出异常了。异常会完全中止构造过程，这意味着用户永远无法访问语义无效的对象。所以在大多数情况下，抛出异常是最佳选择。

> [!Important]
> 当构造函数失败（并且无法恢复）时，抛出异常通常是最好的做法。

We discuss this further in lessons [27.5 -- Exceptions, classes, and inheritance](https://www.learncpp.com/cpp-tutorial/exceptions-classes-and-inheritance/) and [27.7 -- Function try blocks](https://www.learncpp.com/cpp-tutorial/function-try-blocks/).

---
