
C++ æ”¯æŒä¸¤ç§ç±»å‹çš„æšä¸¾ï¼šæ— ä½œç”¨åŸŸæšä¸¾ å’Œ æœ‰ä½œç”¨åŸŸæšä¸¾ï¼ˆ[[7.2 Scoped enum (enum class)]]ï¼‰ã€‚

Unscoped enumerations are defined via theÂ ==`enum`==Â keyword.

## Avoiding enumerator naming collisions

```cpp
enum Color
{
    red,
    green,
    blue, // blue is put into the global namespace
};

enum Feeling
{
    happy,
    tired,
    blue, // error: naming collision with the above blue
};

int main()
{
    Color apple { red }; // my apple is red
    Feeling me { happy }; // I'm happy right now (even though my program doesn't compile) ğŸ¤£ å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆ ğŸ¤£

    return 0;
}
```

> [!Tip]
> Prefer putting your enumerations inside a named scope region (such as a namespace or class) so the enumerators donâ€™t pollute the global namespace.

---
## Enumeration type

æšä¸¾å™¨çš„å€¼å±äºæ•´æ•°ç±»å‹ã€‚ä½†æ˜¯å…·ä½“æ˜¯å“ªç§æ•´æ•°ç±»å‹å‘¢ï¼Ÿ

ç”¨äºè¡¨ç¤ºæšä¸¾å™¨å€¼çš„ç‰¹å®šæ•´æ•°ç±»å‹ç§°ä¸ºæšä¸¾çš„åº•å±‚ç±»å‹ (**underlying type** or **base**)ã€‚ C++ æ ‡å‡†å¹¶æœªæŒ‡å®šï¼Œå› æ­¤å…·ä½“é€‰æ‹©ç”±å®ç°å®šä¹‰ã€‚å¤§å¤šæ•°ç¼–è¯‘å™¨ä¼šä½¿ç”¨ int ä½œä¸ºåº•å±‚ç±»å‹ã€‚

å¯ä»¥ä¸ºæšä¸¾æ˜¾å¼æŒ‡å®šåº•å±‚ç±»å‹ã€‚åº•å±‚ç±»å‹å¿…é¡»æ˜¯æ•´æ•°ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåœ¨æŸäº›å¸¦å®½æ•æ„Ÿçš„ç¯å¢ƒä¸­å·¥ä½œï¼ˆä¾‹å¦‚é€šè¿‡ç½‘ç»œå‘é€æ•°æ®ï¼‰ï¼Œåˆ™å¯èƒ½éœ€è¦ä¸ºæšä¸¾æŒ‡å®šä¸€ä¸ªè¾ƒå°çš„ç±»å‹ï¼š

```cpp
#include <cstdint>  // for std::int8_t
#include <iostream>

// Use an 8-bit integer as the enum underlying type
enum Color : std::int8_t
{
    black,
    red,
    blue,
};

int main()
{
    Color c{ black };
    std::cout << sizeof(c) << '\n'; // prints 1 (byte)

    return 0;
}
```

> [!Best practice]
> Specify the base type of an enumeration only when necessary.

> [!Warning]
> BecauseÂ `std::int8_t`Â andÂ `std::uint8_t`Â are usually type aliases for char types, using either of these types as the enum base will most likely cause the enumerators to print as char values rather than int values.

---
## Integer to unscoped enumerator conversion

While the compiler will implicitly convert an unscoped enumeration to an integer, it willÂ _not_Â implicitly convert an integer to an unscoped enumeration. The following will produce a compiler error:

```cpp
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { 2 }; // compile error: integer value 2 won't implicitly convert to a Pet
    pet = 3;       // compile error: integer value 3 won't implicitly convert to a Pet

    return 0;
}
```

There are two ways to work around this.

First, you can explicitly convert an integer to an unscoped enumerator usingÂ `static_cast`:

```cpp
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { static_cast<Pet>(2) }; // convert integer 2 to a Pet
    pet = static_cast<Pet>(3);       // our pig evolved into a whale!

    return 0;
}
```

Second, as of C++17, if an un-scoped enumeration has an explicitly specified base, then the compiler will allow you to list initialize an un-scoped enumeration using an integral value:

```cpp
enum Pet: int // we've specified a base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet1 { 2 }; // ok: can brace initialize unscoped enumeration with specified base with integer (C++17)
    Pet pet2 (2);   // compile error: cannot direct initialize with integer
    Pet pet3 = 2;   // compile error: cannot copy initialize with integer

    pet1 = 3;       // compile error: cannot assign with integer

    return 0;
}
```

