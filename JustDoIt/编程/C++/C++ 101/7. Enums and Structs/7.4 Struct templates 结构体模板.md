
```cpp
#include <iostream>

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

int main()
{
    Pair<int> p1{ 5, 6 };        // instantiates Pair<int> and creates object p1
    std::cout << p1.first << ' ' << p1.second << '\n';

    Pair<double> p2{ 1.2, 3.4 }; // instantiates Pair<double> and creates object p2
    std::cout << p2.first << ' ' << p2.second << '\n';

    Pair<double> p3{ 7.8, 9.0 }; // creates object p3 using prior definition for Pair<double>
    std::cout << p3.first << ' ' << p3.second << '\n';

    return 0;
}
```

ç¼–è¯‘å™¨ç¼–è¯‘åï¼Œä¸Šé¢çš„ä»£ç ä¼šå˜æˆç±»ä¼¼ï¼š

```cpp
#include <iostream>

// A declaration for our Pair class template
// (we don't need the definition any more since it's not used)
template <typename T>
struct Pair;

// Explicitly define what Pair<int> looks like
template <> // tells the compiler this is a template type with no template parameters
struct Pair<int>
{
    int first{};
    int second{};
};

// Explicitly define what Pair<double> looks like
template <> // tells the compiler this is a template type with no template parameters
struct Pair<double>
{
    double first{};
    double second{};
};

int main()
{
    Pair<int> p1{ 5, 6 };        // instantiates Pair<int> and creates object p1
    std::cout << p1.first << ' ' << p1.second << '\n';

    Pair<double> p2{ 1.2, 3.4 }; // instantiates Pair<double> and creates object p2
    std::cout << p2.first << ' ' << p2.second << '\n';

    Pair<double> p3{ 7.8, 9.0 }; // creates object p3 using prior definition for Pair<double>
    std::cout << p3.first << ' ' << p3.second << '\n';

    return 0;
}
```

---
## `std::pair`

ç”±äºä½¿ç”¨æˆå¯¹çš„æ•°æ®å¾ˆå¸¸è§ï¼ŒC++ æ ‡å‡†åº“åŒ…å«ä¸€ä¸ªåä¸º `std::pair` çš„ç±»æ¨¡æ¿ï¼ˆä½äº `<utility>` å¤´æ–‡ä»¶ä¸­ï¼‰ã€‚

```cpp
#include <iostream>
#include <utility>

template <typename T, typename U>
void print(std::pair<T, U> p)
{
    // the members of std::pair have predefined names `first` and `second`
    std::cout << '[' << p.first << ", " << p.second << ']';
}

int main()
{
    std::pair<int, double> p1{ 1, 2.3 }; // a pair holding an int and a double
    std::pair<double, int> p2{ 4.5, 6 }; // a pair holding a double and an int
    std::pair<int, int> p3{ 7, 8 };      // a pair holding two ints

    print(p2);

    return 0;
}
```

---
## åœ¨å¤šä¸ªæ–‡ä»¶ä¹‹é—´å…±ç”¨æ¨¡æ¿

ä¸å‡½æ•°æ¨¡æ¿ç±»ä¼¼ï¼Œç±»æ¨¡æ¿é€šå¸¸å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­ï¼Œä»¥ä¾¿å¯ä»¥å°†å…¶åŒ…å«åˆ°ä»»ä½•éœ€è¦å®ƒä»¬çš„ä»£ç æ–‡ä»¶ä¸­ã€‚

æ¨¡æ¿å®šä¹‰å’Œç±»å‹å®šä¹‰å‡ä¸å—å•ä¸€å®šä¹‰è§„åˆ™çš„çº¦æŸï¼ˆåªè¦å„ä¸ªæ–‡ä»¶ä¸­çš„å®šä¹‰æ˜¯ä¸€è‡´çš„ï¼‰ã€‚

[[5.6 Using function templates in multiple files#ä¸ºä»€ä¹ˆæŠŠæ¨¡æ¿å‡½æ•°æ”¾åœ¨å¤´æ–‡ä»¶é‡Œæ²¡æœ‰è¿åå•ä¸€å®šä¹‰è§„åˆ™ (ODR) ï¼Ÿ]]

`pair.h:`

```cpp
#ifndef PAIR_H
#define PAIR_H

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

template <typename T>
constexpr T max(Pair<T> p)
{
    return (p.first < p.second ? p.second : p.first);
}

#endif
```

`foo.cpp:`

```cpp
#include "pair.h"
#include <iostream>

void foo()
{
    Pair<int> p1{ 1, 2 };
    std::cout << max(p1) << " is larger\n";
}
```

`main.cpp:`

```cpp
#include "pair.h"
#include <iostream>

void foo(); // forward declaration for function foo()

int main()
{
    Pair<double> p2 { 3.4, 5.6 };
    std::cout << max(p2) << " is larger\n";

    foo();

    return 0;
}
```

---
## Alias templates æ¨¡æ¿åˆ«å

```cpp
#include <iostream>

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

template <typename T>
using Coord = Pair<T>; // ğŸ‘ˆ è¿™é‡Œè¿™é‡Œè¿™é‡Œ Coord is an alias for Pair<T>

template <typename T>
void print(const Coord<T>& c)
{
    std::cout << c.first << ' ' << c.second << '\n';
}

int main()
{
    Coord<int> p1 { 1, 2 }; // åœ¨ C++20 ä¹‹å‰: æˆ‘ä»¬å¿…é¡»æ˜ç¡®æŒ‡å®šæ‰€æœ‰ç±»å‹æ¨¡æ¿å‚æ•°
    
    Coord p2 { 1, 2 };      // åœ¨ C++20 ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ«åæ¨¡æ¿æ¨å¯¼æ¥æ¨å¯¼æ¨¡æ¿å‚æ•°ï¼Œå‰ææ˜¯ CTAD å¯ä»¥æ­£å¸¸å·¥ä½œ
    
    std::cout << p1.first << ' ' << p1.second << '\n';
    print(p2);

    return 0;
}
```

è¿™æ ·ç»™Pairèµ·ä¸ªå«Coordçš„åˆ«åæœ‰ä»€ä¹ˆæ„ä¹‰å‘¢ï¼Ÿç›´æ¥ä¸å« Pair å« Coord ä¸å°±è¡Œäº†ï¼Ÿ

No no no...

> [!Tip]
> æœ¬è´¨ä¸Šæ˜¯åŠ ä¸€å±‚ Coord åˆ«åèƒ½å¸®åŠ©å±è”½æ‰åº•å±‚çš„ä¿®æ”¹å˜åŠ¨ï¼Œä¸å½±å“åˆ°æ¥å£ã€‚
> 
> æ¨¡æ¿åˆ«åèƒ½å¤Ÿå¸®åŠ©å®ç°æ¥å£å±‚çš„æŠ½è±¡ï¼Œå¢å¼ºä»£ç çš„å¯ç»´æŠ¤æ€§ã€‚

1. æ¥å£æŠ½è±¡å±‚
	å®ç°è§£è€¦ï¼šè°ƒç”¨æ–¹åªéœ€ä¾èµ– Coord çš„æ¥å£ï¼Œæ— éœ€çŸ¥é“åº•å±‚æ˜¯ Pair è¿˜æ˜¯å…¶ä»–å®¹å™¨

``` cpp
template<typename T>
void print(const Coord<T>& c); // æ¥å£æ˜ç¡®è¦æ±‚åæ ‡ç±»å‹

// åç»­å¯ä¿®æ”¹ Coord çš„å®é™…ç±»å‹è€Œä¸å½±å“æ¥å£ï¼Œæ¯”å¦‚ä¿®æ”¹å®ç°ä¸ºæ•°ç»„
template<typename T>
using Coord = std::array<T,2>; // æ¥å£æ— éœ€å˜åŠ¨
```

2. ä»£ç ç»´æŠ¤æ€§
	é›†ä¸­æ§åˆ¶ï¼šé€šè¿‡ä¿®æ”¹å•ä¸ªåˆ«åæ¨¡æ¿å³å¯å…¨å±€è°ƒæ•´ç±»å‹å®ç°
	é™ä½è€¦åˆï¼šä¸šåŠ¡é€»è¾‘ä»£ç æ— éœ€çŸ¥é“åº•å±‚æ•°æ®ç»“æ„å˜åŒ–

``` cpp
// åŸå§‹ç‰ˆæœ¬
struct Pair { /*...*/ };

// éœ€æ±‚å˜æ›´ï¼šåæ ‡éœ€è¦å¢åŠ  Z è½´
template<typename T>
struct Coord3D { T x,y,z; };

// åªéœ€ä¿®æ”¹åˆ«åæ¨¡æ¿
template<typename T>
using Coord = Coord3D<T>; // æ‰€æœ‰ä½¿ç”¨ Coord çš„ä»£ç è‡ªåŠ¨å‡çº§ä¸ºä¸‰ç»´åæ ‡
