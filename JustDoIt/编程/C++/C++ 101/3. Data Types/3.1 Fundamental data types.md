## Bits, bytes, and memory addressing

variables are names for a piece of memory that can be used to store information. è®¡ç®—æœºæœ‰å¯ä¾›ç¨‹åºä½¿ç”¨çš„éšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆRAMï¼‰ã€‚å½“å®šä¹‰ä¸€ä¸ªå˜é‡æ—¶ï¼Œå†…å­˜ä¸­çš„ä¸€éƒ¨åˆ†å°±è¢«åˆ†é…ç»™è¯¥å˜é‡ã€‚

The smallest unit of memory is aÂ **binary digit**Â (also called aÂ **bit**), which can hold a value of 0 or 1. å†…å­˜çš„æœ€å°å•ä½æ˜¯äºŒè¿›åˆ¶ä½ï¼ˆä¹Ÿç§°ä¸ºæ¯”ç‰¹ï¼‰ï¼Œå®ƒå¯ä»¥å­˜å‚¨0æˆ–1çš„å€¼ã€‚

Memory is organized into sequential units calledÂ **memory addresses**Â (orÂ **addresses**Â for short). å†…å­˜è¢«ç»„ç»‡æˆç§°ä¸ºå†…å­˜åœ°å€çš„è¿ç»­å•å…ƒï¼ˆç®€ç§°ä¸ºåœ°å€ï¼‰ã€‚ç±»ä¼¼äºè¡—é“åœ°å€å¯ä»¥ç”¨æ¥æ‰¾åˆ°è¡—ä¸Šçš„æŸä¸ªæˆ¿å­ï¼Œå†…å­˜åœ°å€å…è®¸æˆ‘ä»¬æ‰¾åˆ°å¹¶è®¿é—®ç‰¹å®šä½ç½®çš„å†…å­˜å†…å®¹ã€‚

ä¹Ÿè®¸ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œåœ¨ç°ä»£è®¡ç®—æœºæ¶æ„ä¸­ï¼Œ==æ¯ä¸ªæ¯”ç‰¹å¹¶æ²¡æœ‰è‡ªå·±çš„å”¯ä¸€å†…å­˜åœ°å€==ã€‚è¿™æ˜¯å› ä¸ºå†…å­˜åœ°å€çš„æ•°é‡æ˜¯æœ‰é™çš„ï¼Œå¹¶ä¸”é€ä½è®¿é—®æ•°æ®çš„éœ€æ±‚å¾ˆå°‘ã€‚ç›¸åï¼Œæ¯ä¸ªå†…å­˜åœ°å€å­˜å‚¨1å­—èŠ‚çš„æ•°æ®ã€‚å­—èŠ‚æ˜¯ä¸€ç»„ä½œä¸ºä¸€ä¸ªå•å…ƒæ“ä½œçš„æ¯”ç‰¹ã€‚ç°ä»£æ ‡å‡†æ˜¯ä¸€ä¸ªå­—èŠ‚ç”±8ä¸ªè¿ç»­çš„æ¯”ç‰¹ç»„æˆã€‚

---

## Fundamental data types

C++ è¯­è¨€è‡ªå¸¦äº†è®¸å¤šé¢„å®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå…¶ä¸­æœ€åŸºæœ¬çš„ç±»å‹ç§°ä¸º **fundamental data types**Â (informally sometimes calledÂ **basic types**Â orÂ **primitive types**).


## åŸºç¡€ç±»å‹
 
 `_t` åç¼€

Many of the types defined in newer versions of C++ (e.g.Â `std::nullptr_t`) use a `_t` suffix. This suffix **means â€œtypeâ€**, æ˜¯ç°ä»£C++å¸¸ç”¨çš„å‘½åæ³•ã€‚

If you see something with a `_t` suffix, itâ€™s probably a type. ä½†ä¹Ÿæœ‰å¾ˆå¤šç±»å‹æ²¡åŠ è¿™ä¸ªåç¼€... ğŸ’…

---

`sizeof`Â does not include dynamically allocated memory used by an object.

---

Fundamental data type performance

On modern machines, objects of the fundamental data types are fast, so performance while using or copying these types should generally not be a concern.

As an asideâ€¦

You might assume that types that use less memory would be faster than types that use more memory. This is not always true. CPUs are often optimized to process data of a certain size (e.g. 32 bits), and types that match that size may be processed quicker. On such a machine, a 32-bit int could be faster than a 16-bit short or an 8-bit char.

---
int

Overflow

- å¦‚æœæœ‰ç¬¦å·å€¼æº¢å‡ºï¼Œä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚
- å¦‚æœæ— ç¬¦å·å€¼æº¢å‡ºï¼Œåˆ™å°†å…¶é™¤ä»¥æ¯”è¯¥ç±»å‹æœ€å¤§æ•°å­—å¤§ä¸€çš„æ•°å­—ï¼Œå¹¶ä¸”åªä¿ç•™ä½™æ•°ã€‚æ‰€ä»¥æ¯”å¦‚åœ¨shortç±»å‹ä¸Šï¼Œ`257`Â wraps around to the valueÂ `1`.Â `280`Â wraps around to the valueÂ `24`.

ç”¨æ— ç¬¦å·å€¼å®¹æ˜“å¼•å‘ä¸¤ä¸ªé—®é¢˜ï¼š
- ä¸‹é™æ˜¯0ï¼Œæ¯”èµ·ä¸‹é™æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„è´Ÿæ•°è€Œè¨€æ›´å®¹æ˜“æº¢å‡ºã€‚
- å½“ç®—å¼ï¼ˆe.g. arithmetic or comparisonï¼‰ä¸­åˆæœ‰ signed åˆæœ‰ unsigned æ—¶å®¹æ˜“å‡ºé”™ã€‚
``` C++
#include <iostream>

int main()
{
	unsigned int u{ 2 };
	signed int s{ 3 };

	std::cout << u - s << '\n'; // 2 - 3 = 4294967295

	return 0;
}
```
becauseÂ `u`Â is unsigned (which is easy to miss),Â `s`Â gets converted to unsigned, and the result (`-1`) is treated as an unsigned value.

``` C++
#include <iostream>

// assume int is 4 bytes
int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
        std::cout << "-1 is less than 1\n";
    else
        std::cout << "1 is less than -1\n"; // this statement executes

    return 0;
}
```


> [!Warning]
> Avoid mixing signed and unsigned numbers.

---

Fixed-width int

æŒ‰ç…§ç°ä»£æ ‡å‡†ï¼Œå„ç§ int ç¼ºä¹ä¸€è‡´çš„èŒƒå›´ï¼Œè¿™å¾ˆç³Ÿç³•ï¼ˆå°¤å…¶å¯¹è¦è€ƒè™‘å¯ç§»æ¤æ€§çš„ä»£ç æ¥è¯´ï¼‰ã€‚

ä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜ï¼ŒC++11 æä¾›äº†ä¸€ç»„å®šå®½æ•´æ•°ã€‚`std::int8_t` `std::uint8_t` ç­‰ã€‚

> [!Warning]
> `std::int8_t`Â andÂ `std::uint8_t`Â typically behave like chars.
> The 16-bit and wider integral types are not subject to this issue.

ä¾‹å¦‚ï¼š
``` C++
#include <cstdint> // for fixed-width integers
#include <iostream>

int main()
{
    std::int8_t x { 65 };   // initialize 8-bit integral type with value 65
    std::cout << x << '\n'; // å¾ˆå¯èƒ½è¾“å‡ºçš„æ˜¯ä¸€ä¸ªcharå­—æ¯
    return 0;
}
```

In cases whereÂ `std::int8_t`Â is treated as a char, input from the console can also cause problems:

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::cout << "Enter a number between 0 and 127: ";
    std::int8_t myInt{};
    std::cin >> myInt;

    std::cout << "You entered: " << static_cast<int>(myInt) << '\n';

    return 0;
}
```
output:
```
Enter a number between 0 and 127: 35
You entered: 51
```

å½“Â `std::int8_t`Â is treated as a char, æˆ‘ä»¬è¾“å…¥35ï¼Œactually entering two chars,Â `'3'`Â andÂ `'5'`. 
Because a char object can only hold one character, theÂ `'3'`Â is extracted (theÂ `'5'`Â is left in the input stream). 
Because the charÂ `'3'`Â has ASCII code point 51, the valueÂ `51`Â is stored inÂ `myInt`, which we then print later as an int.

---
`std::size_t` 

- `std::size_t` æ˜¯ä¸€ä¸ª implementation-defined ï¼ˆç”±å…·ä½“å®ç°å†³å®šçš„ï¼‰æ— ç¬¦å·æ•´æ•°ç±»å‹çš„åˆ«åã€‚ç”¨äºè¡¨ç¤ºå¯¹è±¡çš„å­—èŠ‚å¤§å°æˆ–é•¿åº¦ã€‚
- `std::size_t` å®é™…ä¸Šæ˜¯ä¸€ä¸ª typedef
- `sizeof`Â çš„è¿”å›å€¼æ˜¯Â `std::size_t` ç±»å‹
- `std::size_t`Â é™åˆ¶äº†å¯¹è±¡çš„æœ€å¤§ä¸Šé™ï¼Œå› ä¸ºå¦‚æœè¶…å‡ºèŒƒå›´åˆ™ sizeof å‡½æ•°ä¼šå¤±æ•ˆï¼Œè¿™ä¸è¢«å…è®¸ã€‚

---

float

ç§‘å­¦è®¡æ•°æ³•

è®¡ç®—æœºä¸Šé€šå¸¸ä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•æ¥è¡¨ç¤ºæµ®ç‚¹å€¼ï¼Œä¸»è¦æ˜¯å› ä¸ºè¿™ç§æ–¹æ³•èƒ½å¤Ÿæœ‰æ•ˆåœ°è¡¨ç¤ºéå¸¸å¤§æˆ–éå¸¸å°çš„æ•°å€¼ï¼ŒåŒæ—¶ä¿æŒä¸€å®šçš„ç²¾åº¦ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å…·ä½“åŸå› ï¼š

1. **èŒƒå›´å¹¿æ³›**ï¼šç§‘å­¦è®¡æ•°æ³•å…è®¸åœ¨ä¸€ä¸ªç›¸å¯¹è¾ƒå°çš„å­˜å‚¨ç©ºé—´å†…è¡¨ç¤ºéå¸¸å¤§çš„æ•°ï¼ˆå¦‚ 10381038ï¼‰å’Œéå¸¸å°çš„æ•°ï¼ˆå¦‚ 10âˆ’3810âˆ’38ï¼‰ã€‚è¿™å¯¹äºéœ€è¦å¤„ç†å„ç§æ•°é‡çº§çš„è®¡ç®—éå¸¸é‡è¦ã€‚
    
2. **ç²¾åº¦ç®¡ç†**ï¼šé€šè¿‡åˆ†ç¦»æ•°å€¼çš„æœ‰æ•ˆä½æ•°ï¼ˆå°¾æ•°ï¼‰å’Œæ•°é‡çº§ï¼ˆæŒ‡æ•°ï¼‰ï¼Œç§‘å­¦è®¡æ•°æ³•å¯ä»¥åœ¨ä¸€å®šèŒƒå›´å†…ä¿æŒæ•°å€¼çš„ç²¾åº¦ã€‚è¿™ç§è¡¨ç¤ºæ–¹æ³•ä½¿å¾—è®¡ç®—æœºèƒ½å¤Ÿåœ¨ä¸åŒçš„æ•°é‡çº§ä¸Šè¿›è¡Œè®¡ç®—ï¼Œè€Œä¸ä¼šå› ä¸ºæ•°å€¼è¿‡å¤§æˆ–è¿‡å°è€Œä¸¢å¤±ç²¾åº¦ã€‚
    
3. **æ ‡å‡†åŒ–è¡¨ç¤º**ï¼šæµ®ç‚¹æ•°é€šå¸¸éµå¾ª IEEE 754 æ ‡å‡†ï¼Œè¯¥æ ‡å‡†ä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•æ¥å®šä¹‰æµ®ç‚¹æ•°çš„å­˜å‚¨æ ¼å¼ã€‚è¿™ç§æ ‡å‡†åŒ–çš„è¡¨ç¤ºæ–¹æ³•ç¡®ä¿äº†ä¸åŒè®¡ç®—æœºç³»ç»Ÿä¹‹é—´çš„å…¼å®¹æ€§å’Œä¸€è‡´æ€§ã€‚
    
4. **è®¡ç®—æ•ˆç‡**ï¼šç§‘å­¦è®¡æ•°æ³•ä½¿å¾—æµ®ç‚¹è¿ç®—ï¼ˆå¦‚åŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•å’Œé™¤æ³•ï¼‰å¯ä»¥é€šè¿‡ç¡¬ä»¶åŠ é€Ÿå®ç°ï¼Œä»è€Œæé«˜è®¡ç®—æ•ˆç‡ã€‚å¤„ç†æµ®ç‚¹æ•°çš„ç¡¬ä»¶é€šå¸¸ä¸“é—¨è®¾è®¡ç”¨äºå¤„ç†è¿™ç§æ ¼å¼çš„æ•°æ®ã€‚
    

æ€»ä¹‹ï¼Œç§‘å­¦è®¡æ•°æ³•åœ¨è®¡ç®—æœºä¸­ç”¨äºæµ®ç‚¹å€¼çš„è¡¨ç¤ºï¼Œä¸»è¦æ˜¯å› ä¸ºå®ƒèƒ½å¤Ÿåœ¨æœ‰é™çš„å­˜å‚¨ç©ºé—´å†…æä¾›å¹¿æ³›çš„æ•°å€¼èŒƒå›´å’Œåˆç†çš„ç²¾åº¦ï¼ŒåŒæ—¶æ”¯æŒé«˜æ•ˆçš„è®¡ç®—æ“ä½œã€‚

---

**rounding error** è¯¯å·®

``` C++
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    float f { 123456789.0f }; // f has 10 significant digits
    std::cout << std::setprecision(9); // to show 9 digits in f
    std::cout << f << '\n';

    return 0;
}
```

outputï¼š
```
123456792
```
The value 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision (and the result of 123456792 is precise only to 7 significant digits). We lost some precision!


==ã€ float values typically have 7 digits of precisionï¼Ÿwhyï¼Ÿã€‘==

æµ®ç‚¹æ•°çš„ç²¾åº¦ä¸å…¶åº•å±‚è¡¨ç¤ºæ–¹å¼æœ‰å…³ã€‚åœ¨è®¡ç®—æœºä¸­ï¼Œå•ç²¾åº¦æµ®ç‚¹æ•°é€šå¸¸éµå¾ª IEEE 754 æ ‡å‡†ï¼Œè¯¥æ ‡å‡†å®šä¹‰äº†å•ç²¾åº¦æµ®ç‚¹æ•°çš„æ ¼å¼ã€‚

å•ç²¾åº¦æµ®ç‚¹æ•°ï¼ˆé€šå¸¸ç§°ä¸º `float`ï¼‰åœ¨ IEEE 754 æ ‡å‡†ä¸­å ç”¨ 32 ä½ï¼Œå…¶ä¸­ï¼š

- 1 ä½ç”¨äºç¬¦å·ä½ã€‚
- 8 ä½ç”¨äºæŒ‡æ•°ã€‚
- 23 ä½ç”¨äºå°¾æ•°ï¼ˆä¹Ÿç§°ä¸ºæœ‰æ•ˆæ•°å­—æˆ–å°æ•°éƒ¨åˆ†ï¼‰ã€‚

ç”±äºå°¾æ•°éƒ¨åˆ†æ˜¯ä»¥äºŒè¿›åˆ¶è¡¨ç¤ºçš„ï¼Œè¿™ 23 ä½çš„å°¾æ•°å¯ä»¥æä¾›å¤§çº¦ 6 åˆ° 9 ä½çš„åè¿›åˆ¶ç²¾åº¦ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬è¯´å•ç²¾åº¦æµ®ç‚¹æ•°æœ‰å¤§çº¦ 7 ä½åè¿›åˆ¶ç²¾åº¦æ˜¯å› ä¸ºåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç²¾åº¦èŒƒå›´èƒ½å¤Ÿå¯é åœ°è¡¨ç¤ºæ•°å€¼ã€‚

å…·ä½“æ¥è¯´ï¼Œ7 ä½ç²¾åº¦æ˜¯ä¸€ä¸ªç»éªŒå€¼ï¼Œè¡¨ç¤ºåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå•ç²¾åº¦æµ®ç‚¹æ•°èƒ½å¤Ÿå‡†ç¡®è¡¨ç¤ºçš„åè¿›åˆ¶æ•°å­—çš„æ•°é‡ã€‚è¿™ä¸ªæ•°å­—æ˜¯ä¸€ä¸ªè¿‘ä¼¼å€¼ï¼Œå› ä¸ºæµ®ç‚¹æ•°çš„ç²¾åº¦å®é™…ä¸Šå–å†³äºå…·ä½“çš„æ•°å€¼å’Œå®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºæ–¹å¼ã€‚

å› æ­¤ï¼Œ7 ä½ç²¾åº¦æ˜¯ä¸€ä¸ªæ–¹ä¾¿çš„å‚è€ƒå€¼ï¼Œç”¨äºæè¿°å•ç²¾åº¦æµ®ç‚¹æ•°åœ¨å®é™…åº”ç”¨ä¸­çš„è¡¨ç°ã€‚


---

NaN å’Œ Inf 

IEEE 754 å…¼å®¹æ ¼å¼è¿˜æ”¯æŒä¸€äº›ç‰¹æ®Šå€¼ï¼š 
- Infï¼Œè¡¨ç¤ºæ— ç©·å¤§ã€‚Inf æ˜¯æœ‰ç¬¦å·çš„ï¼Œå¯ä»¥æ˜¯æ­£æ•° (+Inf) æˆ–è´Ÿæ•° (-Inf)ã€‚ 
- NaNï¼Œä»£è¡¨â€œéæ•°å­—â€ã€‚NaN æœ‰å‡ ç§ä¸åŒçš„ç±»å‹ã€‚ 
- Signed zeroï¼Œè¿™æ„å‘³ç€â€œæ­£é›¶â€ï¼ˆ+0.0ï¼‰å’Œâ€œè´Ÿé›¶â€ï¼ˆ-0.0ï¼‰æœ‰ä¸åŒçš„è¡¨ç¤ºå½¢å¼ã€‚
---

char

**Initializing chars**

You can initialize char variables using character literals:

```cpp
char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)
```

You can initialize chars with integers as well, but this should be avoided if possible

```cpp
char ch1{ 97 }; // initialize with integer 97 ('a') (not preferred)
```

æ‰€ä»¥è¦æ³¨æ„ï¼Œä»¥ä¸‹ä¸¤ä¸ªä»£ç æ˜¯ä¸åŒçš„ï¼š
``` C++
char ch{5}; // initialize with integer 5 (stored as integer 5)
char ch{'5'}; // initialize with code point for '5' (stored as integer 53)
```

---

**Inputting chars**

```cpp
#include <iostream>

int main()
{
    std::cout << "Input a keyboard character: "; // assume the user enters "abcd" (without quotes)

    char ch{};
    std::cin >> ch; // ch = 'a', "bcd" is left queued.
    std::cout << "You entered: " << ch << '\n';

    // Note: The following cin doesn't ask the user for input, it grabs queued input!
    std::cin >> ch; // ch = 'b', "cd" is left queued.
    std::cout << "You entered: " << ch << '\n';

    return 0;
}
```

outputï¼š
```
Input a keyboard character: abcd
You entered: a
You entered: b
```

---

## ç±»å‹è½¬æ¢


**Type conversion of a value produces a new value**

ç±»å‹è½¬æ¢ç±»ä¼¼äºè°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°çš„è¿”å›ç±»å‹ä¸è½¬æ¢çš„ç›®æ ‡ç±»å‹åŒ¹é…ã€‚è¦è½¬æ¢çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œè½¬æ¢åçš„ç»“æœå°†è¿”å›åˆ°ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ä¸­ä¾›è°ƒç”¨è€…ä½¿ç”¨ã€‚

ä¸€äº›é«˜çº§ç±»å‹è½¬æ¢ï¼ˆä¾‹å¦‚ `const_cast` æˆ– `reinterpret_cast` ï¼‰ä¸ä¼šè¿”å›ä¸´æ—¶å¯¹è±¡ï¼Œè€Œæ˜¯é‡æ–°è§£é‡Šç°æœ‰å€¼æˆ–å¯¹è±¡çš„ç±»å‹ã€‚

ä¸å®‰å…¨çš„éšå¼è½¬æ¢é€šå¸¸ä¼šç”Ÿæˆç¼–è¯‘å™¨è­¦å‘Šï¼Œè¿™æ˜¯æ‹¬å·åˆå§‹åŒ–æˆä¸ºé¦–é€‰åˆå§‹åŒ–å½¢å¼çš„ä¸»è¦åŸå› ä¹‹ä¸€ã€‚

``` C++
int main()
{
    double d { 5 }; // okay: int to double is safe
    int x { 5.5 }; // error: double to int not safe

    return 0;
}
```

> [!Tips]
> Brace initialization ä¸å…è®¸çª„åŒ–è½¬æ¢ï¼ˆnarrowing conversionï¼‰ï¼Œå³æŸå¤±ç²¾åº¦ã€‚

---

**Explicit type conversion**

Â `static_cast`
Â 
To perform an explicit type conversion, in most cases weâ€™ll use theÂ `static_cast`Â operator. The syntax for theÂ `static cast`Â looks a little funny:

`static_cast<new_type>(expression)`

static_cast takes the value from an expression as input, and returns that value converted into the type specified byÂ _new_type_Â (e.g. int, bool, char, double).

> [!Key insight]
> Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets (<>), the thing between the angled brackets will most likely be a type. This is typically how C++ deals with code that need a parameterized type.

Â `static_cast` è¿˜å¯ä»¥ç”¨æ¥è½¬æ¢ç¬¦å·ã€‚

``` C++
#include <iostream>

int main()
{
    int s { -1 };
    std::cout << static_cast<unsigned int>(s) << '\n'; // prints 4294967295

    unsigned int u { 4294967295 }; // largest 32-bit unsigned int
    std::cout << static_cast<int>(u) << '\n'; // implementation-defined prior to C++20, -1 as of C++20

    return 0;
}
```
outputï¼š
```
4294967295
-1
```

> [!Warning]
> Converting an unsigned integral value to a signed integral value will result in implementation-defined behavior prior to C++20 if the value being converted can not be represented in the signed type.

