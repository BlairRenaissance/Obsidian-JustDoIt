## `static constexpr const char*`

为什么要写成这样：
``` C++
namespace maleoon {
	constexpr const char* MAIN_FBO_NAME = "MainRenderPass";
	
	// C++17之后
	inline const std::string MAIN_FBO_NAME = "MainRenderPass";
}
```

- `const char*` 表示指针指向的内容是不可变的（字符串字面量本身是只读的）。
- `constexpr` 表示指针本身的值（即地址）在编译期确定。

换句话说：

- `const char*`：指针指向的字符是不可修改的。
- `constexpr`：指针变量本身是编译期常量，指向的地址在编译期就确定了。

如果写成 `constexpr char*` 会怎样？
``` C++
namespace maleoon {
	constexpr char* p = "MainRenderPass"; // 错误！
}
```

这里会报错，因为字符串字面量是只读的，不能用非常量指针指向它。

- `constexpr` 修饰变量时，表示该变量是**编译时常量**，其值在编译期就确定。
- `constexpr` 修饰的是变量本身（这里是指针变量 `p`），而不是指针指向的内容。
- **但指针指向的内容（`char`）本身并不受 `constexpr` 约束**，即指针指向的字符内容不是常量。

---
## `int* const p` 和 `const int* p` 的区别

| 声明                              | 指针本身是否常量 | 指针指向内容是否常量 | 备注             |
| ------------------------------- | -------- | ---------- | -------------- |
| `int* p`                        | 否        | 否          | 指针和内容都可变       |
| `const int* p` 或 `int const* p` | 否        | 是          | 指针可变，内容不可变     |
| `int* const p`                  | 是        | 否          | 指针不可变，内容可变     |
| `const int* const p`            | 是        | 是          | 指针和内容都不可变      |
| `constexpr int* p`              | 是（编译时常量） | 否          | 指针是编译时常量，内容可变  |
| `constexpr const int* p`        | 是（编译时常量） | 是          | 指针是编译时常量，内容不可变 |

关键在于 `const` 修饰的是指针本身，还是指针指向的内容。

这是 C++ 中指针和 `const` 结合时非常经典且容易混淆的一个问题。  

| 声明                                | 含义                | 指针本身是否可变 | 指针指向内容是否可变 |
| --------------------------------- | ----------------- | -------- | ---------- |
| `int* const p`                    | **常量指针**，指针本身不可变  | 否        | 是          |
| `const int* p`等价于 `int const* p`） | **指向常量的指针**，内容不可变 | 是        | 否          |

**记忆技巧：**
- **`const` 在 `*` 左边（靠近类型）修饰的是指针指向的内容**，内容不可变。
- **`const` 在 `*` 右边（靠近变量名）修饰的是指针本身**，指针不可变。

---
## const 成员的初始化

因为构造函数体内赋值属于先初始化后，再赋值。因此 const 成员不能这样做。

| 方式                                | 是初始化还是赋值？ | 过程                  |
| --------------------------------- | --------- | ------------------- |
| 类内成员初始化（`int x = 10;`）            | **初始化**   | 编译器在构造时直接初始化成员      |
| 构造函数初始化列表（`MyClass() : x(10) {}`） | **初始化**   | 推荐方式，尤其是const、引用等成员 |
| 构造函数体内赋值（`x = 10;`）               | **赋值**    | 先默认初始化，再赋值，效率较低     |

const 成员的初始化方式是构造函数初始化列表或类内成员初始化：

|场景/需求|推荐方式|理由|
|---|---|---|
|成员有合理的默认值|**类内初始化**|简洁，避免重复代码，构造函数无需显式初始化|
|需要根据构造函数参数动态初始化|**构造函数初始化列表**|灵活，能根据参数赋不同值|
|既有默认值又有参数化初始化|**类内初始化 + 构造函数初始化列表覆盖**|默认值保证无参构造安全，参数化构造函数覆盖默认值|
|代码风格偏向统一初始化|任选|但构造函数初始化列表更传统，兼容性好|

---
## 静态常量成员的初始化

但当遇上 static 时，成员会带上外部链接，这时情况会有一点复杂：

| 情况                          | 是否违反 ODR？   | 说明                         |
| --------------------------- | ----------- | -------------------------- |
| `static const int` 类内初始化    | 不违反（不取地址时）  | 编译期常量，内联使用，不产生存储空间         |
| `static constexpr` 类内初始化    | 不违反         | 内联变量，编译期常量，C++17 起正式支持内联变量 |
| 非 `constexpr` `static` 成员变量 | 违反（如果类内初始化） | 必须类外定义，否则链接错误              |
| `inline static` 变量（C++17 起） | 不违反         | 内联变量，允许类内初始化               |
| 非静态成员变量类内初始化                | 不违反         | 属于类定义的一部分，不涉及链接定义          |

> [!Question]
> 为什么类内初始化的 `static const int` 或 `static constexpr float` 等为什么不会违反 ODR？

### `static const int` 类内初始化

`struct A {     static const int x = 10; };`

 - **类内初始化的 `static const int` 只是声明+初始化，不是完整定义**（在大多数情况下）。
-  ==如果你没有在类外定义它，且没有取地址，编译器通常会把它当作编译时常量直接替换，不会产生实际变量。 所以放在头文件中的类内定义时，并不会导致多重定义问题。==
- 这是 C++98/03 标准允许的特例，目的是方便使用常量表达式。
- 只有当你**取地址**或**需要变量的存储空间**时，才需要在某个 `.cpp` 文件中提供定义。

**为什么不违反 ODR？**

- 因为这种成员变量是**整型常量表达式**，编译器通常会把它当作编译期常量内联使用，不会在程序中产生实际的存储空间（除非你取地址）。
- 如果你在类外没有再次定义它，链接器不会看到重复定义。
- 如果你取了地址，必须在类外定义一次，否则链接错误。

---
### `static constexpr` 成员变量（C++11 起）

`struct B {     static constexpr float pi = 3.14f; };`

- `constexpr` 表示该变量是编译期常量，且隐含 `const`。
- C++11 允许在类内直接初始化 `static constexpr` 成员变量，且**不需要在类外定义**（除非你取地址）。
- 这比 `static const int` 更通用，支持任意字面类型（整型、浮点型、枚举、字面类型等）。

**为什么不违反 ODR？**

- `static constexpr` 成员变量是**内联变量**（C++17 起正式支持内联变量），编译器会在每个使用点内联该值，不会产生重复定义。
- 这避免了链接时重复定义的问题。

---
### 类内初始化其他类型的 `static` 成员变量

- **非整型的 `static const` 成员变量**，如果在类内初始化，通常是不允许的（C++98/03），必须在类外定义。
- **非 `constexpr` 的 `static` 成员变量**，类内初始化是不允许的，必须在类外定义。
- **C++17 引入了内联变量（`inline` 变量）**，允许你写：

`struct C {     inline static int x = 42;  // 这是内联变量，允许类内初始化且不会违反 ODR };`

---
### 类内初始化非 `static` 成员变量是否违反 ODR？

- **非静态成员变量的类内初始化**是**每个对象的初始化方式**，不涉及链接层面的定义问题，不会违反 ODR。
- 因为非静态成员变量是对象的一部分，属于类的定义范畴，类的定义只出现一次。