## å¤´ç—›å— ğŸ¤• ï¼Ÿæ¥ç›´æ¥çœ‹æ€»ç»“

### 1.Â é¡¶å±‚Â `const`Â vs åº•å±‚Â `const`

| ç±»å‹          | ä½œç”¨å¯¹è±¡         | ç¤ºä¾‹                                   | ç‰¹æ€§        |
| ----------- | ------------ | ------------------------------------ | --------- |
| é¡¶å±‚ Â `const` | å¯¹è±¡æœ¬èº«         | `const int x`  <br>`int* const ptr`  | å¯¹è±¡ä¸å¯ä¿®æ”¹    |
| åº•å±‚ Â `const` | é€šè¿‡å¼•ç”¨/æŒ‡é’ˆè®¿é—®çš„å¯¹è±¡ | `const int& ref`<br>`const int* ptr` | æŒ‡å‘çš„å¯¹è±¡ä¸å¯ä¿®æ”¹ |
### 2.Â ç±»å‹æ¨å¯¼è§„åˆ™ï¼ˆ`auto`ï¼‰

æ¨å¯¼æ­¥éª¤ï¼š

1. å…ˆä¸¢å¼ƒå¼•ç”¨ï¼ˆé™¤éæ˜¾å¼å£°æ˜ä¸ºå¼•ç”¨ç±»å‹ï¼‰
    - ä¾‹ï¼š`const int&`Â â†’ ä¸¢å¼ƒå¼•ç”¨ â†’ å˜ä¸ºÂ `const int`ï¼ˆåº•å±‚â†’é¡¶å±‚è½¬æ¢ï¼‰
2. å†ä¸¢å¼ƒé¡¶å±‚Â `const`ï¼ˆé™¤éæ˜¾å¼å£°æ˜Â `const`/`constexpr`ï¼‰
    - ä¾‹ï¼š`const int`Â â†’ ä¸¢å¼ƒé¡¶å±‚Â `const`Â â†’ å˜ä¸ºÂ `int`
3. æŒ‡é’ˆæ°¸ä¸ä¸¢å¼ƒ
4. `constexpr`Â ä¸å‚ä¸æ¨å¯¼ï¼ˆå¿…é¡»æ˜¾å¼å£°æ˜ï¼‰

æ˜¾å¼å£°æ˜çš„é‡è¦æ€§ï¼š

``` cpp
const int a = 10;

// æ­£ç¡®ï¼šæ˜¾å¼å£°æ˜åº•å±‚ const + æ˜¾å¼å£°æ˜å¼•ç”¨
const auto& r1 = a;  // ç±»å‹ = const int&

// å±é™©ï¼šä¾èµ–æ¨å¯¼ï¼ˆé¡¶å±‚ const è¢«ä¸¢å¼ƒï¼‰
auto r2 = a;         // ç±»å‹ = intï¼ˆä¸¢å¼ƒ constï¼‰
```

### 3.Â æŒ‡é’ˆæ¨å¯¼çš„ç‰¹æ®Šè§„åˆ™

#### `auto`Â vsÂ `auto*`

|å£°æ˜æ–¹å¼|æ¨å¯¼ç‰¹æ€§|ç¤ºä¾‹ï¼ˆè®¾Â `int* p`ï¼‰|ç»“æœç±»å‹|
|---|---|---|---|
|`auto`|ä»…å½“åˆå§‹åŒ–å™¨æ˜¯æŒ‡é’ˆæ—¶æ‰æ¨å¯¼ä¸ºæŒ‡é’ˆ|`auto a = p;`|`int*`|
|`auto*`|å¼ºåˆ¶æ¨å¯¼ä¸ºæŒ‡é’ˆï¼ˆå¦åˆ™ç¼–è¯‘é”™è¯¯ï¼‰|`auto* b = p;`|`int*`|
|||`auto* c = 5;`|âŒ ç¼–è¯‘é”™è¯¯|
#### `const`Â åœ¨æŒ‡é’ˆæ¨å¯¼ä¸­çš„ä½ç½®

|å£°æ˜æ–¹å¼|ç­‰æ•ˆç±»å‹|ä½œç”¨|
|---|---|---|
|`const auto*`|`const int*`|åº•å±‚ constï¼ˆæŒ‡å‘çš„å¯¹è±¡ä¸å¯å˜ï¼‰|
|`auto* const`|`int* const`|é¡¶å±‚ constï¼ˆæŒ‡é’ˆæœ¬èº«ä¸å¯å˜ï¼‰|
|`const auto* const`|`const int* const`|åŒé‡ const|

### 4.Â æœ€ä½³å®è·µæ€»ç»“

1. **å§‹ç»ˆæ˜¾å¼å£°æ˜é™å®šç¬¦**    
```
const auto& ref = ...;  // è€Œé auto&
const auto* ptr = ...;  // è€Œé auto*
```
	å³ä½¿æ¨å¯¼ç»“æœç›¸åŒï¼Œæ˜¾å¼å£°æ˜èƒ½é¿å…æ­§ä¹‰
	
2. **æŒ‡é’ˆæ¨å¯¼ä¼˜å…ˆç”¨Â `auto*`**
	- å¼ºåˆ¶ç±»å‹å®‰å…¨ï¼ˆéæŒ‡é’ˆæ—¶æŠ¥é”™ï¼‰
	- æ˜ç¡®è¡¨è¾¾æŒ‡é’ˆæ„å›¾
	- æ–¹ä¾¿æ·»åŠ Â `const`Â é™å®šç¬¦
	
3. **`constexpr`Â å¿…é¡»æ‰‹åŠ¨æ·»åŠ **

---
## åˆå§‹åŒ–å˜é‡çš„ç±»å‹æ¨å¯¼

Literal suffixes can be used in combination with type deduction to specify a particular type:

```cpp
int main()
{
    auto a { 1.23f }; // f suffix causes a to be deduced to float
    auto b { 5u };    // u suffix causes b to be deduced to unsigned int

    return 0;
}
```

ä½¿ç”¨ç±»å‹æ¨æ–­çš„å˜é‡ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–è¯´æ˜ç¬¦/é™å®šç¬¦ï¼Œæ¯”å¦‚ `const`Â orÂ `constexpr`:

```cpp
int main()
{
    int a { 5 };            // a is an int

    const auto b { 5 };     // b is a const int
    constexpr auto c { 5 }; // c is a constexpr int

    return 0;
}
```

> [!Warning]
> 
> Prior to C++17,Â `auto d{ 5.0 };`Â would deduceÂ `d`Â to be of typeÂ `std::initializer_list<double>`Â rather thanÂ `double`. This was fixed in C++17, and many compilers (such as gcc and Clang) have back-ported this change to previous language standards.
> 
> If you are using C++14 or older, and the above example doesnâ€™t compile on your compiler, use copy initialization withÂ `auto`Â instead (`auto d = 5.0`).

---
### çº¯ `auto` æŠ›å¼ƒé¡¶å±‚`const`

``` cpp
int main()
{
    const int a { 5 }; // a has type const int
    auto b { a };      // b has type int (const dropped)
    return 0;
}
```
- `b`æ˜¯ç‹¬ç«‹çš„æ–°å¯¹è±¡ï¼Œä¸`a`æ— å…³
 - å…è®¸ä¿®æ”¹`b`ä¸ä¼šç ´å`a`çš„å¸¸é‡æ€§
 - ç¬¦åˆ"æœ€å°æ„å¤–åŸåˆ™"ï¼ˆç¨‹åºå‘˜é€šå¸¸æœŸæœ›å‰¯æœ¬å¯ä¿®æ”¹ï¼‰

| æ¨å¯¼æ–¹å¼              | `const`å¤„ç†          | ç¤ºä¾‹                                | ç»“æœç±»å‹         |
| ----------------- | ------------------ | --------------------------------- | ------------ |
| çº¯`auto`       | ä¸¢å¼ƒé¡¶å±‚`const`    | `const int a; auto b = a;`        | `int`        |
| `auto&`       | ä¿ç•™æ‰€æœ‰`const`    | `const int a; auto& b = a;`       | `const int&` |
| `const auto`  | æ˜¾å¼æ·»åŠ é¡¶å±‚`const`  | `const int a; const auto b = a;`  | `const int`  |
| `const auto&` | ä¿ç•™æ‰€æœ‰`const`Â + æ·»åŠ å¼•ç”¨ | `const int a; const auto& b = a;` | `const int&` |

---
#### ä¸ä¼šä¸¢å¼ƒ`const`çš„3ç§æƒ…å†µ

1. ä½¿ç”¨å¼•ç”¨æ—¶ï¼ˆä¿ç•™æ‰€æœ‰`const`ï¼‰
``` cpp
const int x = 10;
auto& r1 = x;        // ä¿ç•™const â†’ const int&

const int* p = &x;
auto& r2 = p;        // ä¿ç•™const â†’ const int*&
```

**ä¸ºä»€ä¹ˆä¿ç•™ï¼Ÿ**  
==å¼•ç”¨æ˜¯åŸå¯¹è±¡çš„åˆ«åï¼Œå¿…é¡»ä¿æŒåŸå¯¹è±¡çš„å¸¸é‡æ€§ã€‚==

2. åº•å±‚`const`æ—¶ï¼ˆä¿ç•™åº•å±‚`const`ï¼‰

``` cpp
const int* p1 = nullptr;    // åº•å±‚constï¼ˆæŒ‡å‘çš„å¯¹è±¡æ˜¯constï¼‰
auto p2 = p1;               // ç±»å‹: const int*ï¼ˆä¿ç•™åº•å±‚constï¼‰

int* const p3 = nullptr;    // é¡¶å±‚constï¼ˆæŒ‡é’ˆæœ¬èº«æ˜¯constï¼‰
auto p4 = p3;               // ç±»å‹: int*ï¼ˆä¸¢å¼ƒé¡¶å±‚constï¼‰
```

**å…³é”®åŒºåˆ«**ï¼š
- åº•å±‚`const`ï¼ˆæŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡æ˜¯constï¼‰â†’ ä¿ç•™
- é¡¶å±‚`const`ï¼ˆæŒ‡é’ˆæœ¬èº«æ˜¯constï¼‰â†’ ä¸¢å¼ƒ

ç‰¹æ®Šæ¡ˆä¾‹ï¼šæ•°ç»„å’Œå‡½æ•°

``` cpp
const char arr[] = "hello";
auto p = arr;         // ç±»å‹: const char*ï¼ˆä¿ç•™åº•å±‚constï¼‰

void func(const int);
auto f = func;        // ç±»å‹: void (*)(const int)ï¼ˆä¿ç•™å‚æ•°constï¼‰
```

3. æ˜¾å¼æ·»åŠ `const`æ—¶

``` cpp
const int a = 5;
const auto b = a;     // æ˜¾å¼æ·»åŠ const â†’ const int
```

---
### `auto` ä¼šæŠ›å¼ƒ `constexpr`

`auto`Â æœ¬èº«ä¸æºå¸¦Â `constexpr`Â å±æ€§ã€‚

- `auto`Â ä»…è´Ÿè´£**ç±»å‹æ¨å¯¼**ï¼ˆå¦‚Â `int`ã€`const int*`Â ç­‰ï¼‰ï¼Œä¸ä¼šè‡ªåŠ¨ä¸ºå˜é‡æ·»åŠ Â `constexpr`Â ä¿®é¥°ç¬¦ã€‚
- è‹¥è¦ä½¿å˜é‡æˆä¸ºÂ `constexpr`ï¼Œå¿…é¡»æ˜¾å¼å£°æ˜ä¸ºÂ `constexpr auto`ã€‚

```cpp
int main()
{
    constexpr double a { 3.4 };  // a has type const double (constexpr not part of type, const is implicit)

    auto b { a };                // b has type double (const dropped)
    const auto c { a };          // c has type const double (const dropped but reapplied)
    constexpr auto d { a };      // d has type const double (const dropped but implicitly reapplied by constexpr)

    return 0;
}
```

> [!warning]
> `constexpr`Â å¿…é¡»æ˜¾å¼å†™åœ¨å˜é‡å£°æ˜ä¸­ï¼Œä¸å¯ä¾èµ–Â `auto`Â è‡ªåŠ¨æ¨å¯¼ã€‚


BecauseÂ `constexpr`Â is not part of the type system, it cannot be deduced as part of type deduction. However, ==aÂ `constexpr`Â variable is implicitly const==. æ‰€ä»¥å­˜åœ¨ç‰¹æ®Šæƒ…å†µâ€”â€”å¼•ç”¨å’ŒæŒ‡é’ˆï¼Œä¼šä¿ç•™æœ‰constã€‚

``` c++
constexpr int x = 42;
auto& r = x;            // r çš„ç±»å‹æ˜¯ const int&ï¼Œä½† r æœ¬èº«ä¸æ˜¯ constexprï¼
constexpr auto& cr = x; // cr æ˜¯ constexpr å¼•ç”¨ï¼ˆç¼–è¯‘æœŸå¯ç”¨ï¼‰
```
- å³ä½¿å¼•ç”¨æŒ‡å‘Â `constexpr`Â å¯¹è±¡ï¼Œ`auto&`Â ä¹Ÿä¸ä¼šè‡ªåŠ¨æ¨å¯¼ä¸ºÂ `constexpr`Â å¼•ç”¨ã€‚

---
### `auto` æ¨å¯¼ä¸å‡º `string`

For historical reasons, string literals in C++ have a strange type. Therefore, the following probably wonâ€™t work as expected:

```cpp
auto s { "Hello, world" }; // s will be type const char*, not std::string
```

If you want the type deduced from a string literal to beÂ `std::string`Â orÂ `std::string_view`, youâ€™ll need to use theÂ `s`Â orÂ `sv`Â literal suffixes. 
ï¼ˆå‚è€ƒï¼š[[3.2 Const and Constexpr#Literal suffixes å­—é¢é‡åç¼€]]  & [[3.3 Strings & String_view]]ï¼‰

---
## å‡½æ•°çš„ç±»å‹æ¨å¯¼

in C++14, theÂ `auto`Â keyword was extended to do function return type deduction. 

When using anÂ `auto`Â return type, all return statements within the function must return values of the **same type**. ä¸‹é¢è¿™ç§æƒ…å†µç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š

```cpp
auto someFcn(bool b)
{
    if (b)
        return 5; // return type int
    else
        return 6.7; // return type double
}
```

---
### å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼çš„å¥½å¤„

è¿”å›ç±»å‹æ¨æ–­çš„æœ€å¤§ä¼˜ç‚¹æ˜¯è®©ç¼–è¯‘å™¨æ¨æ–­å‡½æ•°çš„è¿”å›ç±»å‹ï¼Œä»è€Œæ¶ˆé™¤è¿”å›ç±»å‹ä¸åŒ¹é…çš„é£é™©ã€‚

è¿™åœ¨å‡½æ•°çš„è¿”å›ç±»å‹è¾ƒä¸ºè„†å¼±æ—¶å°¤å…¶æœ‰ç”¨ï¼ˆå³å½“å®ç°ç»†èŠ‚å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè¿”å›ç±»å‹å¾ˆå¯èƒ½éšä¹‹æ”¹å˜çš„æƒ…å†µï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœæ˜¾å¼æŒ‡å®šè¿”å›ç±»å‹ï¼Œé‚£ä¹ˆå½“å®ç°å‘ç”Ÿå½±å“è¿”å›ç±»å‹çš„å˜æ›´æ—¶ï¼Œå°±å¿…é¡»æ‰‹åŠ¨æ›´æ–°æ‰€æœ‰ç›¸å…³çš„è¿”å›ç±»å‹å£°æ˜ã€‚

å¦‚æœè¿æ°”å¥½ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œæé†’æˆ‘ä»¬å»æ›´æ–°ç›¸å…³çš„è¿”å›ç±»å‹ï¼Œä»è€Œé¿å…æ½œåœ¨çš„é—®é¢˜ï¼›  

å¦‚æœè¿æ°”ä¸å¥½ï¼Œåˆ™å¯èƒ½å‡ºç°éšå¼ç±»å‹è½¬æ¢ï¼Œå¯¼è‡´ç¨‹åºè¡Œä¸ºå¼‚å¸¸æˆ–éš¾ä»¥å¯Ÿè§‰çš„é”™è¯¯ã€‚

Â In such cases,Â `auto`Â can be used to simplify:

```cpp
// let compiler determine the return type of unsigned short + char
auto add(unsigned short x, char y)
{
    return x + y;
}
```

---
### å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼çš„åå¤„

ä½¿ç”¨è‡ªåŠ¨è¿”å›ç±»å‹çš„å‡½æ•°å¿…é¡»å…ˆå®Œå…¨å®šä¹‰æ‰èƒ½ä½¿ç”¨ï¼ˆå‰å‘å£°æ˜æ˜¯ä¸å¤Ÿçš„ï¼‰ã€‚å¾ˆåˆç†ï¼Œå› ä¸ºåªæœ‰å‰å‘å£°æ˜ï¼Œç¼–è¯‘å™¨æ²¡æœ‰ä»»ä½•å‡½æ•°ä¿¡æ¯ã€‚

```cpp
#include <iostream>

auto foo();

int main()
{
    std::cout << foo() << '\n'; // the compiler has only seen a forward declaration at this point

    return 0;
}

auto foo()
{
    return 5;
}
```

On the authorâ€™s machine, this gives the following compile error:
```
error C3779: 'foo': a function that returns 'auto' cannot be used before it is defined.
```

---
### å°¾ç½®è¿”å›ç±»å‹

`auto` å…³é”®å­—å¯ä»¥é…åˆå°¾ç½®è¿”å›ç±»å‹ï¼ˆtrailing return typeï¼‰è¯­æ³•æ¥å£°æ˜å‡½æ•°ï¼Œè¿™ç§å†™æ³•å°†è¿”å›ç±»å‹æ”¾åœ¨å‡½æ•°å‚æ•°åˆ—è¡¨ä¹‹åï¼Œç”¨ `->` æŒ‡å®šã€‚å…¶è¯­æ³•å½¢å¼å¦‚ä¸‹ï¼š

``` C++
auto functionName(parameterList) -> returnType {
	// å‡½æ•°ä½“
}
```

Consider the following function:

```cpp
int add(int x, int y)
{
  return (x + y);
}
```

Using the trailing return syntax, this could be equivalently written as:

```cpp
auto add(int x, int y) -> int
{
  return (x + y);
}
```

In this case,Â `auto`Â does not perform type deduction -- it is just part of the syntax to use a trailing return type.

ä¸ºä»€ä¹ˆè¿™ä¹ˆå†™ï¼Ÿ

1. è§£å†³è¿”å›ç±»å‹ä¾èµ–å‚æ•°ç±»å‹çš„é—®é¢˜

å½“å‡½æ•°çš„è¿”å›ç±»å‹ä¾èµ–äºå‚æ•°ç±»å‹æ—¶ï¼Œä¼ ç»Ÿçš„å†™æ³•æ— æ³•ç›´æ¥ä½¿ç”¨å‚æ•°ç±»å‹æ¨æ–­è¿”å›ç±»å‹ï¼Œå› ä¸ºè¿”å›ç±»å‹å¿…é¡»å†™åœ¨å‚æ•°åˆ—è¡¨ä¹‹å‰ï¼Œå‚æ•°ç±»å‹è¿˜æœªå£°æ˜ã€‚

å°¾ç½®è¿”å›ç±»å‹å…è®¸å…ˆå†™å‚æ•°åˆ—è¡¨ï¼Œå†å†™è¿”å›ç±»å‹ï¼Œä»è€Œå¯ä»¥ä½¿ç”¨å‚æ•°ç±»å‹è¿›è¡Œè¿”å›ç±»å‹æ¨æ–­ã€‚

```cpp
#include <type_traits>
// note: decltype(x) evaluates to the type of x

std::common_type_t<decltype(x), decltype(y)> add(int x, double y);         // Compile error: compiler hasn't seen definitions of x and y yet
auto add(int x, double y) -> std::common_type_t<decltype(x), decltype(y)>; // ok
```

2. C++ çš„ä¸€äº›é«˜çº§ç‰¹æ€§ä¹Ÿéœ€è¦å°¾éšè¿”å›è¯­æ³•ï¼Œä¾‹å¦‚ lambdaã€‚[[lambdas åŒ¿åå‡½æ•°]]

3. ä½¿ä»£ç æ›´æ˜“è¯»ã€‚

```cpp
#include <type_traits> // for std::common_type

std::common_type_t<int, double> compare(int, double);         // harder to read (where is the name of the function in this mess?)
auto compare(int, double) -> std::common_type_t<int, double>; // easier to read (we don't have to read the return type unless we care)
```

```cpp
auto add(int x, int y) -> int;
auto divide(double x, double y) -> double;
auto printSomething() -> void;
auto generateSubstring(const std::string &s, int start, int len) -> std::string;
```

---
### å‡½æ•°å‚æ•°ç±»å‹ä¸èƒ½æ˜¯ `auto`

```cpp
#include <iostream>

void addAndPrint(auto x, auto y)
{
    std::cout << x + y << '\n';
}

int main()
{
    addAndPrint(2, 3); // case 1: call addAndPrint with int parameters
    addAndPrint(4.5, 6.7); // case 2: call addAndPrint with double parameters

    return 0;
}
```

ä¸Šé¢è¿™æ ·çš„å†™æ³•ï¼Œåœ¨ C++20 ä¹‹å‰ä¼šç›´æ¥æŠ¥ç¼–è¯‘é”™è¯¯ã€‚

åœ¨ C++20ï¼Œä¼šæ­£å¸¸ç¼–è¯‘ã€‚ä½†Â `auto`Â å…³é”®å­—çš„ä½œç”¨å¹¶ä¸ä»…ä»…æ˜¯ç±»å‹æ¨å¯¼ï¼Œè€Œæ˜¯è§¦å‘äº† function templates å‡½æ•°æ¨¡æ¿ã€‚åœ¨ [[5.4 Function templates å‡½æ•°æ¨¡æ¿]] ä¸­æœ‰æ›´è¯¦ç»†çš„ä»‹ç»ã€‚

---
## æŒ‡é’ˆ / å¼•ç”¨ / const çš„ç±»å‹æ¨æ–­

### ç±»å‹æ¨æ–­åˆ é™¤å¼•ç”¨

```cpp
#include <string>

std::string& getRef(); // some function that returns a reference

int main()
{
    auto ref { getRef() }; // type deduced as std::string (not std::string&)

    return 0;
}
```

---
### é¡¶å±‚const å’Œ åº•å±‚const

AÂ **top-level const**Â is a const qualifier that applies to an object itself. For example:

```cpp
const int x;    // this const applies to x, so it is top-level
int* const ptr; // this const applies to ptr, so it is top-level
// references don't have a top-level const syntax, as they are implicitly top-level const
```

In contrast, aÂ **low-level const**Â is a const qualifier that applies to the object being referenced or pointed to:

```cpp
const int& ref; // this const applies to the object being referenced, so it is low-level
const int* ptr; // this const applies to the object being pointed to, so it is low-level
```

### ç±»å‹æ¨å¯¼ä¸ä¼šä¸¢å¼ƒæŒ‡é’ˆ

```cpp
#include <string>

std::string* getPtr(); // some function that returns a pointer

int main()
{
    auto ptr1{ getPtr() }; // std::string*

    return 0;
}
```

We can also use an asterisk in conjunction with pointer type deduction (`auto*`) to make it clearer that the deduced type is a pointer:

```cpp
#include <string>

std::string* getPtr(); // some function that returns a pointer

int main()
{
    auto ptr1{ getPtr() };  // std::string*
    auto* ptr2{ getPtr() }; // std::string*

    return 0;
}
```

è¿™é‡Œè¦æ³¨æ„ä¸€ä¸‹çš„æ˜¯ï¼Œ`auto`Â å’ŒÂ `auto*`Â è¿˜æ˜¯æœ‰ä¸€ç‚¹åŒºåˆ«çš„ã€‚ `auto*`Â must resolve to a pointer initializer, otherwise a compile error will result:

```cpp
#include <string>

std::string* getPtr(); // some function that returns a pointer

int main()
{
    auto ptr3{ *getPtr() };  // auto æ¨å¯¼å‡º std::string (because we dereferenced getPtr())
    auto* ptr4{ *getPtr() }; // does not compile (initializer not a pointer)
	
    return 0;
}
```

é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆ references are dropped during type deduction but pointers are not droppedï¼Ÿ

å½“æˆ‘ä»¬å¤„ç†å¼•ç”¨æ—¶ï¼Œå®é™…ä¸Šå¤„ç†çš„æ˜¯è¢«å¼•ç”¨çš„å¯¹è±¡ã€‚å› æ­¤ï¼Œåœ¨ç±»å‹æ¨å¯¼æ—¶ï¼Œæ¨å¯¼å‡ºè¢«å¼•ç”¨å¯¹è±¡çš„ç±»å‹ï¼ˆè€Œä¸æ˜¯å¼•ç”¨æœ¬èº«ï¼‰æ˜¯åˆç†çš„ã€‚æ­¤å¤–ï¼Œç”±äºæ¨å¯¼å‡ºçš„æ˜¯éå¼•ç”¨ç±»å‹ï¼Œä½¿ç”¨auto&å¯ä»¥è½»æ¾æ·»åŠ å¼•ç”¨ã€‚å¦‚æœç±»å‹æ¨å¯¼è¦æ¨å¯¼å‡ºå¼•ç”¨ï¼Œå½“ä¸éœ€è¦å¼•ç”¨æ—¶å»é™¤å¼•ç”¨çš„è¯­æ³•ä¼šæ›´åŠ å¤æ‚ã€‚

è€ŒæŒ‡é’ˆä¿å­˜çš„æ˜¯å¯¹è±¡çš„åœ°å€ã€‚å½“æˆ‘ä»¬å¤„ç†æŒ‡é’ˆæ—¶ï¼Œå¤„ç†çš„æ˜¯æŒ‡é’ˆæœ¬èº«ã€‚å› æ­¤ï¼Œæ¨å¯¼å‡ºæŒ‡é’ˆæœ¬èº«çš„ç±»å‹ï¼ˆè€Œä¸æ˜¯è¢«æŒ‡å‘å¯¹è±¡çš„ç±»å‹ï¼‰æ˜¯åˆç†çš„ã€‚å¦‚æœæƒ³è¦å¤„ç†è¢«æŒ‡å‘çš„å¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡è§£å¼•ç”¨å®ç°ã€‚

---
