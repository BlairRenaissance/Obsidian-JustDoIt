
当有且只有一个操作数为负数时，数学上的“模”产生的结果与 C++ 中的运算符 % 产生的结果不同。
- -21 modulo 4 = 3  
- -21 %(remainder) 4 = -1

| Operator                           | Symbol | Form | Operation                                      |
| ---------------------------------- | ------ | ---- | ---------------------------------------------- |
| Prefix increment (pre-increment)   | ++     | ++x  | Increment x, then return x                     |
| Prefix decrement (pre-decrement)   | ––     | ––x  | Decrement x, then return x                     |
| Postfix increment (post-increment) | ++     | x++  | Copy x, then increment x, then return the copy |
| Postfix decrement (post-decrement) | ––     | x––  | Copy x, then decrement x, then return the copy |

> [!Best practice]
> Favor the prefix versions, as they are more performant and less likely to cause surprises.

---

条件表达式

条件表达式的第二第三个参数需要类型匹配，或者能够转换。

``` C++
#include <iostream>

int main()
{
    std::cout << (true ? 1 : 2) << '\n';    
    // okay: both operands have matching type int
    
    std::cout << (false ? 1 : 2.2) << '\n'; 
    // okay: int value 1 converted to double
    
    std::cout << (true ? -1 : 2u) << '\n';  
    // surprising result: -1 converted to unsigned int, result out of range
    
    return 0;
}
```

---

Q：表达式 `x = 5` 是返回什么？

Both `operator=` and `operator<<` (when used to output values to the console) return **their left operand**. Thus, `x = 5` returns `x`, and `std::cout << 5` returns `std::cout`. This is done so that these operators can be chained.

For example, `x = y = 5` evaluates as `x = (y = 5)`. First `y = 5` assigns `5` to `y`. This operation then returns `y`, which can then be assigned to `x`.

`std::cout << "Hello " << "world!"` evaluates as `(std::cout << "Hello ") << "world!"`. This first prints `"Hello "` to the console. This operation returns `std::cout`, which can then be used to print `"world!"` to the console as well.

```Cpp
int x { 2 };
std::cout << (x = 5) << '\n'; // output 5
```
