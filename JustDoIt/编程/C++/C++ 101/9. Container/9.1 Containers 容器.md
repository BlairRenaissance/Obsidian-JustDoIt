
容器用于存储一组未命名的对象（称为元素）。

数组在内存中**连续**分配元素，并允许通过下标快速直接地访问任何元素。 

C++ 有三种常用的数组类型：std::vector、std::array 和 C 风格数组。 

数组分为两类：
1. 固定大小数组（也称为定长数组）。要求在实例化时已知数组的长度，并且之后不能更改该长度。C 风格数组和 std::array 都是固定大小数组。 
2. 动态数组。可以在运行时调整大小。std::vector 就是一个动态数组。

Let’s goooooooooooooooooooooooooooooooooooooooooooooooo.

---
## `std::vector`

### 初始化

```cpp
// Copy init
std::vector<int> v1 = 10;     // 10 not an initializer list, copy init won't match explicit constructor: compilation error

// Direct init
std::vector<int> v2(10);      // 10 not an initializer list, matches explicit single-argument constructor

// List init
std::vector<int> v3{ 10 };    // { 10 } interpreted as initializer list, matches list constructor

// Copy list init
std::vector<int> v4 = { 10 }; // { 10 } interpreted as initializer list, matches list constructor
std::vector<int> v5({ 10 });  // { 10 } interpreted as initializer list, matches list constructor

        // Default init
        std::vector<int> v6 {};       // {} is empty initializer list, matches default constructor
        std::vector<int> v7 = {};     // {} is empty initializer list, matches default constructor
```

```
v2: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

v3: [10]

v4: [10]

v5: [10]

v6: []

v7: []
```

当 `std::vector` 作为类类型的成员时，**不允许使用直接（括号）初始化**。
- 必须使用 copy initialization 或 list initialization。
- **不允许使用类模板实参推导（CTAD）**，因此必须显式指定元素类型。

```cpp
struct Foo
{
    std::vector<int> v1(8); // 编译错误：成员默认初始化器不允许直接（括号）初始化
    std::vector<int> v{ std::vector<int>(8) }; // 正确
};
```

---
### const 和 constexpr 的 std::vector

`std::vector` 类型的对象可以被声明为 `const`：

```cpp
#include <vector>

int main() {
	const std::vector<int> prime { 2, 3, 5, 7, 11 }; // prime 及其元素都不能被修改
	return 0; 
}
```

一个 `const std::vector` 必须在初始化时赋值，之后就不能再被修改。这样的 vector 的元素也会被视为 const。

**注意：**`std::vector` 的元素类型不能被定义为 const（例如 `std::vector<const int>` 是不允许的）。

`std::vector` 最大的缺点之一是它**不能被声明为 constexpr**。如果需要一个 constexpr 数组，请使用 `std::array`。

---
### 操作语句

|Function Name|Stack Operation|Behavior|Notes|
|---|---|---|---|
|push_back()|Push|Put new element on top of stack|Adds the element to end of vector|
|pop_back()|Pop|Remove the top element from the stack|Returns void, removes element at end of vector|
|back()|Top or Peek|Get the top element on the stack|Does not remove item|
|emplace_back()|Push|Alternate form of push_back() that can be more efficient (see below)|Adds element to end of vector|

**`resize()`** 成员函数会更改向量的长度和容量。 通过索引访问向量时，使用 `resize()`。这会改变向量的长度，从而使索引有效。 

**`reserve()`** 成员函数只会更改容量。通过堆栈操作访问向量时，请使用 `reserve()`。这会增加容量，而不会改变向量的长度。

**`emplace_back()`**：适合“就地构造新对象”或“需要 explicit 构造函数”时用。

**`push_back()`**：适合“已有对象”时用，语义更清晰。

```cpp
#include <iostream>
#include <string>
#include <string_view>
#include <vector>
  
class Foo
{
private:
    std::string m_a{}; 
    int m_b{}; 

public:
    // 构造函数，接收 string_view 和 int
    Foo(std::string_view a, int b)
        : m_a { a }, m_b { b }
        {}

    // 显式构造函数，只接收 int
    explicit Foo(int b)
        : m_a {}, m_b { b }
        {};
};

int main()
{
    std::vector<Foo> stack{};
    
    // 当我们已经有一个对象时，push_back 和 emplace_back 效率差不多
    Foo f{ "a", 2 };
    stack.push_back(f);    // 推荐用法：将已有对象 f 拷贝进 vector
    stack.emplace_back(f); // 也可以，但和 push_back 效果一样

    // 当我们需要临时创建对象时，emplace_back 更高效
    stack.push_back({ "a", 2 }); // 先创建一个临时对象，再拷贝进 vector（有一次拷贝）
    stack.emplace_back("a", 2);  // 直接在 vector 内部构造对象（无拷贝，更高效）

  
    // push_back 不能使用 explicit 构造函数，但 emplace_back 可以
    stack.push_back({ 2 }); // 编译错误：Foo(int) 是 explicit，不能隐式转换
    stack.emplace_back(2);  // 正确：emplace_back 可以直接调用 explicit 构造函数

    return 0;
}
```

---
## `std::array`

> [!Tip]
> Use `std::array` for constexpr arrays, and `std::vector` for non-constexpr arrays.

### 为什么不总是用std::vector？

 `std::vector` 很强大、灵活、易用，是大多数情况下的首选。但它也有一些限制：

1. **性能略低于定长数组**：因为它需要管理内存分配和可能的扩容，虽然大多数情况下差别很小。

2. **对 `constexpr` 的支持有限**：`std::vector` 只能在很有限的场景下用作 `constexpr`，而定长数组（特别是 `std::array`）可以更好地支持 `constexpr`，让代码在编译期就能确定和优化。

如果需要编译期常量数组（`constexpr`），或者数组长度在编译时已知且不会变，优先用 `std::array`。这样代码更健壮，编译器还能做更多优化。

---
### 定义

```cpp
#include <array>  // for std::array
#include <vector> // for std::vector

int main()
{
    std::array<int, 5> a {};  // a std::array of 5 ints

    std::vector<int> b(5);    // a std::vector of 5 ints (for comparison)

    return 0;
}
```

`std::array` 的声明有**两个模板参数**：
1. 第一个参数（`int`）：元素的类型。
2. 第二个参数（`5`）：数组的长度（必须是编译期常量）。

> [!Warning]
> std::array 的长度必须是常量表达式（constant expression）。

---
### 初始化

或许令人惊讶，std::array 是一个聚合类型（aggregate）。这意味着它没有构造函数，而是使用聚合初始化来初始化。

```cpp
#include <array>

int main()
{
	// copy-list initialization using braced list
    std::array<int, 6> fibonnaci = { 0, 1, 1, 2, 3, 5 };
     
    // list initialization using braced list (preferred)
    std::array<int, 5> prime { 2, 3, 5, 7, 11 };

    return 0;
}
```

如果定义 `std::array` 时没有指定初始化器，元素会被**默认初始化**。在大多数情况下，这意味着元素会**保持未初始化状态**。

由于我们通常希望元素被初始化，当没有指定初始化器时，应该使用空花括号对 `std::array` 进行值初始化。

```cpp
#include <array>
#include <vector>

int main()
{
    std::array<int, 5> a;   // 聚合类型默认初始化，元素保持未初始化
    std::array<int, 5> b{}; // 聚合类型值初始化，元素被初始化为0（推荐做法）
    
    std::vector<int> v(5);  // 值初始化，元素被初始化为0（用于对比）
    
    return 0;
}
```

如果在初始化列表中提供的初始值**多于数组长度**，编译器会报错。如果提供的初始值**少于数组长度**，则剩余未初始化的元素会被**值初始化**：

``` cpp
#include <array>
int main()
{
    std::array<int, 4> a { 1, 2, 3, 4, 5 }; // 编译错误：初始值过多
    std::array<int, 4> b { 1, 2 };          // b[2]和b[3]会被值初始化为0
    return 0;
}
```

---
### Const 和 constexpr 的 std::array

std::array 可以被声明为 const：

``` cpp
#include <array>
int main()
{
    const std::array<int, 5> prime { 2, 3, 5, 7, 11 };
    return 0;
}
```

即使 const std::array 的元素没有被显式地标记为 const，它们依然会被当作常量处理（因为整个数组是 const 的）。

std::array 也**完全支持 constexpr**：

``` cpp
#include <array>
int main()
{
    constexpr std::array<int, 5> prime { 2, 3, 5, 7, 11 };
    return 0;
}
```

对 constexpr 的支持是使用 std::array 的关键原因。

> [!Best practice]
> 只要有可能，就将 `std::array` 定义为 `constexpr`。
> 如果你的 `std::array` 不能是 `constexpr`，可以考虑使用 `std::vector` 代替。

---
### `std::array`的类模板参数推导 CTAD (C++17)

Class template argument deduction (CTAD) : 类模板参数推导。

使用 C++17 中的 CTAD（类模板参数推导），我们可以让编译器从初始化列表中推断出 std::array 的元素类型和数组长度：
```cpp
#include <array>
#include <iostream>

int main()
{
    constexpr std::array a1 { 9, 7, 5, 3, 1 }; 
    // The type is deduced to std::array<int, 5>
    
    constexpr std::array a2 { 9.7, 7.31 };     
    // The type is deduced to std::array<double, 2>

    return 0;
}
```

只要切实可行，我们都推荐使用这种语法。如果编译器不支持 C++17，则需要显式提供类型和长度模板参数。

⚠️注意：CTAD 不支持部分省略模板参数。

```cpp
#include <iostream>

int main()
{
    constexpr std::array<int> a2 { 9, 7, 5, 3, 1 };     
    // error: too few template arguments (length missing)
    
    constexpr std::array<5> a2 { 9, 7, 5, 3, 1 };       
    // error: too few template arguments (type missing)
	
    return 0;
}
```

---
### 操作语句

Just like a `std::vector`, the most common way to access elements of a `std::array` is by using the subscript operator (`operator[]`):

```cpp
#include <array> // for std::array
#include <iostream>

int main()
{
    constexpr std::array<int, 5> prime{ 2, 3, 5, 7, 11 };

    std::cout << prime[3]; // print the value of element with index 3 (7)
    std::cout << prime[9]; // invalid index (undefined behavior)

    return 0;
}
```

As a reminder, `operator[]` does not do bounds checking.

与 `std::string` 和 `std::string_view` 同时拥有 `length()` 和 `size()` 成员函数（而且这两个函数的作用是一样的）不同，`std::array`（以及 C++ 中大多数其他容器类型）**只有 `size()` 成员函数**。

---
### 传递与返回 `std::array`

std::array 类型的对象可以像任何其他对象一样传递给函数。这意味着，如果我们按值传递 std::array，将会进行一次代价高昂的复制。因此，我们通常通过 (const) 引用传递 std::array，以避免此类复制。 

对于 std::array，元素类型和数组长度都是对象类型信息的一部分。因此，当我们使用 std::array 作为函数参数时，必须显式指定元素类型和数组长度：

```cpp
#include <array>
#include <iostream>

void passByRef(const std::array<int, 5>& arr) // ！！！必须有 <int, 5> 
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::array arr{ 9, 7, 5, 3, 1 }; // CTAD deduces type std::array<int, 5>
    passByRef(arr);

    return 0;
}
```

如果我们有一个需要返回 std::array 的函数呢？情况会稍微复杂一些。与 std::vector 不同，**std::array 不具备移动能力**，因此按值返回 std::array 会复制该数组。如果数组中的元素具备移动能力，则将被移动；否则，将被复制。

std::vector 具有移动功能，可以按值返回而无需进行昂贵的复制。如果要按值返回 std::array，则说明 std::array 可能不是 constexpr，这时应该考虑使用并返回 std::vector。

---
## C-style array 

> [!Tip] 
> 当你需要**最基础、最轻量**的数组，或者与 C 代码/库交互时，可以使用 C 风格数组。但在 C++ 代码中，优先考虑 `std::array` 或 `std::vector`，除非有特殊需求。

### 定义

``` cpp
int arr[5];        // 定义一个长度为5的int数组，元素未初始化 
int arr2[5] = {};  // C++11起，所有元素初始化为0 
int arr3[5] = {1, 2, 3}; // 前3个元素初始化，后2个为0
```

- **类型**：`int` 是元素类型。
- **长度**：`5` 必须是编译期常量表达式。

---
### 初始化

``` cpp
int a[4] = {1, 2, 3, 4};   // 完全初始化 
int b[4] = {1, 2};         // b[2]和b[3]自动初始化为0 
int c[] = {1, 2, 3, 4, 5}; // 编译器自动推断长度为5 
int d[5] = {};             // 全部初始化为0（C++11起）
```

> [!Warning] 
> 如果初始化器中的元素**多于数组长度**，会编译错误；少于数组长度，剩余元素会被初始化为0（仅限静态/全局变量或C++11起的局部变量）。

---
### 注意事项
#### **数组名的退化（decay）**

- **数组名在大多数表达式中会自动退化为指向首元素的指针**，但有两个例外：
    - `sizeof(arr)`：得到整个数组的字节数。
    - `&arr`：得到整个数组的指针，类型为 `int (*)[N]`。
- 其他情况下，`arr` 变成 `int*`，丢失长度信息。

``` cpp
int arr[10]; 
int* p = arr;      // OK, arr退化为int* 
int* p2 = &arr[0]; // OK 
int (*p3)[10] = &arr; // OK, p3是指向整个数组的指针
```

---
#### 作为函数参数

数组作为函数参数时的陷阱：
- 传递数组时，**数组会退化为指针**，长度信息丢失。
- `sizeof(arr)` 在函数参数中得到的是指针大小，不是数组大小。

``` cpp
void foo(int arr[10])
{
	// sizeof(arr) == 4 或 8（取决于指针大小），不是 40 
}
```

**解决方法**：总是显式传递长度参数：
``` cpp
void foo(int arr[5]); // 实际等价于 void foo(int* arr); 
void bar(int arr[], int len); // 需要额外传递长度
```

- 传递数组时，**数组会退化为指针**，长度信息丢失。
- 推荐总是**显式传递长度**。

---
#### 获取数组长度

``` cpp
int arr[5]; 
size_t len = sizeof(arr) / sizeof(arr[0]); // 结果为5
```

- 只在**数组作用域内**有效。如果数组作为参数传递给函数，会退化为指针，无法再用 `sizeof` 得到长度。

---
#### 不能整体赋值、比较或返回

``` cpp
int a[3] = {1,2,3}; 
int b[3]; 
// b = a; // 错误，不能整体赋值  

// if (a == b) // 错误

int* func() {
	static int arr[3] = {1,2,3};     
	return arr; // 只能返回指针，不能返回数组本身 
}
```
---
#### **多维数组的声明与访问**

- 多维数组在内存中是**连续存储**的（行主序）。
- 传递多维数组给函数时，**除第一个维度外，其他维度必须指定**。

``` cpp
void func(int arr[][5], int rows); // OK 
void func(int arr[][], int rows, int cols); // 错误
```

**因为编译器需要知道每一行有多少元素，才能正确地进行指针运算。**

``` cpp
void foo(int arr[][4], int rows) {
	// 访问 arr[i][j] 时，编译器会把它翻译成 *(arr + i * 4 + j) 
	// 或者 *( *(arr + i) + j ) 
}
```

如果你只写 `int arr[][]`，编译器就**不知道每一行有多少个元素**，无法计算 `arr[i][j]` 在内存中的偏移量。

---
#### **数组长度必须是编译期常量**

- C++ 不支持变长数组（VLA），`int n = 5; int arr[n];` 是非法的（GCC 扩展除外）。
- 长度必须是常量表达式。

---
#### 数组指针与指针数组的区别

- `int* arr[10];` 是**指针数组**，有10个`int*`。
- `int (*arr)[10];` 是**数组指针**，指向10个`int`的数组。

---
#### **与 `memset`/`memcpy` 的配合**

- 可以用 `memset(arr, 0, sizeof(arr));` 初始化为0。
- 但**不适用于非POD类型**（如`std::string`、自定义类）。
- 结构体中的数组成员不能整体赋值或比较，但可以用 `memcpy` 复制（仅限POD类型）。

---
#### 数组与 `std::begin`/`std::end`

 C++11 起，可以用 `std::begin(arr)` 和 `std::end(arr)` 获取指针范围，适合与 STL 算法配合。

``` cpp
#include <algorithm> 

int arr[5] = {1,2,3,4,5}; 
std::sort(std::begin(arr), std::end(arr));
```

---
### 与 C++ 容器的对比

- **C 风格数组**：极致轻量，性能极高，但易错、功能有限。
- **std::array**：定长、类型安全、支持 STL 接口，推荐用于编译期已知长度的数组。
- **std::vector**：变长、动态分配，推荐用于长度运行时可变的数组。

> [!Best practice] 
> 除非有特殊需求（如与 C 代码交互、极致性能），否则优先使用 `std::array` 或 `std::vector`。

---