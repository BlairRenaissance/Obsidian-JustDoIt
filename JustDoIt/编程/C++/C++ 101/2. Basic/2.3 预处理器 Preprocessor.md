## 预处理阶段 preprocessing phase

在项目编译过程中，开发者可能以为编译器会直接按照源码文件原样进行编译。实际上，在正式编译之前，==每个.cpp源代码文件都会经历预处理阶段==。

这个阶段的核心处理流程如下：专门的预处理器程序会对源代码文本进行多重转换，典型操作包括：宏展开、头文件包含、条件编译等。

预处理器不会修改原始源代码文件，所有转换操作通过两种方式实现：
- 内存中的临时处理（主流现代编译器方案）
- 生成临时中间文件（传统处理方式）

> [!info]
> 在计算机发展史上，预处理器最初是独立于编译器的单独程序。但随着技术演进，现代编译器通常已将预处理器直接集成到编译器内部。

预处理器所做的大部分工作都相当无趣。例如，它会删除注释，并确保每个代码文件都以换行符结尾。但是，预处理器确实有一个非常重要的作用：处理预处理指令。

==When the preprocessor has finished processing a code file, the result is called a **translation unit 编译单元**.== This translation unit is what is then compiled by the compiler.

> [!Abstract]
> 在C/C++开发领域，预处理、编译和链接这三个阶段的完整流程被统称为翻译过程。
> The entire process of preprocessing, compiling, and linking is called translation.

---
## 预处理指令 Preprocessor directives

When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives. **Preprocessor directives** (often just called _directives_) are instructions that start with a _#_ symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks.

---

**`#Include`**

当 `#include` 一个文件时，预处理器会用对应名称的文件内容替换 `#include` 指令。然后，被包含的内容会继续被预处理（这可能会导致 `#include` 指令被递归预处理）。

---

**`#define`**

`#define` 指令可用于创建宏。宏的名字应全部大写，单词之间用下划线分隔。

There are two basic types of macros: _object-like macros_, and _function-like macros_.

Object-like macros with substitution text were used (in C) as a way to assign names to literals. 像这样：`#define MY_NAME "Alex"`。但这种方式现在应该尽量避免！！更好的方式可以参考：[[4.6 跨多个文件共享全局常量]]。

> [!Tip]
> `#define` 指令仅在定义它的文件中生效。

function.cpp:
``` C++
#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!\n";
#endif
#ifndef PRINT
    std::cout << "Not printing!\n";
#endif
}
```

main.cpp:
``` C++
void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();

    return 0;
}
```

The above program will print:
```
Not printing!
```