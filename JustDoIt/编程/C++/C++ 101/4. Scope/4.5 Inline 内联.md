## Inline Function

历史上，编译器要么无法判断内联扩展是否有益，要么并不擅长于此。因此，C++ 提供了关键字 inline，其最初的目的是为了提示编译器，某个函数（可能）会从内联扩展中受益。 使用 inline 关键字声明的函数称为内联函数。

然而，在现代 C++ 中，`inline` 关键字已经不再用于请求函数内联展开，原因有以下几点：
1. 使用 `inline` 来请求内联展开是一种过早优化（premature optimization），滥用反而可能损害性能。
2. `inline` 关键字只是给编译器的一个提示，帮助它决定是否进行内联展开。编译器完全可以忽略这个请求，而且通常会这么做。同时，编译器也可以在没有使用 `inline` 关键字的函数上执行内联展开，作为其常规优化的一部分。
3. `inline` 关键字的粒度不合适。它是作用于函数定义上的，但内联展开实际上是针对每一次函数调用来决定的。有些调用内联展开是有益的，有些则可能有害，而语法上并没有办法针对不同调用进行区分和控制。
4. 现代的优化型编译器通常非常擅长判断哪些函数调用应该内联展开——在大多数情况下比人类判断更准确。因此，编译器很可能会忽略或降低 `inline` 关键字请求内联展开的作用。

> [!Best practice]
> 不要使用 `inline` 关键字来请求函数内联展开。

---

==现代 C++ 中，`inline` 更多是用于解决多重定义==（如头文件中函数**定义**而非仅声明会产生的链接问题），而非性能优化的手段，性能优化应交由编译器自动完成。

在前面的章节中，我们提到不应该在头文件中实现具有外部链接（external linkage）的函数，因为当这些头文件被包含到多个 `.cpp` 文件中时，函数定义会被复制到多个 `.cpp` 文件中。随后这些文件会被编译，链接器会报错，指出你定义了多个相同的函数，这违反了一定义规则（One-Definition Rule，简称 ODR）。

在现代 C++ 中，`inline` 这个术语的含义已经演变为“允许多重定义”。因此，`inline` 函数是指允许在多个翻译单元（translation units）中定义的函数（且不违反 ODR）。

`inline` 函数有两个主要要求：
1. 编译器需要在每个使用该函数的翻译单元中看到该 `inline` 函数的完整定义（仅有前置声明是不够的）。每个翻译单元中只能有一个这样的定义，否则会导致编译错误。
2. 如果提供了前置声明，函数定义可以出现在使用点之后。但编译器通常在看到函数定义之前，无法进行内联展开，因此在声明和定义之间的使用通常不会被内联展开。
3. 对于具有外部链接的 `inline` 函数（默认情况下函数具有外部链接），每个定义必须完全相同，否则会导致未定义行为。

以下函数是隐式内联（implicitly inline）的：
- 在类、结构体或联合体的定义体内直接实现的成员函数。
- `constexpr` 或 `consteval` 函数。
- 从函数模板隐式实例化出来的函数。

总结来说，==现代 C++ 中 `inline` 函数的核心作用是允许函数在多个翻译单元中重复定义而不违反 ODR==，从而方便将函数定义放在头文件中，同时编译器仍然可以选择是否进行内联展开优化。

---
## Inline Valuable (C++17)

C++17 引入了 **inline 变量**，即允许在多个文件中定义的变量。inline 变量的工作方式类似于 inline 函数，并且具有相同的要求：编译器必须能够在变量被使用的每个地方看到完全相同的定义。
