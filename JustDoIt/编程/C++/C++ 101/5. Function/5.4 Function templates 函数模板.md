
åœ¨ C++ ä¸­ï¼Œæ¨¡æ¿ç³»ç»Ÿçš„è®¾è®¡ç›®çš„æ˜¯ç®€åŒ–åˆ›å»ºèƒ½å¤Ÿå¤„ç†ä¸åŒæ•°æ®ç±»å‹çš„å‡½æ•°ï¼ˆæˆ–ç±»ï¼‰çš„è¿‡ç¨‹ã€‚

ç¼–è¯‘å™¨å¯ä»¥ç”¨ä¸€ä¸ªæ¨¡æ¿ç”Ÿæˆä¸€ç³»åˆ—ç›¸å…³çš„å‡½æ•°æˆ–ç±»ã€‚

ç»è¿‡ç¼–è¯‘å™¨ç¼–è¯‘ï¼Œç¼–è¯‘å™¨å°†æœ‰æ•ˆåœ°ç¼–è¯‘å¹¶æ‰§è¡Œæ­¤ä»£ç ï¼š

```cpp
#include <iostream>

template <typename T>
T addOne(T x);

template<>
int addOne<int>(int x)
{
    return x + 1; // å‡½æ•°å®ä¾‹é•¿è¿™æ ·
}

template<>
double addOne<double>(double x)
{
    return x + 1;
}

int main()
{
    std::cout << addOne(1) << '\n';   // calls addOne<int>(int)
    std::cout << addOne(2.3) << '\n'; // calls addOne<double>(double)

    return 0;
}
```

---
## Using a function template

å®šä¹‰è¯­æ³•ï¼š
```cpp
template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}
```

è°ƒç”¨è¯­æ³•ï¼š
```cpp
int main()
{
    std::cout << max<int>(1, 2) << '\n'; // instantiates and calls function max<int>(int, int)

    return 0;
}
```

ä»å‡½æ•°æ¨¡æ¿ï¼ˆå¸¦æœ‰æ¨¡æ¿ç±»å‹ï¼‰åˆ›å»ºå…·æœ‰å…·ä½“ç±»å‹çš„å‡½æ•°çš„è¿‡ç¨‹ï¼Œç§°ä¸º**å‡½æ•°æ¨¡æ¿å®ä¾‹åŒ–**ï¼ˆfunction template instantiationï¼Œç®€ç§°å®ä¾‹åŒ–ï¼‰ã€‚å½“å‡½æ•°å› å‡½æ•°è°ƒç”¨è€Œè¢«å®ä¾‹åŒ–æ—¶ï¼Œè¿™ç§å®ä¾‹åŒ–ç§°ä¸º**éšå¼å®ä¾‹åŒ–**ï¼ˆimplicit instantiationï¼‰ã€‚ä»æ¨¡æ¿å®ä¾‹åŒ–å‡ºæ¥çš„å‡½æ•°åœ¨æŠ€æœ¯ä¸Šç§°ä¸º**ç‰¹åŒ–**ï¼ˆspecializationï¼‰ï¼Œä½†åœ¨æ—¥å¸¸è¯­è¨€ä¸­é€šå¸¸ç§°ä¸º**å‡½æ•°å®ä¾‹**ï¼ˆfunction instanceï¼‰ã€‚äº§ç”Ÿç‰¹åŒ–çš„æ¨¡æ¿ç§°ä¸º**ä¸»æ¨¡æ¿**ï¼ˆprimary templateï¼‰ã€‚å‡½æ•°å®ä¾‹åœ¨æ‰€æœ‰æ–¹é¢éƒ½æ˜¯æ™®é€šå‡½æ•°ã€‚

==å¦‚æœæ²¡æœ‰å¯¹å‡½æ•°æ¨¡æ¿è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œåˆ™ç›¸åº”çš„å‡½æ•°æ¨¡æ¿å°†ä¸ä¼šåœ¨è¯¥ç¿»è¯‘å•å…ƒä¸­è¢«å®ä¾‹åŒ–ã€‚==

```cpp
#include <iostream>

template <typename T>
T max(T x, T y) // function template for max(T, T)
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max<int>(1, 2) << '\n';    // instantiates and calls function max<int>(int, int)
    std::cout << max<int>(4, 3) << '\n';    // calls already instantiated function max<int>(int, int)
    std::cout << max<double>(1, 2) << '\n'; // instantiates and calls function max<double>(double, double)

    return 0;
}
```

---
## Template argument deduction

ä¾‹å¦‚ï¼Œä¸è¿™æ ·è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼š

```cpp
std::cout << max<int>(1, 2) << '\n'; // specifying we want to call max<int>
```

è€Œæ˜¯ï¼š

```cpp
std::cout << max<>(1, 2) << '\n';
std::cout << max(1, 2) << '\n';
```

æ­£å¸¸çš„å‡½æ•°è°ƒç”¨è¯­æ³•å°†ä¼˜å…ˆé€‰æ‹©éæ¨¡æ¿å‡½æ•°ï¼Œè€Œä¸æ˜¯ä»æ¨¡æ¿å®ä¾‹åŒ–çš„åŒæ ·å¯è¡Œçš„å‡½æ•°ï¼š

```cpp
#include <iostream>

template <typename T>
T max(T x, T y)
{
    std::cout << "called max<int>(int, int)\n";
    return (x < y) ? y : x;
}

int max(int x, int y)
{
    std::cout << "called max(int, int)\n";
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max<int>(1, 2) << '\n'; // calls max<int>(int, int)
    std::cout << max<>(1, 2) << '\n';    // deduces max<int>(int, int) (non-template functions not considered)
    std::cout << max(1, 2) << '\n';      // calls max(int, int)

    return 0;
}
```

---
## Forbidden certain arguments

æˆ‘ä»¬å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œç¦æ­¢å®ä¾‹åŒ–æŸäº›å‚æ•°çš„å‡½æ•°æ¨¡æ¿ã€‚ğŸˆ²

è¿™å¯ä»¥é€šè¿‡å‡½æ•°æ¨¡æ¿ç‰¹åŒ–æ¥å®ç°ï¼Œå®ƒå…è®¸æˆ‘ä»¬é‡è½½ç‰¹å®šå‚æ•°çš„å‡½æ•°æ¨¡æ¿ï¼Œå¹¶ä½¿ç”¨ = delete è¯­å¥ã€‚

```cpp
#include <iostream>
#include <string>

template <typename T>
T addOne(T x)
{
    return x + 1;
}

// Use function template specialization to tell the compiler that addOne(const char*) should emit a compilation error
// const char* will match a string literal
template <>
const char* addOne(const char* x) = delete;

int main()
{
    std::cout << addOne("Hello, world!") << '\n'; // compile error

    return 0;
}
```

---
## è­¦æƒ•åŒ…å« modifiable static local variables çš„å‡½æ•°æ¨¡æ¿

å½“å‡½æ•°æ¨¡æ¿ä¸­ä½¿ç”¨ static local variableï¼Œæ¯ä¸ªå‡½æ•°å®ä¾‹éƒ½å°† have **a separate version of the static local variable**. å¦‚æœæ˜¯ const é‚£è¿˜å¥½ï¼Œå¦‚æœå¯ä¿®æ”¹ï¼Œé‚£ç»“æœå¯èƒ½å‡ºä¹æ„æ–™ã€‚

```cpp
#include <iostream>

template <typename T>
void printIDAndValue(T value);

template <>
void printIDAndValue<int>(int value)
{
    static int id{ 0 };
    std::cout << ++id << ") " << value << '\n';
}

template <>
void printIDAndValue<double>(double value)
{
    static int id{ 0 };
    std::cout << ++id << ") " << value << '\n';
}

int main()
{
    printIDAndValue(12);   // calls printIDAndValue<int>()
    printIDAndValue(13);   // calls printIDAndValue<int>()

    printIDAndValue(14.5); // calls printIDAndValue<double>()

    return 0;
}
```

Note thatÂ `printIDAndValue<int>`Â andÂ `printIDAndValue<double>`Â each have their own independent static local variable namedÂ `id`, not one that is shared between them.

---
## å«å¤šç§æ¨¡æ¿ç±»å‹çš„å‡½æ•°æ¨¡æ¿

```cpp
#include <iostream>

template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max(2, 3.5) << '\n';  // compile error âŒ

    return 0;
}
```

ä½ å¯èƒ½ä¼šæƒŠè®¶åœ°å‘ç°è¿™ä¸ªç¨‹åºæ ¹æœ¬ç¼–è¯‘ä¸å‡ºæ¥ã€‚ç›¸åï¼Œç¼–è¯‘å™¨ä¼šæŠ›å‡ºä¸€å †çœ‹èµ·æ¥å¾ˆç–¯ç‹‚çš„é”™è¯¯ä¿¡æ¯ã€‚

```
Project3.cpp(11,18): error C2672: 'max': no matching overloaded function found
Project3.cpp(11,28): error C2782: 'T max(T,T)': template parameter 'T' is ambiguous
Project3.cpp(4): message : see declaration of 'max'
Project3.cpp(11,28): message : could be 'double'
Project3.cpp(11,28): message : or       'int'
Project3.cpp(11,28): error C2784: 'T max(T,T)': could not deduce template argument for 'T' from 'double'
Project3.cpp(4): message : see declaration of 'max'
```

åœ¨æˆ‘ä»¬çš„å‡½æ•°è°ƒç”¨ `max(2, 3.5)` ä¸­ï¼Œæˆ‘ä»¬ä¼ å…¥äº†ä¸¤ç§ä¸åŒç±»å‹çš„å‚æ•°ï¼šä¸€ä¸ªæ˜¯ `int`ï¼Œå¦ä¸€ä¸ªæ˜¯ `double`ã€‚å› ä¸ºæˆ‘ä»¬è°ƒç”¨å‡½æ•°æ—¶æ²¡æœ‰ä½¿ç”¨å°–æ‹¬å·æ¥æ˜¾å¼æŒ‡å®šç±»å‹ï¼Œç¼–è¯‘å™¨ä¼šå…ˆæ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸€ä¸ªéæ¨¡æ¿çš„å‡½æ•°åŒ¹é… `max(int, double)`ã€‚å®ƒæ‰¾ä¸åˆ°è¿™æ ·çš„å‡½æ•°ã€‚

æ¥ä¸‹æ¥ï¼Œç¼–è¯‘å™¨ä¼šå°è¯•æŸ¥æ‰¾å‡½æ•°æ¨¡æ¿åŒ¹é…ã€‚ç„¶è€Œï¼Œè¿™ä¹Ÿä¼šå¤±è´¥ï¼ŒåŸå› å¾ˆç®€å•ï¼š`T` åªèƒ½ä»£è¡¨å•ä¸€ç±»å‹ã€‚æ²¡æœ‰ä¸€ä¸ªç±»å‹ `T` èƒ½è®©ç¼–è¯‘å™¨å°†å‡½æ•°æ¨¡æ¿ `max<T>(T, T)` å®ä¾‹åŒ–æˆä¸€ä¸ªå‚æ•°ç±»å‹ä¸åŒçš„å‡½æ•°ã€‚æ¢å¥è¯è¯´ï¼Œå› ä¸ºå‡½æ•°æ¨¡æ¿ä¸­ä¸¤ä¸ªå‚æ•°çš„ç±»å‹éƒ½æ˜¯ `T`ï¼Œ**å®ƒä»¬å¿…é¡»è§£æä¸ºç›¸åŒçš„å®é™…ç±»å‹**ã€‚

ç”±äºæ—¢æ²¡æœ‰æ‰¾åˆ°éæ¨¡æ¿åŒ¹é…ï¼Œä¹Ÿæ²¡æœ‰æ‰¾åˆ°æ¨¡æ¿åŒ¹é…ï¼Œå‡½æ•°è°ƒç”¨æ— æ³•è§£æï¼Œå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚

ä½ å¯èƒ½ä¼šæƒ³ï¼Œä¸ºä»€ä¹ˆç¼–è¯‘å™¨ä¸ç”Ÿæˆ `max<double>(double, double)`ï¼Œç„¶åé€šè¿‡æ•°å€¼è½¬æ¢å°† `int` å‚æ•°è½¬æ¢ä¸º `double` å‘¢ï¼Ÿ

ç­”æ¡ˆå¾ˆç®€å•ï¼š==ç±»å‹è½¬æ¢åªåœ¨è§£æå‡½æ•°é‡è½½æ—¶è¿›è¡Œï¼Œè€Œä¸ä¼šåœ¨æ¨¡æ¿å‚æ•°æ¨å¯¼æ—¶è¿›è¡Œã€‚==

æ¯”å¦‚ç›¸æ¯”äºä¸Šé¢çš„ç¼–è¯‘é”™è¯¯ï¼Œä¸‹é¢çš„ä»£ç å¯ä»¥æ­£å¸¸æ‰§è¡Œï¼š

```cpp
#include <iostream>

double max(double x, double y)
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max(2, 3.5) << '\n'; // the int argument will be converted to a double

    return 0;
}
```

**æ¨¡æ¿å‚æ•°ä¸è¿›è¡Œç±»å‹è½¬æ¢çš„è¡Œä¸ºæ˜¯æœ‰æ„ä¸ºä¹‹ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªåŸå› ï¼š**

1. **ç®€åŒ–è§„åˆ™**  
    è¿™æ ·åšè®©è§„åˆ™å˜å¾—ç®€å•æ˜äº†ï¼šè¦ä¹ˆå‡½æ•°è°ƒç”¨çš„å®å‚ç±»å‹å’Œæ¨¡æ¿ç±»å‹å‚æ•°å®Œå…¨åŒ¹é…ï¼Œè¦ä¹ˆå°±ä¸åŒ¹é…ï¼ˆä¸ä¼šè‡ªåŠ¨è¿›è¡Œç±»å‹è½¬æ¢æ¥å°è¯•åŒ¹é…ï¼‰ã€‚

2. **ä¿è¯ç±»å‹ä¸€è‡´æ€§**  
    è¿™æ ·å¯ä»¥è®©æˆ‘ä»¬ç¼–å†™ä¸€äº›å‡½æ•°æ¨¡æ¿ï¼Œè¦æ±‚å¤šä¸ªå‚æ•°å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹ï¼ˆæ¯”å¦‚ä¸Šé¢æåˆ°çš„ä¾‹å­ï¼‰ï¼Œä»è€Œä¿è¯ç±»å‹å®‰å…¨ã€‚å¦‚æœå…è®¸è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼Œå°±æ— æ³•ä¿è¯å‚æ•°ç±»å‹å®Œå…¨ä¸€è‡´äº†ã€‚

> [!Warning]
> æ¨¡æ¿å‚æ•°æ¨å¯¼ä¸­ä¸ä¼šè¿›è¡Œè‡ªåŠ¨çš„ç±»å‹è½¬æ¢ã€‚

---

çœ‹èµ·æ¥ä¸‹é¢è¿™ç§æ–¹å¼èƒ½å¤Ÿè§£å†³é—®é¢˜ï¼š

```cpp
#include <iostream>

template <typename T, typename U> // We're using two template type parameters named T and U
T max(T x, U y) // x can resolve to type T, and y can resolve to type U
{
    return (x < y) ? y : x; // uh oh, we have a narrowing conversion problem here
}

int main()
{
    std::cout << max(2, 3.5) << '\n'; // resolves to max<int, double>

    return 0;
}
```

å› ä¸º T å’Œ U æ˜¯ç‹¬ç«‹çš„æ¨¡æ¿å‚æ•°ï¼Œå®ƒä»¬å¯ä»¥ç‹¬ç«‹åœ°è§£æå…¶ç±»å‹ã€‚

ç„¶è€Œï¼Œè¿™ä¸ªä¾‹å­å¹¶ä¸æ­£ç¡®ã€‚

æ¡ä»¶è¿ç®—ç¬¦ (?:) è¦æ±‚å…¶ï¼ˆéæ¡ä»¶ï¼‰æ“ä½œæ•°å…·æœ‰ç›¸åŒçš„é€šç”¨ç±»å‹ã€‚æ“ä½œæ•°æ˜¯ int å’Œ double æ—¶ï¼Œæ¡ä»¶è¿ç®—ç¬¦ç”Ÿæˆçš„å€¼å°†æ˜¯ double ç±»å‹ã€‚ä½†å‡½æ•°çš„è¿”å›ç±»å‹æ˜¯ intã€‚æˆ‘ä»¬çš„å€¼ 3.5 æ­£åœ¨ç»å†å‘ int å€¼ 3 çš„çª„åŒ–è½¬æ¢ï¼Œå¯¼è‡´æ•°æ®ä¸¢å¤±ï¼ˆå¹¶å¯èƒ½å¼•å‘ç¼–è¯‘å™¨è­¦å‘Šï¼‰ã€‚

---

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å›ç±»å‹æ¨æ–­ï¼ˆé€šè¿‡ autoï¼‰ä¼šå¾ˆæœ‰ç”¨â€”â€”æˆ‘ä»¬è®©ç¼–è¯‘å™¨æ ¹æ® return è¯­å¥æ¨æ–­å‡ºè¿”å›ç±»å‹ï¼š

```cpp
#include <iostream>

template <typename T, typename U>
auto max(T x, U y) // ask compiler can figure out what the relevant return type is
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max(2, 3.5) << '\n';

    return 0;
}
```

éœ€è¦æ³¨æ„çš„å°±æ˜¯ï¼Œauto è¿”å›ç±»å‹çš„å‡½æ•°åœ¨ä½¿ç”¨ä¹‹å‰éœ€è¦å®Œå…¨å®šä¹‰ï¼ˆå‰å‘å£°æ˜æ˜¯ä¸å¤Ÿçš„ï¼‰ï¼Œå› ä¸ºç¼–è¯‘å™¨å¿…é¡»æ£€æŸ¥å‡½æ•°å®ç°æ¥ç¡®å®šè¿”å›ç±»å‹ã€‚

---

å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥å‰å‘å£°æ˜çš„å‡½æ•°ï¼Œå°±å¿…é¡»æ˜ç¡®è¿”å›ç±»å‹ã€‚ç”±äºè¿”å›ç±»å‹éœ€è¦æ˜¯ `T` å’Œ `U` çš„å…¬å…±ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `std::common_type_t` æ¥è·å– `T` å’Œ `U` çš„å…¬å…±ç±»å‹ï¼Œå¹¶å°†å…¶ä½œä¸ºæ˜¾å¼è¿”å›ç±»å‹ã€‚

```cpp
#include <iostream>
#include <type_traits> // for std::common_type_t

template <typename T, typename U>
auto max(T x, U y) -> std::common_type_t<T, U>; // returns the common type of T and U

int main()
{
    std::cout << max(2, 3.5) << '\n';

    return 0;
}

template <typename T, typename U>
auto max(T x, U y) -> std::common_type_t<T, U>
{
    return (x < y) ? y : x;
}
```

---

C++20 å¼•å…¥äº† `auto` å…³é”®å­—çš„æ–°ç”¨æ³•ï¼šå½“ `auto` å…³é”®å­—è¢«ç”¨ä½œæ™®é€šå‡½æ•°çš„å‚æ•°ç±»å‹æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å°†è¯¥å‡½æ•°è½¬æ¢ä¸ºå‡½æ•°æ¨¡æ¿ï¼Œå…¶ä¸­æ¯ä¸ª `auto` å‚æ•°éƒ½ä¼šæˆä¸ºä¸€ä¸ªç‹¬ç«‹çš„æ¨¡æ¿ç±»å‹å‚æ•°ã€‚ä½¿ç”¨è¿™ç§æ–¹å¼åˆ›å»ºå‡½æ•°æ¨¡æ¿ç§°ä¸º**ç®€å†™å‡½æ•°æ¨¡æ¿**ï¼ˆabbreviated function templateï¼‰ã€‚

æ¯”å¦‚ï¼š
```cpp
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
```

is shorthand in C++20 for the following:

```cpp
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
```

ä½†æ˜¯å½“å¸Œæœ›å¤šä¸ªè‡ªåŠ¨å‚æ•°å¿…é¡»å…·æœ‰ç›¸åŒçš„ç±»å‹æ—¶ï¼Œå°±ä¸èƒ½ä½¿ç”¨ç¼©å†™å‡½æ•°æ¨¡æ¿ã€‚åªèƒ½è¿™ä¹ˆå†™ï¼š

```cpp
template <typename T>
T max(T x, T y) // two parameters of the same type
{
    return (x < y) ? y : x;
}
```

---
## å‡½æ•°æ¨¡æ¿çš„ä¸€äº›å°ç¼ºç‚¹

First, the compiler will create (and compile) a function for each function call with a unique set of argument types. ä¸ä¼šå†é€šè¿‡æ•°å€¼æå‡å’Œç±»å‹è½¬æ¢å§”æ›²æ±‚å…¨ ğŸ¥¹ã€‚å› æ­¤ï¼Œè™½ç„¶å‡½æ•°æ¨¡æ¿çš„ç¼–å†™éå¸¸ç®€æ´ï¼Œä½†å®ƒä»¬å¯èƒ½ä¼šè†¨èƒ€æˆå¤§é‡ä»£ç ï¼Œè¿™å¯èƒ½å¯¼è‡´**ä»£ç è†¨èƒ€**ï¼ˆcode bloatï¼‰å’Œè¾ƒæ…¢çš„ç¼–è¯‘æ—¶é—´ã€‚

å‡½æ•°æ¨¡æ¿çš„æ›´å¤§ç¼ºç‚¹æ˜¯ï¼Œå®ƒä»¬å¾€å¾€ä¼šäº§ç”Ÿéå¸¸å¤æ‚ã€å‡ ä¹éš¾ä»¥é˜…è¯»çš„é”™è¯¯ä¿¡æ¯ï¼Œè¿™äº›é”™è¯¯ä¿¡æ¯æ¯”æ™®é€šå‡½æ•°çš„é”™è¯¯ä¿¡æ¯æ›´éš¾ç†è§£ã€‚è¿™äº›é”™è¯¯ä¿¡æ¯å¯èƒ½è®©äººæœ›è€Œç”Ÿç•ï¼Œä½†ä¸€æ—¦ä½ ç†è§£äº†å®ƒä»¬æƒ³è¦å‘Šè¯‰ä½ çš„å†…å®¹ï¼Œæ‰€æŒ‡å‡ºçš„é—®é¢˜é€šå¸¸éƒ½ç›¸å½“å®¹æ˜“è§£å†³ã€‚

ä½†å®˜æ–¹æ•™ç¨‹çš„ç»“è®ºæ˜¯è¿™äº›ç¼ºç‚¹åœ¨æ¨¡æ¿å‡½æ•°çš„ä¼˜ç‚¹é¢å‰ä¸å€¼ä¸€æã€‚