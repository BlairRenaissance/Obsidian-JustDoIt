## 匿名函数

lambda 表达式（也称为 lambda 或闭包）允许我们在另一个函数内部定义匿名函数。这种嵌套很重要，因为它既可以避免命名空间污染，又可以将函数定义在离使用它最近的地方（提供额外的上下文）。

### lambda 表达式

lambda 的语法是 C++ 中比较奇怪的语法之一，需要花点时间来适应。lambda 的形式如下：

```cpp
[捕获子句] (参数列表) -> 返回类型
{
    语句;
}
```

- 如果不需要捕获任何变量，捕获子句可以为空。
- 如果不需要参数，参数列表可以为空。除非指定了返回类型，否则参数列表也可以完全省略。
- 返回类型如果省略，会使用类型推导来确定返回类型。如果使用返回类型推导，lambda 中的所有返回语句必须返回相同的类型。
- 当编译器无法自动推导返回类型时，必须进行显式转换，使所有返回类型匹配，或者显式指定 lambda 的返回类型，并让编译器进行隐式转换。
- lambda（作为匿名函数）没有名称，所以我们不需要提供名称。

``` cpp
auto divide{ [](int x, int y, bool intDivision) { // 注意：没有指定返回类型
if (intDivision)
  return x / y; // 返回类型是 int
else
  return static_cast<double>(x) / y; // 错误：返回类型与之前的返回类型不匹配
} };
```

对于常见操作（例如加法、取反或比较），往往不需要编写自己的 lambda，因为标准库提供了许多基本的可调用对象可以使用。这些在 `<functional>` 头文件中定义。

---
### lambda 的类型

我们在需要使用 lambda 的地方定义它的这种用法，称为函数字面量。

然而，在同一行中编写 lambda 有时会使代码更难阅读。就像我们可以用字面量值（或函数指针）初始化变量供以后使用一样，我们可以用 lambda 定义初始化 lambda 变量，然后在以后使用它。一个命名的 lambda 加上一个好的函数名可以使代码更易读。

例如，在下面的代码片段中，我们使用 `std::all_of` 来检查数组的所有元素是否都是偶数：

```cpp
// 不好：我们必须阅读 lambda 才能理解发生了什么
return std::all_of(array.begin(), array.end(), [](int i){ return ((i % 2) == 0); });
```

我们可以如下改进它的可读性：

```cpp
// 好：相反，我们可以将 lambda 存储在命名变量中，然后将其传递给函数
auto isEven{ [](int i){ return (i % 2) == 0; } };

return std::all_of(array.begin(), array.end(), isEven);
```

> [!Tip]
> 将 lambda 存储在变量中的好处有：
> - 提供了一种给 lambda 起名的方法，提高可读性。
> - 提供了一种多次使用该 lambda 的方法。

但是 lambda `isEven` 的类型是什么？

事实证明，lambda 没有我们可以显式使用的类型。当我们编写 lambda 时，编译器会为 lambda 生成一个独特的类型，但不会暴露给我们。使用 lambda 实际类型的唯一方法是通过 `auto`。

实际上，lambda 不是函数（这也是它们避免 C++ 不支持嵌套函数这一限制的部分原因）。它们是一种特殊的对象，称为仿函数。仿函数是包含重载的 `operator()` 的对象，这使得它们可以像函数一样被调用。

---
### 将 lambda 传递给函数

虽然我们不知道 lambda 的类型，但有几种方法可以存储 lambda 供定义后使用。

如果我们想将 lambda 传递给函数，有 4 种选择：

```cpp
#include <functional>
#include <iostream>

// 情况 1：使用 std::function 参数
void repeat1(int repetitions, const std::function<void(int)>& fn)
{
    for (int i{ 0 }; i < repetitions; ++i)
        fn(i);
}

// 情况 2：使用带有类型模板参数的函数模板
template <typename T>
void repeat2(int repetitions, const T& fn)
{
    for (int i{ 0 }; i < repetitions; ++i)
        fn(i);
}

// 情况 3：使用简化的函数模板语法（C++20）
void repeat3(int repetitions, const auto& fn)
{
    for (int i{ 0 }; i < repetitions; ++i)
        fn(i);
}

// 情况 4：使用函数指针（仅适用于没有捕获的 lambda）
void repeat4(int repetitions, void (*fn)(int))
{
    for (int i{ 0 }; i < repetitions; ++i)
        fn(i);
}

int main()
{
    auto lambda = [](int i)
    {
        std::cout << i << '\n';
    };

    repeat1(3, lambda);
    repeat2(3, lambda);
    repeat3(3, lambda);
    repeat4(3, lambda);

    return 0;
}
```

> [!Tip]
> 将 lambda 存储在变量中时，使用 `auto` 作为变量的类型。

---
### 泛型 lambda

从 C++14 开始允许对 lambda 的参数使用 `auto`。（ C++20 开始普通函数也能够对参数使用 `auto`）。

因为带有一个或多个 `auto` 参数的 lambda 可以潜在地处理各种各样的类型，所以它们被称为泛型 lambda。

```cpp

// 搜索两个连续的、以相同字母开头的月份，注意参数类型没有具体给出
const auto sameLetter{ std::adjacent_find(months.begin(), months.end(),
					 [](const auto& a, const auto& b) { return a[0] == b[0];}) };

if (sameLetter != months.end())
{
// std::next 返回 sameLetter 之后的下一个迭代器
std::cout << *sameLetter << " and " << *std::next(sameLetter)
		  << " start with the same letter\n";
}

```

```plaintext
June and July start with the same letter
```

当 lambda 有一个或多个 `auto` 参数时，编译器会从对 lambda 的调用中推断所需的参数类型。

泛型 lambda 的工作方式相同：会为 `auto` 解析的每种不同类型生成一个独特的 lambda。

下面的示例展示了一个泛型 lambda 如何变成两个不同的 lambda：

```cpp

int main()
{
  // 打印一个值并计算 @print 被调用了多少次
  auto print{ [](auto value) {
      static int callCount{ 0 };
      std::cout << callCount++ << ": " << value << '\n';
    }
  };

  print("hello"); // 0: hello
  print("world"); // 1: world

  print(1); // 0: 1
  print(2); // 1: 2

  print("ding dong"); // 2: ding dong

  return 0;
}
```

输出：

```plaintext
0: hello
1: world
0: 1
1: 2
2: ding dong
```

在上面的示例中，我们定义了一个 lambda，然后用两种不同的参数调用它（一个字符串字面量参数和一个整数参数）。这会生成两个不同版本的 lambda（一个带有字符串字面量参数，一个带有整数参数）。

大多数时候，这并不重要。然而，请注意，如果泛型 lambda 使用静态生存期变量，这些变量不会在生成的 lambda 之间共享。

要在生成的两个 lambda 之间有一个共享的计数器，我们必须定义一个全局变量或 lambda 外部的 `static` 局部变量！

---
### constexpr lambda

从 C++17 开始，如果结果满足常量表达式的要求，lambda 会隐式成为 constexpr。这通常需要两件事：

- lambda 必须要么没有捕获，要么所有捕获都必须是 constexpr。
- lambda 调用的函数必须是 constexpr。注意，许多标准库算法和数学函数直到 C++20 或 C++23 才成为 constexpr。

在下面的示例中，我们的 lambda 在 C++17 中不会隐式成为 constexpr，但在 C++20 中会，因为 `std::count_if` 在 C++20 中成为 constexpr。这意味着在 C++20 中我们可以使 `fiveLetterMonths` 成为 constexpr：

```cpp
constexpr auto fiveLetterMonths{ std::count_if(months.begin(), months.end(),
	[](std::string_view str) { return str.length() == 5;}) };
```

---
## Lambda 捕获

### 捕获子句

捕获子句用于间接地让 lambda 访问其周围作用域中原本无法访问的变量。

我们只需将希望从 lambda 内部访问的实体列在捕获子句中即可。

在这个例子中，我们希望让 lambda 访问变量 `search` 的值，因此将其添加到捕获子句中：

```cpp
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>
#include <string>

int main()
{
  std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };

  std::string search{};
  std::cin >> search;

  // 捕获 @search                                   vvvvvv
  auto found{ std::find_if(arr.begin(), arr.end(), [search](std::string_view str) {
    return str.find(search) != std::string_view::npos;
  }) };

  if (found == arr.end()) { std::cout << "Not found\n"; }
  else { std::cout << "Found " << *found << '\n'; }

  return 0;
}
```

现在用户可以搜索数组中的元素了。输出：

```plaintext
nana
Found banana
```

那么捕获实际上是如何工作的呢？

虽然看起来上面示例中的 lambda 直接访问了 `main` 函数中的 `search` 变量，但事实并非如此。lambda 可能看起来像嵌套代码块，但它们的工作方式略有不同（这种区别很重要）。

当 lambda 定义被执行时，对于每个 lambda 捕获的变量，都会在 lambda 内部创建该变量的副本（名称相同）。这些副本变量会在此时用同名的外部作用域变量进行初始化。

因此，在上面的示例中，当 lambda 对象创建时，lambda 会获得自己的名为 `search` 的副本变量。这个副本 `search` 与 `main` 函数中的 `search` 具有相同的值，因此看起来我们在访问 `main` 的 `search`，但实际上并非如此。

虽然这些副本变量名称相同，但它们的类型不一定与原始变量相同。

> [!Tip]
> lambda 捕获的变量是外部作用域变量的副本，而非变量本身。

附录：
根据前文我们知道 lambda 看起来像函数，但它们实际上是可以像函数一样被调用的对象，称为仿函数。
当编译器遇到 lambda 定义时，它会为 lambda 创建自定义的对象定义。每个捕获的变量都会成为该对象的数据成员。
在运行时，当遇到 lambda 定义时，lambda 对象会被实例化，此时 lambda 的成员会被初始化。

---
### 捕获的变量默认视为 const

当 lambda 被调用时，会调用 `operator()`。默认情况下，该 `operator()` 将捕获的变量视为 const，这意味着 lambda 不允许修改这些捕获的变量。

在以下示例中，我们捕获变量 `ammo` 并尝试对其进行递减：

```cpp
int ammo{ 10 };
// 非法，ammo 不能被修改
auto shoot{ [ammo]() { --ammo; } };
```

上面的代码无法编译，因为在 lambda 内部 `ammo` 被视为 const。

---
### 可变捕获

要允许修改被捕获的变量，我们可以将 lambda 标记为 `mutable`：

```cpp
int ammo{ 10 };
// 现在是 mutable  // 现在允许修改 ammo
auto shoot{ [ammo]() mutable { --ammo; } };
```

虽然现在代码可以编译，但仍然存在逻辑错误。

发生了什么？

当 lambda 被调用时，lambda 捕获了 `ammo` 的副本。当 lambda 将 `ammo` 从 10 递减到 9 再到 8 时，它递减的是自己的副本，而不是原始的 `ammo` 值。

同时，由于捕获的变量是 lambda 对象的成员，它们的值会在多次调用 lambda 时保持不变！这很可能会引入预期之外的错误：[[5.10 Lambda 匿名函数#可变 lambda 的意外副本]]

---
### 按引用捕获

就像函数可以通过引用传递参数来修改参数值一样，我们也可以通过引用捕获变量，让 lambda 能够影响参数的值。

要按引用捕获变量，我们在捕获中的变量名前添加 & 符号。与按值捕获的变量不同，按引用捕获的变量是非 const 的，除非被捕获的变量本身是 `const`。在通常更倾向于通过引用传递参数的场景（例如对于非基础类型），应优先使用按引用捕获而非按值捕获。

以下是将 `ammo` 按引用捕获的代码：


```cpp
int ammo{ 10 };
// 不再需要 mutable  // 对 ammo 的修改会影响 main 中的 ammo
auto shoot{ [&ammo]() { --ammo; } };
```

---
### 捕获多个变量

多个变量可以通过逗号分隔进行捕获。可以混合按值和按引用捕获的变量：

```cpp
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// 按值捕获 health 和 armor，按引用捕获 enemies
[health, armor, &enemies](){};
```

---
### 默认捕获

必须明确列出要捕获的变量可能会很麻烦。如果修改 lambda，可能会忘记添加或删除捕获的变量。

幸运的是，我们可以借助编译器自动生成需要捕获的变量列表。 

默认捕获会捕获所有在 lambda 中提及的变量。如果使用默认捕获，则不会捕获 lambda 中未提到的变量。 

> [!Tip]
> - 按值捕获所有使用的变量，使用 =。 
> - 按引用捕获所有使用的变量，使用 &。

默认捕获可以与普通捕获混合使用。我们可以按值捕获一些变量，按引用捕获其他变量，但每个变量只能被捕获一次。

```cpp
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// 按值捕获 health 和 armor，按引用捕获 enemies
[health, armor, &enemies](){};

// 按引用捕获 enemies，其他变量按值捕获
[=, &enemies](){};

// 按值捕获 armor，其他变量按引用捕获
[&, armor](){};

// 非法，已经声明按引用捕获所有变量
[&, &armor](){};

// 非法，已经声明按值捕获所有变量
[=, armor](){};

// 非法，armor 出现了两次
[armor, &health, &armor](){};

// 非法，默认捕获必须是捕获组中的第一个元素
[armor, &](){};
```

> [!Warning]
> 每个变量只能被捕获一次。

---
### 在 lambda 捕获中定义新变量

有时我们希望捕获经过轻微修改的变量，或者声明仅在 lambda 作用域中可见的新变量。我们可以通过在 lambda 捕获中定义变量（无需指定类型）来实现这一点。

```cpp
#include <array>
#include <iostream>
#include <algorithm>

int main()
{
  std::array areas{ 100, 25, 121, 40, 56 };

  int width{};
  int height{};

  std::cin >> width >> height;

  // 我们存储了面积，但用户输入的是宽和高
  // 需要先计算面积才能搜索
  auto found{ std::find_if(areas.begin(), areas.end(),
                           // 声明仅对 lambda 可见的新变量
                           // userArea 的类型会被自动推导为 int
                           [userArea{ width * height }](int knownArea) {
                             return userArea == knownArea;
                           }) };

  if (found == areas.end())
  {
    std::cout << "I don't know this area :(\n";
  }
  else
  {
    std::cout << "Area found :)\n";
  }

  return 0;
}
```

`userArea` 只会在 lambda 定义时计算一次。计算出的面积存储在 lambda 对象中，并且在每次调用时保持相同。如果 lambda 是可变的，并且修改了在捕获中定义的变量，则原始值会被覆盖。

---
### 捕获 this 指针

在类的成员函数中，可以捕获 `this` 指针，以便在 lambda 中访问类的成员。

```cpp
class MyClass {
public:
    int value;
    void func() {
        auto lambda = [this]() { value += 1; };
    }
};
```

---
### 悬空的捕获变量

变量在 lambda 定义时被捕获。如果按引用捕获的变量在 lambda 之前销毁，lambda 将持有悬空引用。

```cpp
#include <iostream>
#include <string>

// 返回一个 lambda
auto makeWalrus(const std::string& name)
{
  // 按引用捕获 name 并返回 lambda
  return [&]() {
    std::cout << "I am a walrus, my name is " << name << '\n'; // 未定义行为
  };
}

int main()
{
  // 创建一个名为 Roofus 的新海象
  // sayName 是 makeWalrus 返回的 lambda
  auto sayName{ makeWalrus("Roofus") };

  // 调用 makeWalrus 返回的 lambda 函数
  sayName();

  return 0;
}
```

临时字符串在 `makeWalrus()` 结束时销毁，但 lambda `sayName` 在那之后仍然引用它。因此，当我们调用 `sayName` 时，会访问悬空引用，导致未定义行为。

但是，让 lambda 持有值能够解决该问题。（ 注意不是给函数 `makeWalrus()` 传值）

如果我们希望捕获的 `name` 在 lambda 使用时有效，需要改为按值捕获（显式或使用默认按值捕获）。

> [!Warning]
> 按引用捕获变量时要格外小心，尤其是使用默认引用捕获时。被捕获的变量必须比 lambda 存活得更久。

---
### 可变 lambda 的意外副本

由于 lambda 是对象，它们可以被复制。在某些情况下，这可能会导致问题。考虑以下代码：

```cpp
#include <iostream>

int main()
{
  int i{ 0 };

  // 创建名为 count 的新 lambda
  auto count{ [i]() mutable { std::cout << ++i << '\n'; } };

  count(); // 调用 count

  auto otherCount{ count }; // 创建 count 的副本

  // 调用 count 和副本
  count();
  otherCount();

  return 0;
}
```

```plaintext
1
2
2
```

代码没有输出 1、2、3，而是两次输出 2。当我们创建 `otherCount` 作为 `count` 的副本时，我们创建了 `count` 当前状态的副本。`count` 的 `i` 是 1，因此 `otherCount` 的 `i` 也是 1。由于 `otherCount` 是 `count` 的副本，它们各自有自己的 `i`。

---
现在让我们看一个稍微不那么明显的例子：

```cpp
#include <iostream>
#include <functional>

void myInvoke(const std::function<void()>& fn)
{
    fn();
}

int main()
{
    int i{ 0 };

    // 递增并打印其局部副本 @i
    auto count{ [i]() mutable { std::cout << ++i << '\n'; } };

    myInvoke(count);
    myInvoke(count);
    myInvoke(count);

    return 0;
}
```

```plaintext
1
1
1
```

这个例子以更隐晦的形式表现出与前一个例子相同的问题。

当我们调用 `myInvoke(count)` 时，编译器会发现 `count`（具有 lambda 类型）与引用参数类型（`std::function<void()>`）不匹配。它会将 lambda 转换为临时的 `std::function`，以便引用参数可以绑定到它，这会创建 lambda 的副本。因此，我们对 `fn()` 的调用实际上是在作为临时 `std::function` 一部分的 lambda 副本上执行的，而不是实际的 lambda。

如果我们需要传递可变 lambda，并希望避免意外创建副本，有两种选择：

- 一种选择是使用非捕获 lambda—— 在上面的例子中，我们可以移除捕获，使用静态局部变量来跟踪状态。但静态局部变量可能难以跟踪，会降低代码的可读性。
- 更好的选择是首先防止创建 lambda 的副本。但由于我们无法影响 `std::function`（或其他标准库函数或对象）的实现方式，我们该怎么做呢？一种选择是立即将 lambda 放入 `std::function` 中。这样，当我们调用 `myInvoke()` 时，引用参数 `fn` 可以绑定到我们的 `std::function`，不会创建临时副本：

```cpp
#include <iostream>
#include <functional>

void myInvoke(const std::function<void()>& fn)
{
    fn();
}

int main()
{
    int i{ 0 };

    // 递增并打印其局部副本 @i
    std::function count{ [i]() mutable { // lambda 对象存储在 std::function 中
      std::cout << ++i << '\n';
    } };

    myInvoke(count); // 调用时不创建副本
    myInvoke(count); // 调用时不创建副本
    myInvoke(count); // 调用时不创建副本

    return 0;
}
```

```plaintext
1
2
3
```

- 另一种解决方案是使用引用包装器。C++ 提供了一种方便的类型（在 `<functional>` 头文件中）称为 `std::reference_wrapper`，允许我们传递普通类型，就好像它是引用一样。为了更方便，可以通过 `std::ref()` 函数创建 `std::reference_wrapper`。通过将 lambda 包装在 `std::reference_wrapper` 中，当有人尝试复制我们的 lambda 时，他们实际上会复制引用包装器（避免复制 lambda）。

以下是使用 `std::ref` 更新后的代码：

```cpp
#include <iostream>
#include <functional> // 包含 std::reference_wrapper 和 std::ref

void myInvoke(const std::function<void()>& fn)
{
    fn();
}

int main()
{
    int i{ 0 };

    // 递增并打印其局部副本 @i
    auto count{ [i]() mutable { std::cout << ++i << '\n'; } };
    
    // std::ref(count) 确保 count 被视为引用
    // 因此，任何尝试复制 count 的操作实际上都会复制引用
    // 确保只存在一个 count
    myInvoke(std::ref(count));
    myInvoke(std::ref(count));
    myInvoke(std::ref(count));
	
    return 0;
}
```

```plaintext
1
2
3
```

这种方法有趣的地方在于，即使 `myInvoke` 按值接受 `fn`（而不是按引用），它也能工作！

> [!Rule]
> 标准库函数可能会复制函数对象（提醒：lambda 是函数对象）。如果要提供带有可变捕获变量的 lambda，请使用 `std::ref` 通过引用传递它们。

> [!Warning]
> 尽量避免可变 lambda。不可变 lambda 更易于理解，不会遇到上述问题，以及在添加并行执行时出现的更危险问题。

