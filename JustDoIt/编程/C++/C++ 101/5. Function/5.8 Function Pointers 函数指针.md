## 指向函数的指针

创建非 const 函数指针的语法是你在 C++ 中会遇到的最丑陋的语法之一：

```cpp
// fcnPtr是一个指向不接受参数且返回整数的函数的指针
int (*fcnPtr)();
```

在上面的代码片段中，`fcnPtr`是一个指向无参数且返回整数的函数的指针。`fcnPtr`可以指向任何匹配此类型的函数。

`(*fcnPtr)`周围的括号是出于优先级原因所必需的，因为`int* fcnPtr()`会被解释为一个名为`fcnPtr`的函数的前向声明，该函数不接受参数并返回一个指向整数的指针。

要创建 const 函数指针，const 关键字应放在星号后面：

```cpp
int (*const fcnPtr)();
```

如果你将 const 放在 int 前面，那么它表示被指向的函数将返回一个 const int。

---
## 初始化函数指针

与指向变量的指针一样，我们也可以使用`&foo`来获取指向`foo`的函数指针。

```cpp
int foo()
{
    return 5;
}

int goo()
{
    return 6;
}

int main()
{
    int (*fcnPtr)(){ &foo }; // fcnPtr指向函数foo
    fcnPtr = &goo; // fcnPtr现在指向函数goo

    return 0;
}
```

一个常见的错误是这样做：

```cpp
fcnPtr = goo();
```

这试图将函数`goo()`的调用返回值（类型为`int`）分配给`fcnPtr`（它期望的是`int(*)()`类型的值），这不是我们想要的。我们希望`fcnPtr`被分配函数`goo`的地址，而不是`goo()`的返回值。所以不需要括号。

请注意，函数指针的类型（参数和返回类型）必须与函数的类型匹配。以下是一些例子：

```cpp
// 函数原型
int foo();
double goo();
int hoo(int x);

// 函数指针初始化
int (*fcnPtr1)(){ &foo };    // 正确
int (*fcnPtr2)(){ &goo };    // 错误——返回类型不匹配！
double (*fcnPtr4)(){ &goo }; // 正确
fcnPtr1 = &hoo;              // 错误——fcnPtr1没有参数，但hoo()有参数
int (*fcnPtr3)(int){ &hoo }; // 正确
```

与基本类型不同，C++ 会在需要时隐式地将函数转换为函数指针（因此你不需要使用取地址运算符`&`来获取函数的地址）。但是，函数指针不会转换为`void`指针，反之亦然（尽管有些编译器如 Visual Studio 可能允许这样做）。

```cpp
// 函数原型
int foo();

// 函数初始化
int (*fcnPtr5)() { foo }; // 正确，foo隐式转换为指向foo的函数指针
void* vPtr { foo };       // 不正确，尽管有些编译器可能允许
```

函数指针也可以被初始化为或分配`nullptr`值：

```cpp
int (*fcnptr)() { nullptr }; // 正确
```

就像`auto`关键字可以用来推断普通变量的类型一样，`auto`关键字也可以推断函数指针的类型。

```cpp
#include <iostream>

int foo(int x)
{
    return x;
}

int main()
{
    auto fcnPtr{ &foo };
    std::cout << fcnPtr(5) << '\n';

    return 0;
}
```

这完全如你所期望的那样工作，而且语法非常简洁。当然，缺点是函数的参数类型和返回类型的所有细节都被隐藏了，因此在通过函数进行调用或使用其返回值时更容易出错。不推荐。

---
## 使用函数指针

使用函数指针可以做的另一件主要事情是用它来实际调用函数。有两种方法可以做到这一点。第一种是通过显式解引用：

```cpp
int foo(int x)
{
    return x;
}

int main()
{
    int (*fcnPtr)(int){ &foo }; // 用函数foo初始化fcnPtr

    (*fcnPtr)(5); // 通过fcnPtr调用函数foo(5)

    return 0;
}
```

第二种方法是通过隐式解引用：

```cpp
int foo(int x)
{
    return x;
}

int main()
{
    int (*fcnPtr)(int){ &foo }; // 用函数foo初始化fcnPtr

    fcnPtr(5); // 通过fcnPtr调用函数foo(5)

    return 0;
}
```

如你所见，隐式解引用方法看起来就像正常的函数调用 —— 这正是你所期望的，因为正常的函数名本身就是指向函数的指针！然而，一些较旧的编译器不支持隐式解引用方法，但所有现代编译器都应该支持。

还要注意，因为函数指针可以被设置为`nullptr`，所以在调用函数指针之前，最好断言或有条件地测试它是否为 null 指针。就像普通指针一样，解引用 null 函数指针会导致未定义的行为。

```cpp
int foo(int x)
{
    return x;
}

int main()
{
    int (*fcnPtr)(int){ &foo }; // 用函数foo初始化fcnPtr

    if (fcnPtr) // 确保fcnPtr不是null指针
        fcnPtr(5); // 否则这将导致未定义的行为

    return 0;
}
```

---
## 默认参数不适用于通过函数指针调用的函数

当编译器遇到对具有一个或多个默认参数的函数的正常函数调用时，它会重写函数调用以包含默认参数。这个过程发生在编译时，因此只能应用于可以在编译时解析的函数。

然而，当通过函数指针调用函数时，它是在运行时解析的。在这种情况下，不会重写函数调用来包含默认参数。

> [!Important]
> 由于函数指针解析发生在运行时，当通过函数指针调用函数时，默认参数不会被解析。

这意味着我们可以使用函数指针来消除因默认参数而可能产生的函数调用歧义。在以下示例中，我们展示了两种方法：

```cpp
#include <iostream>

void print(int x)
{
    std::cout << "print(int)\n";
}

void print(int x, int y = 10)
{
    std::cout << "print(int, int)\n";
}

int main()
{
//    print(1); // 歧义的函数调用

    // 分解方法
    using vnptr = void(*)(int); // 定义一个指向void(int)函数的函数指针的类型别名
    vnptr pi { print }; // 用函数print初始化我们的函数指针

    pi(1); // 通过函数指针调用print(int)函数

    // 简洁方法
    static_cast<void(*)(int)>(print)(1); // 调用带参数1的void(int)版本的print

    return 0;
}
```

---
## 将函数作为参数传递

函数指针最有用的用途之一是将函数作为参数传递给另一个函数。用作其他函数参数的函数有时被称为回调函数。

考虑这样一种情况：你正在编写一个执行某项任务的函数（例如对数组进行排序），但你希望用户能够定义该任务的特定部分将如何执行（例如数组是按升序还是降序排序）。比如通过改变比较方式，我们可以改变算法的排序方式，而不影响排序代码的其余部分。

以下是我们之前课程中的选择排序程序：

```cpp
#include <utility> // 用于std::swap

void SelectionSort(int* array, int size)
{
    if (!array)
        return;

    // 遍历数组的每个元素
    for (int startIndex{ 0 }; startIndex < (size - 1); ++startIndex)
    {
        // smallestIndex是我们到目前为止遇到的最小元素的索引
        int smallestIndex{ startIndex };

        // 在数组的剩余元素中寻找最小元素（从startIndex+1开始）
        for (int currentIndex{ startIndex + 1 }; currentIndex < size; ++currentIndex)
        {
            // 如果当前元素比我们之前找到的最小元素小
            if (array[smallestIndex] > array[currentIndex]) // 比较在这里进行
            {
                // 这是本次迭代的新最小数
                smallestIndex = currentIndex;
            }
        }

        // 将我们的起始元素与最小元素交换
        std::swap(array[startIndex], array[smallestIndex]);
    }
}
```

现在，为了让调用者决定排序方式，我们将允许调用者提供他们自己的排序函数，而不是使用我们自己的硬编码比较函数！这是通过函数指针实现的。

因为调用者的比较函数要比较两个整数并返回一个布尔值，指向这样一个函数的指针看起来会像这样：

```cpp
bool (*comparisonFcn)(int, int);
```

期望的比较函数的指针作为第三个参数：

```cpp
#include <utility> // 用于std::swap
#include <iostream>

// 注意我们的用户定义比较是第三个参数
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))
{
    if (!array || !comparisonFcn)
        return;

    // 遍历数组的每个元素
    for (int startIndex{ 0 }; startIndex < (size - 1); ++startIndex)
    {
        // bestIndex是我们到目前为止遇到的最小/最大元素的索引
        int bestIndex{ startIndex };

        // 在数组的剩余元素中寻找最小/最大元素（从startIndex+1开始）
        for (int currentIndex{ startIndex + 1 }; currentIndex < size; ++currentIndex)
        {
            // 如果当前元素比我们之前找到的最小/最大元素小/大
            if (comparisonFcn(array[bestIndex], array[currentIndex])) // 比较在这里进行
            {
                // 这是本次迭代的新最小/最大数
                bestIndex = currentIndex;
            }
        }

        // 将我们的起始元素与最小/最大元素交换
        std::swap(array[startIndex], array[bestIndex]);
    }
}

// 这是一个按升序排序的比较函数
// （注意：它与之前的ascending()函数完全相同）
bool ascending(int x, int y)
{
    return x > y; // 如果第一个元素大于第二个元素，则交换
}

// 这是一个按降序排序的比较函数
bool descending(int x, int y)
{
    return x < y; // 如果第二个元素大于第一个元素，则交换
}

int main()
{
    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };

    // 使用descending()函数按降序排序数组
    selectionSort(array, 9, descending);
    printArray(array, 9);

    // 使用ascending()函数按升序排序数组
    selectionSort(array, 9, ascending);
    printArray(array, 9);

    return 0;
}
```

```plaintext
9 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 8 9
```

这是不是很酷？我们让调用者能够控制我们的选择排序的工作方式。

调用者甚至可以定义他们自己的 “奇怪” 比较函数：

```cpp
bool evensFirst(int x, int y)
{
    // 如果x是偶数而y是奇数，x排在前面（不需要交换）
    if ((x % 2 == 0) && !(y % 2 == 0))
        return false;

    // 如果x是奇数而y是偶数，y排在前面（需要交换）
    if (!(x % 2 == 0) && (y % 2 == 0))
        return true;

    // 否则按升序排序
    return ascending(x, y);
}

int main()
{
    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };

    selectionSort(array, 9, evensFirst);
    printArray(array, 9);

    return 0;
}
```

上面的代码片段产生以下结果：

```plaintext
2 4 6 8 1 3 5 7 9
```

如你所见，在这种情况下使用函数指针提供了一种很好的方式，允许调用者将他们自己的功能 “挂钩” 到你之前编写和测试过的代码中，这有助于促进代码重用！以前，如果你想将一个数组按降序排序，另一个按升序排序，你需要多个版本的排序程序。现在你可以有一个版本，可以按照调用者期望的任何方式排序！

注意：如果函数参数是函数类型，它将被转换为指向该函数类型的指针。这意味着：

```cpp
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))
```

可以等效地写成：

```cpp
void selectionSort(int* array, int size, bool comparisonFcn(int, int))
```

这只对函数参数有效，因此用途有限。在非函数参数上，后者被解释为前向声明：

```cpp
bool (*ptr)(int, int); // 函数指针ptr的定义
bool fcn(int, int);    // 函数fcn的前向声明
```

如果打算传入一个函数作为参数，提供一些标准函数供调用者使用通常会很有用。例如：

```cpp
// 默认按升序排序
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

在这种情况下，只要用户正常调用`selectionSort`（不是通过函数指针），`comparisonFcn`参数将默认为`ascending`。你需要确保`ascending`函数在此之前声明，否则编译器会抱怨它不知道`ascending`是什么。

---
## 使用类型别名

让我们面对现实吧 —— 函数指针的语法很丑陋。然而，类型别名可以用来使函数指针看起来更像普通变量：

```cpp
using ValidateFunction = bool(*)(int, int);
```

这定义了一个名为 “ValidateFunction” 的类型别名，它是一个指向接受两个 int 并返回 bool 的函数的指针。

```cpp
bool validate(int x, int y, bool (*fcnPtr)(int, int)); // 丑陋
bool validate(int x, int y, ValidateFunction pfcn) // 简洁
```
