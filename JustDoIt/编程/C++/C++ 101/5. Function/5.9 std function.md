## 函数指针的 “能力边界”

函数指针（以 `bool(*)(int, int)` 为例）本质是指向函数代码段的 “裸指针”，它只能存储：

- 普通函数的地址（全局函数、静态成员函数）；
- 严格匹配签名的函数（参数、返回值类型必须完全一致）。

核心缺陷：函数指针无法存储 “携带额外状态” 的对象，“携带额外状态” 指的是可调用对象内部包含了**不属于函数参数或返回值的额外数据**，这些数据会影响其调用行为。例如：

- 带捕获的 lambda
- 重载 `operator()` 的类 / 结构体
- `std::bind` 将参数绑定到可调用对象

## `std::function` 的 “万能存储”

定义和存储函数指针的另一种方法是使用`std::function`，它是标准库`<functional>`头的一部分。

```cpp
#include <functional>

bool validate(int x, int y, std::function<bool(int, int)> fcn); // 返回bool并接受两个int参数的std::function方法
```

`std::function<bool(int, int)>` 是 C++11 引入的**通用函数包装器**，它可以存储任何可调用对象（callable），包括：

- 普通函数指针（如 `bool(*)(int, int)`）
- lambda 表达式
- 仿函数（重载 `operator()` 的类对象）
- 绑定表达式（`std::bind` 的结果）

```cpp
#include <functional>

int main() {
    // 1. 带捕获的 lambda
    int threshold = 5;
    auto lambda = [threshold](int a) { return a > threshold; };
    std::function<bool(int)> f1 = lambda; // 正确存储

    // 2. 仿函数
    struct Functor {
        bool operator()(int a) const { return a > 3; }
    };
    Functor funcObj;
    std::function<bool(int)> f2 = funcObj; // 正确存储

    // 3. std::bind 结果
    auto bound = std::bind([](int a, int b) { return a > b; }, std::placeholders::_1, 5);
    std::function<bool(int)> f3 = bound; // 正确存储
}
```

为`std::function`创建类型别名有助于提高可读性：

```cpp
using ValidateFunctionRaw = bool(*)(int, int); // 指向原始函数指针的类型别名
using ValidateFunction = std::function<bool(int, int)>; // 指向std::function的类型别名
```

定义类型别名时，我们必须显式指定任何模板参数，因为没有初始值来推断模板参数。

> [!Warning]
> `std::function`只允许通过隐式解引用调用函数（例如`fcnPtr()`），而不允许显式解引用（例如`(*fcnPtr)()`）。

---
## 相互转换

当函数参数声明为 `std::function<bool(int, int)>` 时，传入 `bool(*)(int, int)` 类型的函数指针是完全合法的，因为函数指针会被隐式转换为 `std::function` 对象。例如：

```cpp
// 函数参数为 std::function
void validate(int x, int y, std::function<bool(int, int)> checker) {
    if (checker(x, y)) {
        // 验证通过
    }
}

int main() {
    // 传入函数指针（自动转换为 std::function）
    validate(3, 5, isGreater); 
    return 0;
}
```

反之，如果函数参数是原生函数指针 `bool(*)(int, int)`，则也可以传入 `std::function` 对象吗？**不能直接传入**，因为 `std::function` 不是函数指针类型，需要通过 `std::function::target` 方法提取内部的函数指针（但仅在存储的是函数指针时有效）：

```cpp
// 函数参数为原生函数指针
void validateRaw(int x, int y, bool(*checker)(int, int)) {
    if (checker(x, y)) {
        // 验证通过
    }
}

int main() {
    std::function<bool(int, int)> func = isGreater;
    // 错误：std::function 不能直接转换为函数指针
    // validateRaw(3, 5, func); 

    // 正确：提取内部函数指针（需确保存储的是函数指针）
    if (auto* rawPtr = func.target<bool(*)(int, int)>()) {
        validateRaw(3, 5, *rawPtr); 
    }
    return 0;
}
```