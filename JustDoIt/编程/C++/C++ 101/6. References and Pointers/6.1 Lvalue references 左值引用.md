
> [!Best practice]
> When defining a reference, place `&` next to the type (not the reference variableâ€™s name).

Modern C++ programmers tend to prefer attaching the ampersand to the type, as it makes clearer that the reference is part of the type information, not the identifier.

```cpp
// regular types
int        // a normal int type (not an reference)
int&       // an lvalue reference to an int object
double&    // an lvalue reference to a double object
const int& // an lvalue reference to a const int object
```

`&` in this context does not mean â€œaddress ofâ€, it means â€œlvalue reference toâ€.

---
## Non-const lvalue reference

å¦‚æœ non-const å·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šåˆ° const å·¦å€¼æˆ–å³å€¼ï¼Œé‚£ä¹ˆå°†èƒ½å¤Ÿé€šè¿‡å¼•ç”¨æ›´æ”¹è¿™äº›å€¼ï¼Œæ˜¾ç„¶ä¸åˆç†ï¼ï¼ï¼

> [!warning]
> C++ç¦æ­¢ non-const å·¦å€¼å¼•ç”¨åˆ° const å·¦å€¼æˆ–ç»‘å®šå³å€¼ã€‚

```cpp
int main()
{
    int x { 5 };
    int& ref { x };         // okay: non-const lvalue reference bound to a modifiable lvalue
	
    const int y { 5 };
    int& invalidRef { y };  // invalid: non-const lvalue reference can't bind to a non-modifiable lvalue
    int& invalidRef2 { 0 }; // invalid: non-const lvalue reference can't bind to an rvalue
	
    return 0;
}
```

---
## Lvalue reference to const

Lvalue references to const can bind to non-modifiable lvalues.

```cpp
#include <iostream>

int main()
{
    const int x { 5 };    // x is a non-modifiable lvalue
    const int& ref { x }; // okay: ref is a an lvalue reference to a const value

    std::cout << ref << '\n'; // okay: we can access the const object
    ref = 6;                  // error: we can not modify an object through a const reference

    return 0;
}
```

Lvalue references to const can also bind to modifiable lvalues.

```cpp
#include <iostream>

int main()
{
    int x { 5 };          // x is a modifiable lvalue
    const int& ref { x }; // okay: we can bind a const reference to a modifiable lvalue

    std::cout << ref << '\n'; // okay: we can access the object through our const reference
    ref = 7;                  // error: we can not modify an object through a const reference

    x = 6;                // okay: x is a modifiable lvalue, we can still modify it through the original identifier

    return 0;
}
```

Lvalue references to rvalue å¯ä»¥å»¶é•¿ç”Ÿå‘½å‘¨æœŸ

```cpp
#include <iostream>

int main()
{
    const int& ref { 5 }; // The temporary object holding value 5 has its lifetime extended to match ref

    std::cout << ref << '\n'; // Therefore, we can safely use it here

    return 0;
} // Both ref and the temporary object die here
```

ï¼ˆä»…å½“ const å¼•ç”¨ç›´æ¥ç»‘å®šåˆ°ä¸´æ—¶å˜é‡æ—¶æœ‰æ•ˆã€‚å‡½æ•°è¿”å›çš„ä¸´æ—¶å˜é‡ï¼ˆå³ä½¿æ˜¯ const å¼•ç”¨è¿”å›çš„ä¸´æ—¶å˜é‡ï¼‰ä¸å…·å¤‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿çš„æ¡ä»¶ï¼‰ã€‚

> [!summary]
> Lvalue references can only bind to modifiable lvalues.
> Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.

^518b80

---
## Donâ€˜t initializing an lvalue reference to const with a value of a different type

> [!warning]
> ç¡®ä¿å¼•ç”¨ç±»å‹å’Œå¯¹è±¡ç±»å‹å®Œå…¨åŒ¹é…ã€‚é¿å…ç”¨å¼•ç”¨ç»‘å®šä¸åŒç±»å‹çš„å€¼ã€‚

å½“ä½ å°è¯•å°†ä¸å¼•ç”¨ç±»å‹ä¸ç›¸åŒçš„å€¼ç»‘å®šåˆ°ä¸€ä¸ªÂ `const`Â å·¦å€¼å¼•ç”¨æ—¶ï¼Œç¼–è¯‘å™¨ä¼šåšä»€ä¹ˆï¼Ÿ

- **ç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼ˆtemporary objectï¼‰**ï¼Œè¿™ä¸ªä¸´æ—¶å¯¹è±¡çš„ç±»å‹ä¸å¼•ç”¨çš„ç±»å‹ç›¸åŒã€‚
- ç„¶åç”¨ä½ æä¾›çš„å€¼æ¥åˆå§‹åŒ–è¿™ä¸ªä¸´æ—¶å¯¹è±¡ã€‚
- æœ€åï¼Œ`const`Â å·¦å€¼å¼•ç”¨ç»‘å®šåˆ°è¿™ä¸ªä¸´æ—¶å¯¹è±¡ä¸Šã€‚

æˆ‘ä»¬é€šå¸¸å‡è®¾å¼•ç”¨ä¸å…¶ç»‘å®šçš„å¯¹è±¡å®Œå…¨ç›¸åŒâ€”â€”ä½†å½“å¼•ç”¨è¢«ç»‘å®šåˆ°å¯¹è±¡çš„ä¸´æ—¶å‰¯æœ¬ï¼Œè¿™ä¸€å‡è®¾å°±è¢«æ‰“ç ´äº†ï¼Œä»»ä½•åç»­å¯¹åŸå§‹å¯¹è±¡çš„ä¿®æ”¹éƒ½ä¸ä¼šè¢«å¼•ç”¨æ„ŸçŸ¥åˆ°ã€‚

```cpp
#include <iostream>

int main()
{
    short bombs { 1 };         // I can has bomb! (note: type is short)
	
    const int& you { bombs };  // You can has bomb too (note: type is int&)
    --bombs;                   // Bomb all gone
	
    if (you)                   // You still has?
    {
        std::cout << "Bombs away!  Goodbye, cruel world.\n"; // Para bailar la bomba ç‚¸å¼¹ğŸ’£çˆ†ç‚¸å•¦ğŸ’¥
    }
	
    return 0;
}
```

In the above example,Â `bombs`Â is aÂ `short`Â andÂ `you`Â is aÂ `const int&`. BecauseÂ `you`Â can only bind to anÂ `int`Â object, whenÂ `you`Â is initialized withÂ `bombs`, the compiler will implicitly convertÂ `bombs`Â to anÂ `int`, which results in the creation of a temporaryÂ `int`Â object (with valueÂ `1`).Â `you`Â ends up bound to this temporary object rather thanÂ `bombs`.

WhenÂ `bombs`Â is decremented,Â `you`Â is not affected because it is referencing a different object. So although we expectÂ `if (you)`Â to evaluate toÂ `false`, it actually evaluates toÂ `true`.

If you would stop blowing up the world, that would be great.

---
## References canâ€™t be reseated

`ref = y`Â doesnâ€™t changeÂ `ref`Â to now referenceÂ `y`. Rather, becauseÂ `ref`Â is an alias forÂ `x`.

```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 6 };

    int& ref { x }; // ref is now an alias for x

    ref = y; // assigns 6 (the value of y) to x (the object being referenced by ref)
    // The above line does NOT change ref into a reference to variable y!

    std::cout << x << '\n'; // user is expecting this to print 5

    return 0;
}
```

Perhaps surprisingly, this prints:

```
6
```

---
## References arenâ€™t objects

å› ä¸ºå¼•ç”¨ä¸æ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥å®ƒä»¬ä¸èƒ½åœ¨ä»»ä½•éœ€è¦å¯¹è±¡çš„åœ°æ–¹ä½¿ç”¨ã€‚

æ€è€ƒä¸€ä¸‹è¿™ç§æƒ…å†µï¼š

```cpp
int var{};
int& ref1{ var };  // an lvalue reference bound to var
int& ref2{ ref1 }; // an lvalue reference bound to var
```

BecauseÂ `ref2`Â (a reference) is initialized withÂ `ref1`Â (a reference), you might be tempted to conclude thatÂ `ref2`Â is a reference to a reference. It is not. 

BecauseÂ `ref1`Â is a reference toÂ `var`, when used in an expression (such as an initializer),Â `ref1`Â evaluates toÂ `var`. SoÂ `ref2`Â is just a normal lvalue reference bound toÂ `var`.

---
## ä¼ é€’å·¦å€¼å¼•ç”¨

```cpp
#include <iostream>

void printAddresses(int val, int& ref)
{
    std::cout << "The address of the value parameter is: " << &val << '\n';
    std::cout << "The address of the reference parameter is: " << &ref << '\n';   
}

int main()
{
    int x { 5 };
    std::cout << "The address of x is: " << &x << '\n';
    printAddresses(x, x);

    return 0;
}
```

æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ï¼š

å€¼å‚æ•°ï¼ˆvalue parameterï¼‰å…·æœ‰ä¸åŒçš„å†…å­˜åœ°å€ï¼Œè¿™æ„å‘³ç€å€¼å‚æ•°æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¯¹è±¡ã€‚ç”±äºå®ƒä»¬æ‹¥æœ‰ç‹¬ç«‹çš„å†…å­˜åœ°å€ï¼Œä¸ºäº†è®©å€¼å‚æ•°è·å¾—ä¸å®å‚ç›¸åŒçš„å€¼ï¼Œå¿…é¡»å°†å®å‚çš„å€¼å¤åˆ¶åˆ°å€¼å‚æ•°æŒæœ‰çš„å†…å­˜ç©ºé—´ä¸­ã€‚

å¦ä¸€æ–¹é¢ï¼Œå¼•ç”¨å‚æ•°ï¼ˆreference parameterï¼‰çš„åœ°å€ä¸å®å‚å®Œå…¨ä¸€è‡´ã€‚è¿™è¡¨æ˜å¼•ç”¨å‚æ•°è¢«å½“ä½œä¸å®å‚å®Œå…¨ç›¸åŒçš„å¯¹è±¡æ¥å¤„ç†â€”â€”å®ƒä»¬å…±äº«åŒä¸€å—å†…å­˜ç©ºé—´ã€‚

```
The address of x is: 0x7ffd16574de0
The address of the value parameter is: 0x7ffd16574de4
The address of the reference parameter is: 0x7ffd16574de0
```

---

å‡½æ•°å‚æ•°æ˜¯æ™®é€šå·¦å€¼å¼•ç”¨æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½ä¼ é€’ const å˜é‡æˆ–æ–‡å­—ï¼š

```cpp
#include <iostream>

void printValue(int& y) // y only accepts modifiable lvalues
{
    std::cout << y << '\n';
}

int main()
{
    int x { 5 };
    printValue(x); // ok: x is a modifiable lvalue

    const int z { 5 };
    printValue(z); // error: z is a non-modifiable lvalue

    printValue(5); // error: 5 is an rvalue

    return 0;
}
```

å°†å‡½æ•°å‚æ•°æ”¹æˆ const å·¦å€¼å¼•ç”¨æ„å‘³ç€å¯ä»¥ä¼ é€’ä»»æ„ç±»å‹å˜é‡ï¼ŒåŒ…æ‹¬æ™®é€šå˜é‡ã€const å˜é‡å’Œå­—é¢é‡ç­‰å³å€¼ï¼š([[6.1 Lvalue references å·¦å€¼å¼•ç”¨#^518b80]])

```cpp
#include <iostream>

void printRef(const int& y) // y is a const reference
{
    std::cout << y << '\n';
}

int main()
{
    int x { 5 };
    printRef(x);   // ok: x is a modifiable lvalue, y binds to x

    const int z { 5 };
    printRef(z);   // ok: z is a non-modifiable lvalue, y binds to z

    printRef(5);   // ok: 5 is rvalue literal, y binds to temporary int object

    return 0;
}
```

We can now answer these question of why we donâ€™t pass everything by reference:

- For objects that are cheap to copy, the cost of copying is similar to the cost of binding, but accessing the objects is faster and the compiler is likely to be able to optimize better.
- For objects that are expensive to copy, the cost of the copy dominates other performance considerations.

