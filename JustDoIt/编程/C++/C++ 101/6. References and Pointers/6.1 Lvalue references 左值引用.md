
> [!Best practice]
> When defining a reference, place `&` next to the type (not the reference variableâ€™s name).

ç°ä»£ C++ ç¨‹åºå‘˜å€¾å‘äºå°†`&`é™„åŠ åˆ°ç±»å‹æ—è¾¹ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥æ›´æ¸…æ¥šåœ°è¡¨æ˜å¼•ç”¨æ˜¯ç±»å‹ä¿¡æ¯çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯æ ‡è¯†ç¬¦ã€‚

```cpp
// regular types
int        // a normal int type (not an reference)
int&       // an lvalue reference to an int object
double&    // an lvalue reference to a double object
const int& // an lvalue reference to a const int object
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`&` does not mean â€œaddress ofâ€, it means â€œlvalue reference toâ€.

---
## non-const å·¦å€¼å¼•ç”¨

æŒ‡å¯¹ non-const çš„å·¦å€¼å¼•ç”¨ã€‚

å¦‚æœ non-const å·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šåˆ° const å·¦å€¼æˆ–å³å€¼ï¼Œé‚£ä¹ˆå°†èƒ½å¤Ÿé€šè¿‡å¼•ç”¨æ›´æ”¹è¿™äº›å€¼ï¼Œæ˜¾ç„¶ä¸åˆç†ï¼ï¼ï¼

> [!warning]
> C++ç¦æ­¢ non-const å·¦å€¼å¼•ç”¨åˆ° const å·¦å€¼æˆ–ç»‘å®šå³å€¼ã€‚

```cpp
int main()
{
    int x { 5 };
    int& ref { x };         // okay: non-const lvalue reference bound to a modifiable lvalue
	
    const int y { 5 };
    int& invalidRef { y };  // invalid: non-const lvalue reference can't bind to a non-modifiable lvalue
    int& invalidRef2 { 0 }; // invalid: non-const lvalue reference can't bind to an rvalue
	
    return 0;
}
```

---
## å¯¹ const çš„å·¦å€¼å¼•ç”¨

æŒ‡å¯¹ const çš„å·¦å€¼å¼•ç”¨ã€‚
- **`lvalue reference to const`**Â æŒ‡çš„æ˜¯Â `const T&`ï¼Œå³**å¯¹å¸¸é‡çš„å¼•ç”¨**ï¼Œå¼ºè°ƒè¢«å¼•ç”¨çš„å¯¹è±¡ä¸å¯ä¿®æ”¹ã€‚
- **å¸¸é‡å¼•ç”¨**ï¼ˆ`T& const`ï¼‰åœ¨ C++ ä¸­æ˜¯æ— æ•ˆè¯­æ³•ï¼Œå› ä¸ºå¼•ç”¨æœ¬èº«é»˜è®¤ä¸å¯å˜ã€‚

### Const å·¦å€¼å¼•ç”¨

Const å·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šåˆ°ä¸å¯ä¿®æ”¹çš„å·¦å€¼ã€‚

```cpp
#include <iostream>

int main()
{
    const int x { 5 };    // x is a non-modifiable lvalue
    const int& ref { x }; // okay: ref is a an lvalue reference to a const value

    std::cout << ref << '\n'; // okay: we can access the const object
    ref = 6;                  // error: we can not modify an object through a const reference

    return 0;
}
```

Const å·¦å€¼å¼•ç”¨ä¹Ÿå¯ä»¥ç»‘å®šåˆ°å¯ä¿®æ”¹çš„å·¦å€¼ã€‚

```cpp
#include <iostream>

int main()
{
    int x { 5 };          // x is a modifiable lvalue
    const int& ref { x }; // okay: we can bind a const reference to a modifiable lvalue

    std::cout << ref << '\n'; // okay: we can access the object through our const reference
    ref = 7;                  // error: we can not modify an object through a const reference
    
    x = 6;                // okay: x is a modifiable lvalue, we can still modify it through the original identifier

    return 0;
}
```

Const å·¦å€¼å¼•ç”¨ä¹Ÿå¯ä»¥ç»‘å®šåˆ°å³å€¼ã€‚å¯ä»¥å»¶é•¿ç”Ÿå‘½å‘¨æœŸã€‚

```cpp
#include <iostream>

int main()
{
    const int& ref { 5 }; // The temporary object holding value 5 has its lifetime extended to match ref

    std::cout << ref << '\n'; // Therefore, we can safely use it here

    return 0;
} // Both ref and the temporary object die here
```

ä»…å½“ const å¼•ç”¨ç›´æ¥ç»‘å®šåˆ°ä¸´æ—¶å˜é‡æ—¶æœ‰æ•ˆã€‚å‡½æ•°è¿”å›çš„ä¸´æ—¶å˜é‡ï¼ˆå³ä½¿æ˜¯ const å¼•ç”¨è¿”å›çš„ä¸´æ—¶å˜é‡ï¼‰ä¸å…·å¤‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿çš„æ¡ä»¶ã€‚

> [!summary]
> Lvalue references can only bind to modifiable lvalues.
> Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.

---
### ä¼ é€’å·¦å€¼å¼•ç”¨

```cpp
#include <iostream>

void printAddresses(int val, int& ref)
{
    std::cout << "The address of the value parameter is: " << &val << '\n';
    std::cout << "The address of the reference parameter is: " << &ref << '\n';   
}

int main()
{
    int x { 5 };
    std::cout << "The address of x is: " << &x << '\n';
    printAddresses(x, x);

    return 0;
}
```

æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ï¼š

å€¼å‚æ•°ï¼ˆvalue parameterï¼‰å…·æœ‰ä¸åŒçš„å†…å­˜åœ°å€ï¼Œè¿™æ„å‘³ç€å€¼å‚æ•°æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¯¹è±¡ã€‚ç”±äºå®ƒä»¬æ‹¥æœ‰ç‹¬ç«‹çš„å†…å­˜åœ°å€ï¼Œä¸ºäº†è®©å€¼å‚æ•°è·å¾—ä¸å®å‚ç›¸åŒçš„å€¼ï¼Œå¿…é¡»å°†å®å‚çš„å€¼å¤åˆ¶åˆ°å€¼å‚æ•°æŒæœ‰çš„å†…å­˜ç©ºé—´ä¸­ã€‚

å¦ä¸€æ–¹é¢ï¼Œå¼•ç”¨å‚æ•°ï¼ˆreference parameterï¼‰çš„åœ°å€ä¸å®å‚å®Œå…¨ä¸€è‡´ã€‚è¿™è¡¨æ˜å¼•ç”¨å‚æ•°è¢«å½“ä½œä¸å®å‚å®Œå…¨ç›¸åŒçš„å¯¹è±¡æ¥å¤„ç†â€”â€”å®ƒä»¬å…±äº«åŒä¸€å—å†…å­˜ç©ºé—´ã€‚

```
The address of x is: 0x7ffd16574de0
The address of the value parameter is: 0x7ffd16574de4
The address of the reference parameter is: 0x7ffd16574de0
```

---

å‡½æ•°å‚æ•°æ˜¯æ™®é€šå·¦å€¼å¼•ç”¨æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½ä¼ é€’ const å˜é‡æˆ–æ–‡å­—ï¼š

```cpp
#include <iostream>

void printValue(int& y) // y only accepts modifiable lvalues
{
    std::cout << y << '\n';
}

int main()
{
    int x { 5 };
    printValue(x); // ok: x is a modifiable lvalue

    const int z { 5 };
    printValue(z); // error: z is a non-modifiable lvalue

    printValue(5); // error: 5 is an rvalue

    return 0;
}
```

å°†å‡½æ•°å‚æ•°æ”¹æˆ const å·¦å€¼å¼•ç”¨æ„å‘³ç€å¯ä»¥ä¼ é€’ä»»æ„ç±»å‹å˜é‡ï¼ŒåŒ…æ‹¬æ™®é€šå˜é‡ã€const å˜é‡å’Œå­—é¢é‡ç­‰å³å€¼ï¼š

```cpp
#include <iostream>

void printRef(const int& y) // y is a const reference
{
    std::cout << y << '\n';
}

int main()
{
    int x { 5 };
    printRef(x);   // ok: x is a modifiable lvalue, y binds to x

    const int z { 5 };
    printRef(z);   // ok: z is a non-modifiable lvalue, y binds to z

    printRef(5);   // ok: 5 is rvalue literal, y binds to temporary int object

    return 0;
}
```

We can now answer these question of why we donâ€™t pass everything by reference:

- For objects that are cheap to copy, the cost of copying is similar to the cost of binding, but accessing the objects is faster and the compiler is likely to be able to optimize better.
- For objects that are expensive to copy, the cost of the copy dominates other performance considerations.

---
### ä¸ºä»€ä¹ˆConstå·¦å€¼å¼•ç”¨å¯ä»¥ç»‘å®šåˆ°å³å€¼ï¼Ÿ

å“ˆï¼C++ è¯­è¨€ç‰¹æ€§è®¾è®¡å¦‚æ­¤ã€‚

Â C++ ä¸­ï¼Œ**å¯¹ const çš„å¼•ç”¨ï¼ˆ`const T&`ï¼‰å¯ä»¥ç›´æ¥ç»‘å®šåˆ°å³å€¼**ï¼Œè¿™æ˜¯è¯­è¨€è®¾è®¡ä¸­ä¸ºäº†å…¼é¡¾çµæ´»æ€§ã€å®‰å…¨æ€§å’Œæ€§èƒ½è€Œåšå‡ºçš„ç‰¹æ®Šè§„å®šã€‚å…·ä½“åŸå› å¦‚ä¸‹ï¼š

**1. å³å€¼çš„ç‰¹æ€§ä¸å¼•ç”¨çš„é™åˆ¶**

- **å³å€¼**ï¼šé€šå¸¸æ˜¯ä¸´æ—¶å¯¹è±¡ï¼ˆå¦‚è¡¨è¾¾å¼ç»“æœÂ `3 + 4`ï¼‰ã€å­—é¢é‡ï¼ˆå¦‚Â `5`ï¼‰æˆ–å³å°†é”€æ¯çš„å¯¹è±¡ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸçŸ­æš‚ï¼Œä¸”æ— æ³•è¢«ä¿®æ”¹ï¼ˆæˆ–ä¿®æ”¹æ— æ„ä¹‰ï¼‰ã€‚
- **æ™®é€šå·¦å€¼å¼•ç”¨ï¼ˆ`T&`ï¼‰**ï¼šåªèƒ½ç»‘å®šåˆ°å¯ä¿®æ”¹çš„å·¦å€¼ï¼ˆå¦‚å˜é‡ï¼‰ï¼Œå› ä¸ºå®ƒçš„è®¾è®¡ç›®çš„æ˜¯ â€œé€šè¿‡å¼•ç”¨ä¿®æ”¹åŸå¯¹è±¡â€ã€‚å¦‚æœå…è®¸ç»‘å®šåˆ°å³å€¼ï¼Œå¯èƒ½å¯¼è‡´å¯¹ä¸´æ—¶å¯¹è±¡çš„ä¿®æ”¹ï¼ˆè€Œä¸´æ—¶å¯¹è±¡éšåä¼šé”€æ¯ï¼Œä¿®æ”¹æ— æ„ä¹‰ï¼‰ï¼Œå› æ­¤è¯­è¨€ç¦æ­¢è¿™ç§è¡Œä¸ºã€‚

 **2. å¯¹ const çš„å¼•ç”¨çš„ç‰¹æ®Šæ€§**

å¯¹ const çš„å¼•ç”¨ï¼ˆ`const T&`ï¼‰çš„æ ¸å¿ƒç‰¹æ€§æ˜¯ ==**â€œåªè¯»â€**==â€”â€” å®ƒåªèƒ½è®¿é—®å¯¹è±¡ï¼Œä¸èƒ½ä¿®æ”¹å¯¹è±¡ã€‚è¿™ä¸€ç‰¹æ€§ä½¿å…¶é€‚åˆç»‘å®šåˆ°å³å€¼ï¼ŒåŸå› å¦‚ä¸‹ï¼š

- **å®‰å…¨æ€§**ï¼šç”±äºæ— æ³•é€šè¿‡Â `const T&`Â ä¿®æ”¹å¯¹è±¡ï¼Œå³ä½¿ç»‘å®šåˆ°å³å€¼ï¼ˆä¸´æ—¶å¯¹è±¡ï¼‰ï¼Œä¹Ÿä¸ä¼šå‡ºç° â€œä¿®æ”¹ä¸´æ—¶å¯¹è±¡æ— æ„ä¹‰â€ çš„é—®é¢˜ã€‚
- **å®ç”¨æ€§**ï¼šå…è®¸ç»‘å®šåˆ°å³å€¼å¯ä»¥ç®€åŒ–ä»£ç ï¼Œé¿å…ä¸å¿…è¦çš„æ‹·è´ã€‚ä¾‹å¦‚ï¼š

    ```cpp
    void print(const int& x) {  // å¯ä»¥æ¥æ”¶å·¦å€¼æˆ–å³å€¼
        std::cout << x << '\n';
    }
    
    int main() {
        int a = 5;
        print(a);       // æ­£ç¡®ï¼šç»‘å®šåˆ°å·¦å€¼a
        print(3 + 4);   // æ­£ç¡®ï¼šç»‘å®šåˆ°å³å€¼ï¼ˆ7ï¼‰ï¼Œæ— éœ€æ‹·è´
        print(10);      // æ­£ç¡®ï¼šç»‘å®šåˆ°å³å€¼ï¼ˆå­—é¢é‡10ï¼‰
    }
    ```  
    
    å¦‚æœÂ `print`Â çš„å‚æ•°æ˜¯æ™®é€šå¼•ç”¨ï¼ˆ`int&`ï¼‰ï¼Œåˆ™æ— æ³•æ¥æ”¶Â `3 + 4`Â æˆ–Â `10`Â è¿™æ ·çš„å³å€¼ï¼Œå¿…é¡»å…ˆåˆ›å»ºå˜é‡å­˜å‚¨è¿™äº›å€¼ï¼Œæ—¢ç¹çåˆä½æ•ˆã€‚

**3. ä¸´æ—¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå»¶é•¿**

**4. è¯­è¨€è®¾è®¡çš„æƒè¡¡**

- å…è®¸Â `const T&`Â ç»‘å®šåˆ°å³å€¼ï¼Œæ—¢ä¿ç•™äº† â€œåªè¯»â€ çš„å®‰å…¨æ€§ï¼Œåˆæå‡äº†ä»£ç çš„çµæ´»æ€§ï¼ˆæ— éœ€ä¸ºå³å€¼å•ç‹¬å†™é‡è½½å‡½æ•°ï¼‰ï¼Œè¿˜å‡å°‘äº†ä¸å¿…è¦çš„æ‹·è´ï¼ˆç›´æ¥ç»‘å®šä¸´æ—¶å¯¹è±¡ï¼Œè€Œéå¤åˆ¶åˆ°å˜é‡å†å¼•ç”¨ï¼‰ã€‚
- åä¹‹ï¼Œå¦‚æœç¦æ­¢Â `const T&`Â ç»‘å®šåˆ°å³å€¼ï¼Œä¼šå¯¼è‡´å¤§é‡å†—ä½™ä»£ç ï¼ˆå¦‚ä¸ºå·¦å€¼å’Œå³å€¼åˆ†åˆ«è®¾è®¡å‡½æ•°ï¼‰ï¼Œè¿èƒŒ C++â€œé›¶æˆæœ¬æŠ½è±¡â€ çš„ç†å¿µã€‚

**æ€»ç»“**

å¯¹ const çš„å¼•ç”¨ï¼ˆ`const T&`ï¼‰ä¹‹æ‰€ä»¥èƒ½ç›´æ¥ç»‘å®šåˆ°å³å€¼ï¼Œæ˜¯å› ä¸ºï¼š
1. å®ƒçš„ â€œåªè¯»â€ ç‰¹æ€§ä¿è¯äº†ä¸ä¼šä¿®æ”¹å³å€¼ï¼ˆä¸´æ—¶å¯¹è±¡ï¼‰ï¼Œé¿å…äº†æ— æ„ä¹‰çš„æ“ä½œï¼›
2. è¯­è¨€é€šè¿‡å»¶é•¿ä¸´æ—¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œè§£å†³äº†å¼•ç”¨æ‚¬ç©ºçš„é—®é¢˜ï¼›
3. è¿™ç§è®¾è®¡å¤§å¹…æå‡äº†ä»£ç çš„çµæ´»æ€§ï¼Œå…è®¸å‡½æ•°ç»Ÿä¸€æ¥æ”¶å·¦å€¼å’Œå³å€¼ï¼ŒåŒæ—¶å‡å°‘æ‹·è´å¼€é”€ã€‚

---
### é¿å…ç»™Constå·¦å€¼å¼•ç”¨ç»‘å®šéåŒç±»å‹å€¼

å½“ä½ å°è¯•å°†ä¸å¼•ç”¨ç±»å‹ä¸ç›¸åŒçš„å€¼ç»‘å®šåˆ°ä¸€ä¸ªÂ `const`Â å·¦å€¼å¼•ç”¨æ—¶ï¼Œç¼–è¯‘å™¨ä¼šåšä»€ä¹ˆï¼Ÿ

- **ç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼ˆtemporary objectï¼‰**ï¼Œè¿™ä¸ªä¸´æ—¶å¯¹è±¡çš„ç±»å‹ä¸å¼•ç”¨çš„ç±»å‹ç›¸åŒã€‚
- ç„¶åç”¨ä½ æä¾›çš„å€¼æ¥åˆå§‹åŒ–è¿™ä¸ªä¸´æ—¶å¯¹è±¡ã€‚
- æœ€åï¼Œ`const`Â å·¦å€¼å¼•ç”¨ç»‘å®šåˆ°è¿™ä¸ªä¸´æ—¶å¯¹è±¡ä¸Šã€‚

æˆ‘ä»¬é€šå¸¸å‡è®¾å¼•ç”¨ä¸å…¶ç»‘å®šçš„å¯¹è±¡å®Œå…¨ç›¸åŒâ€”â€”ä½†å½“å¼•ç”¨è¢«ç»‘å®šåˆ°å¯¹è±¡çš„ä¸´æ—¶å‰¯æœ¬ï¼Œè¿™ä¸€å‡è®¾å°±è¢«æ‰“ç ´äº†ï¼Œä»»ä½•åç»­å¯¹åŸå§‹å¯¹è±¡çš„ä¿®æ”¹éƒ½ä¸ä¼šè¢«å¼•ç”¨æ„ŸçŸ¥åˆ°ã€‚

```cpp
#include <iostream>

int main()
{
    short bombs { 1 };         // I can has bomb! (note: type is short)
	
    const int& you { bombs };  // You can has bomb too (note: type is int&)
    --bombs;                   // Bomb all gone
	
    if (you)                   // You still has?
    {
        std::cout << "Bombs away!  Goodbye, cruel world.\n";
        // Para bailar la bomba ç‚¸å¼¹ğŸ’£çˆ†ç‚¸å•¦ğŸ’¥
    }
	
    return 0;
}
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ`bombs`Â æ˜¯ä¸€ä¸ªÂ `short`Â ç±»å‹ï¼Œè€ŒÂ `you`Â æ˜¯ä¸€ä¸ªÂ `const int&`ã€‚
ç”±äºÂ `you` åªèƒ½ç»‘å®šåˆ°Â `int`Â ç±»å‹çš„å¯¹è±¡ï¼Œå½“ç”¨Â `bombs`Â åˆå§‹åŒ–Â `you`Â æ—¶ï¼Œç¼–è¯‘å™¨ä¼šéšå¼åœ°å°†Â `bombs`Â è½¬æ¢ä¸ºÂ `int`Â ç±»å‹ï¼Œè¿™ä¼šå¯¼è‡´åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„Â `int`Â å¯¹è±¡ï¼ˆå€¼ä¸º 1ï¼‰ã€‚æœ€ç»ˆï¼Œ`you`Â ç»‘å®šçš„æ˜¯è¿™ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œè€ŒéÂ `bombs`Â æœ¬èº«ã€‚

å½“Â `bombs`Â è¢«é€’å‡æ—¶ï¼Œ`you`Â ä¸ä¼šå—åˆ°å½±å“ï¼Œå› ä¸ºå®ƒå¼•ç”¨çš„æ˜¯å¦ä¸€ä¸ªå¯¹è±¡ã€‚å› æ­¤ï¼Œå°½ç®¡æˆ‘ä»¬é¢„æœŸÂ `if (you)`Â çš„åˆ¤æ–­ç»“æœä¸ºÂ `false`ï¼Œä½†å®é™…ä¸Šå®ƒçš„ç»“æœä¸ºÂ `true`ã€‚

> [!warning]
> é¿å…ç”¨å¼•ç”¨ç»‘å®šä¸åŒç±»å‹çš„å€¼ï¼

---
## å¼•ç”¨æ— æ³•è¢«é‡æ–°ç»‘å®š

References canâ€™t be reseated. ä¸€æ—¦å¼•ç”¨åœ¨åˆå§‹åŒ–æ—¶ç»‘å®šåˆ°æŸä¸ªå¯¹è±¡ï¼Œå°±**ä¸èƒ½å†æ”¹å˜ç»‘å®šå…³ç³»**ï¼Œæ— æ³•è®©å®ƒè½¬è€Œå¼•ç”¨å¦ä¸€ä¸ªå¯¹è±¡ã€‚

`ref = y`Â å¹¶ä¸ä¼šè®©Â `ref`Â è½¬è€Œå¼•ç”¨Â `y`ã€‚ç›¸åï¼Œå› ä¸ºÂ `ref`Â æ˜¯Â `x`Â çš„åˆ«åï¼ˆå¼•ç”¨ä¸€æ—¦ç»‘å®šåˆ°æŸä¸ªå¯¹è±¡ï¼Œå°±å§‹ç»ˆæ˜¯è¯¥å¯¹è±¡çš„ â€œåˆ«åâ€ï¼‰ï¼Œæ‰€ä»¥è¿™ä¸ªæ“ä½œå®é™…ä¸Šæ˜¯æŠŠÂ `y`Â çš„å€¼èµ‹ç»™äº†Â `x`ã€‚

```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 6 };

    int& ref { x }; // ref is now an alias for x

    ref = y; // assigns 6 (the value of y) to x (the object being referenced by ref)
    // The above line does NOT change ref into a reference to variable y!

    std::cout << x << '\n'; // user is expecting this to print 5

    return 0;
}
```

```
6
```

---
## å¼•ç”¨ä¸æ˜¯å¯¹è±¡

å› ä¸ºå¼•ç”¨ä¸æ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥å®ƒä»¬ä¸èƒ½åœ¨ä»»ä½•éœ€è¦å¯¹è±¡çš„åœ°æ–¹ä½¿ç”¨ã€‚

æ€è€ƒä¸€ä¸‹è¿™ç§æƒ…å†µï¼š

```cpp
int var{};
int& ref1{ var };  // an lvalue reference bound to var
int& ref2{ ref1 }; // an lvalue reference bound to var
```

å› ä¸ºÂ `ref2`ï¼ˆä¸€ä¸ªå¼•ç”¨ï¼‰æ˜¯ç”¨Â `ref1`ï¼ˆå¦ä¸€ä¸ªå¼•ç”¨ï¼‰åˆå§‹åŒ–çš„ï¼Œä½ å¯èƒ½ä¼šè¯¯ä»¥ä¸ºÂ `ref2`Â æ˜¯ â€œå¼•ç”¨çš„å¼•ç”¨â€ã€‚ä½†äº‹å®å¹¶éå¦‚æ­¤ã€‚

ç”±äºÂ `ref1`Â æ˜¯Â `var`Â çš„å¼•ç”¨ï¼Œå½“å®ƒåœ¨è¡¨è¾¾å¼ä¸­ä½¿ç”¨æ—¶ï¼ˆæ¯”å¦‚ä½œä¸ºåˆå§‹åŒ–å™¨ï¼‰ï¼Œ`ref1`Â ä¼šè¢«æ±‚å€¼ä¸ºÂ `var`Â æœ¬èº«ã€‚å› æ­¤ï¼Œ`ref2`Â åªæ˜¯ä¸€ä¸ªç»‘å®šåˆ°Â `var`Â çš„æ™®é€šå·¦å€¼å¼•ç”¨ã€‚

---
