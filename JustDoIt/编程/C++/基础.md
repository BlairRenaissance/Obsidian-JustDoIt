# Compiling your source code
## Compiler

In order to compile a C++ program, we use a C++ compiler. The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important tasks:

1. First, it checks your code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.

2. Second, it translates your C++ source code into a machine language file called an ***object file***. Object files are typically named _name.o_ or _name.obj_, where _name_ is the same name as the .cpp file it was produced from.

![](https://www.learncpp.com/images/CppTutorial/Chapter0/CompileSource-min.png?ezimgfmt=rs:421x161/rscb2/ng:webp/ngcb2)


## Linker

After the compiler creates one or more object files, then another program called the ***linker*** kicks in. The job of the linker is three fold:

![](https://www.learncpp.com/images/CppTutorial/Chapter0/LinkingObjects-min.png?ezimgfmt=rs:441x271/rscb2/ng:webp/ngcb2)

1. First, to take all the object files generated by the compiler and combine them into a single executable program.

2. Second, in addition to being able to link object files, the linker also is capable of linking library files. A ***library file*** is a collection of precompiled code that has been “packaged up” for reuse in other programs. (etc.  C++ Standard Library STL)

3. Third, the linker makes sure all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.

Once the linker is finished linking all the object files and libraries (assuming all goes well), you will have an executable file that you can then run!


## Preprocessor 预处理器

When you compile your project, you might expect that the compiler compiles each code file exactly as you’ve written it. This actually isn’t the case.

在编译之前，每个代码（.cpp）文件都会经历一个预处理阶段。在这个阶段，一个称为预处理器的程序会对代码文件的文本进行各种更改。预处理器实际上并不会修改原始的代码文件，而是通过在内存中临时进行更改或使用临时文件来完成所有预处理所需的更改。

在历史上，预处理器是编译器的一个单独程序，但在现代编译器中，预处理器可能被直接构建到编译器本身中。

预处理器所做的大部分工作都是相当无趣的。例如，它删除注释，并确保每个代码文件以换行符结尾。然而，预处理器确实有一个非常重要的作用：它处理include和define指令。

When the preprocessor has finished processing a code file, the result is called a translation unit. This translation unit is what is then compiled by the compiler.


# Data Types

## Unsigned integer

优点：
1. 在进行位操作时，首选使用无符号数。在某些算法（如加密和随机数生成）中需要定义明确的环绕行为时非常有用。
2. 其次，在某些情况下，无法避免地需要使用无符号数，主要涉及数组索引。

缺点：Unsigned integer overflow
What happens if we try to store the number `280` (which requires 9 bits to represent) in a 1-byte (8-bit) unsigned integer? The answer is overflow.If an unsigned value is out of range, it is divided by one greater than the largest number of the type, and only the remainder kept. The number `280` is too big to fit in our 1-byte range of 0 to 255. 1 greater than the largest number of the type is 256. Therefore, we divide 280 by 256, getting 1 remainder 24. The remainder of 24 is what is stored.

Let’s take a look at this using 2-byte shorts:
```cpp
#include <iostream>

int main()
{
    unsigned short x{ 65535 }; // largest 16-bit unsigned value possible
    std::cout << "x was: " << x << '\n';

    x = 65536; 
    std::cout << "x is now: " << x << '\n';

    x = 65537; 
    std::cout << "x is now: " << x << '\n';

    return 0;
}
```

```
x was: 65535
x is now: 0
x is now: 1
```

It’s possible to wrap around the other direction as well. 0 is representable in a 2-byte unsigned integer, so that’s fine. -1 is not representable, so it wraps around to the top of the range, producing the value 65535. -2 wraps around to 65534. And so forth.
```cpp
#include <iostream>

int main()
{
    unsigned short x{ 0 }; // smallest 2-byte unsigned value possible
    std::cout << "x was: " << x << '\n';

    x = -1; // -1 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    x = -2; // -2 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    return 0;
}
```

```
x was: 0
x is now: 65535
x is now: 65534
```

在电脑游戏《文明》中，甘地经常是第一个使用核武器的人，这似乎与他预期的被动本性相反。玩家有一个理论，甘地的侵略性设置最初设置为1，但如果他选择民主政府，他将获得-2的侵略性修正值（将他当前的侵略性值降低2）。这会让他的攻击力溢出到255，让他的攻击力达到最大！然而，最近席德梅尔（游戏作者）澄清事实并非如此。

 **⚠️注意**
 
- 慎用 The 8-bit fixed-width integer types，因为8-bit int 通常被视为字符而不是整数值（因系统而异）。
	```cpp
	#include <cstdint>
	#include <iostream>

	int main()
	{
	    std::cout << "Enter a number between 0 and 127: ";
	    std::int8_t myint{};
	    std::cin >> myint;

	    std::cout << "You entered: " << static_cast<int>(myint) << '\n';
	
	    return 0;
	}
	```
	
	A sample run of this program:
	```
	Enter a number between 0 and 127: 35
	You entered: 51
	```

	Here’s what’s happening. When `std::int8_t` is treated as a char, the input routines interpret our input as a sequence of characters, not as an integer. So when we enter `35`, we’re actually entering two chars, `'3'` and `'5'`. Because a char object can only hold one character, the `'3'` is extracted (the `'5'` is left in the input stream for possible extraction later). Because the char `'3'` has ASCII code point 51, the value `51` is stored in `myint`, which we then print later as an int.

## std::size_t

std::size_t is defined as an unsigned integral type, and it is typically used to represent the size or length of objects.

Much like an integer can vary in size depending on the system, `std::size_t` also varies in size. `std::size_t` is guaranteed to be unsigned and at least 16 bits, but on most systems will be equivalent to the address-width of the application. That is, for 32-bit applications, `std::size_t` will typically be a 32-bit unsigned integer, and for a 64-bit application, `std::size_t` will typically be a 64-bit unsigned integer.



# 容器

## Vector

[C++中的vector容器（保姆级讲解）](https://cloud.tencent.com/developer/article/2168389)
# Type Conversion 类型转换

## Type deduction for string literals

For historical reasons, string literals in C++ have a strange type. Therefore, the following probably won’t work as expected:

```cpp
auto s { "Hello, world" }; // s will be type const char*, not std::string
```

If you want the type deduced from a string literal to be `std::string` or `std::string_view`, you’ll need to use the `s` or `sv` literal suffixes.

```cpp
#include <string>
#include <string_view>

int main()
{
    using namespace std::literals; // easiest way to access the s and sv suffixes

    auto s1 { "goo"s };  // "goo"s is a std::string literal, so s1 will be deduced as a std::string
    auto s2 { "moo"sv }; // "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view

    return 0;
}
```


## Type deduction drops const / constexpr qualifiers

In most cases, type deduction will drop the `const` or `constexpr` qualifier from deduced types. For example:
```cpp
int main()
{
    const int x { 5 }; // x has type const int
    auto y { x };      // y will be type int (const is dropped)

    return 0;
}
```
In the above example, `x` has type `const int`, but when deducing a type for variable `y` using `x` as the initializer, type deduction deduces the type as `int`, not `const int`.

If you want a deduced type to be const or constexpr, you must supply the const or constexpr yourself. To do so, simply use the `const` or `constexpr` keyword in conjunction with the `auto` keyword:
```cpp
int main()
{
    const int x { 5 };  // x has type const int (compile-time const)
    auto y { x };       // y will be type int (const is dropped)

    constexpr auto z { x }; // z will be type constexpr int 

    return 0;
}
```
In this example, the type deduced from `x` will be `int` (the `const` is dropped), but because we’ve re-added a `constexpr` qualifier during the definition of variable `z`, variable `z` will be a `constexpr int`.


## Type deduction for functions

When using an `auto` return type, all return statements within the function must return values of the same type, otherwise an error will result. For example:
```cpp
auto someFcn(bool b)
{
    if (b)
        return 5; // return type int
    else
        return 6.7; // return type double
}
```
In the above function, the two return statements return values of different types, so the compiler will give an error.

⚠️ Favor explicit return types over function return type deduction for normal functions.

**Trailing return type syntax**

The `auto` keyword can also be used to declare functions using a trailing return syntax, where the return type is specified after the rest of the function prototype.

Consider the following function:
```cpp
int add(int x, int y)
{
  return (x + y);
}
```
Using the trailing return syntax, this could be equivalently written as:
```cpp
auto add(int x, int y) -> int
{
  return (x + y);
}
```
In this case, `auto` does not perform type deduction -- it is just part of the syntax to use a trailing return type.

Why would you want to use this? The trailing return syntax is required for some advanced features of C++, such as ***lambdas*** (which we cover in lesson [12.7 -- Introduction to lambdas (anonymous functions)](https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/)).

# Function overload 重载


How overloaded functions are differentiated:

|Function property|Used for differentiation|Notes|
|---|---|---|
|Number of parameters|Yes||
|Type of parameters|Yes|Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses.|
|Return type|No||

Note that a function’s return type is not used to differentiate overloaded functions. We’ll discuss this more in a bit.


For ***member functions***, additional function-level qualifiers are also considered:

|Function-level qualifier|Used for overloading|
|---|---|
|const or volatile|Yes|
|Ref-qualifiers|Yes|

As an example, a const member function can be differentiated from an otherwise identical non-const member function (even if they share the same set of parameters).

⚠️：If a parameter is given a default argument, all subsequent parameters (to the right) must also be given default arguments.



# Function template 泛型

## Template parameter declaration

```cpp
template <typename T> // this is the template parameter declaration
T max(T x, T y) // this is the function template definition for max<T>
{
    return (x < y) ? y : x;
}
```

There is no difference between the `typename` and `class` keywords in this context. You will often see people use the `class` keyword since it was introduced into the language earlier. However, we prefer the newer `typename` keyword, because it makes it clearer that the type template parameter can be replaced by any type (such as a fundamental type), not just class types.


## Functions templates with multiple template type parameters

```cpp
#include <iostream>

template <typename T, typename U> // We're using two template type parameters named T and U
T max(T x, U y) // x can resolve to type T, and y can resolve to type U
{
    return (x < y) ? y : x; // uh oh, we have a narrowing conversion problem here
}
```

## Abbreviated function templates (C++20)

C++20 introduces a new use of the `auto` keyword: When the `auto` keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each auto parameter becoming an independent template type parameter. This method for creating a function template is called an abbreviated function template.

For example:
```cpp
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
```

is shorthand in C++20 for the following:
```cpp
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
```

There isn’t a concise way to use abbreviated function templates when you want more than one auto parameter to be the same type. That is, there isn’t an easy abbreviated function template for something like this:
```cpp
template <typename T>
auto max(T x, T y) // two parameters of the same type
{
    return (x < y) ? y : x;
}
```


## Non-type template parameters

A **non-type template parameter** is a template parameter with a fixed type that serves as a placeholder for a constexpr value passed in as a template argument.

A non-type template parameter can be any of the following types:

- An integral type
- An enumeration type
- `std::nullptr_t`
- A floating point type (since C++20)
- A pointer or reference to an object
- A pointer or reference to a function
- A pointer or reference to a member function
- A literal class type (since C++20)

Here’s a simple example that uses an int non-type template parameter:
```cpp
#include <iostream>

template <int N> // declare a non-type template parameter of type int named N
void print()
{
    std::cout << N << '\n'; // use value of N here
}

int main()
{
    print<5>(); // 5 is our non-type template argument

    return 0;
}
```

This example prints:
```
5
```


# Assert 断言


如果程序以 `std::exit` 的方式中断了，那么所有的调用堆栈与调试信息都会丢失。以 `std::abort` 方式中断更好，可以从中断的位置开始debugging。断言能够使程序以`std::abort` 方式中断。

## assert

An assertion is an expression that will be true unless there is a bug in the program. If the expression evaluates to `true`, the assertion statement does nothing. If the conditional expression evaluates to `false`, an error message is displayed and the program is terminated (via `std::abort`). This error message typically contains the expression that failed as text, along with the name of the code file and the line number of the assertion. 

In C++, runtime assertions are implemented via the assert preprocessor macro (断言预处理器宏), which lives in the `<cassert>` header. 

```
#include <cassert> // for assert()
#include <cmath> // for std::sqrt
#include <iostream>

double calculateTime(double initialHeight, double gravity)
{
  assert(gravity > 0.0); // Assert

  if (initialHeight <= 0.0) return 0.0;

  return std::sqrt((2.0 * initialHeight) / gravity);
}
```


## static_assert

C++也提供了另一种在编译期就进行检查的静态断言`static_assert`。A static_assert is an assertion that is checked at compile-time rather than at runtime, with a failing `static_assert` causing a compile error. Unlike assert, which is declared in the `<cassert>` header, static_assert is a keyword, so no header needs to be included to use it.

A `static_assert` takes the following form:
```
static_assert(condition, diagnostic_message)
```

If the condition is not true, the diagnostic message is printed. Here’s an example of using static_assert to ensure types have a certain size:

On the author’s machine, when compiled, the compiler errors:
```
1>c:\consoleapplication1\main.cpp(19): error C2338: long must be 8 bytes
```

A few useful notes about `static_assert`:

- Because `static_assert` is evaluated by the compiler, the condition must be a constant expression.
- `static_assert` can be placed anywhere in the code file (even in the global namespace).
- `static_assert` is not compiled out in release builds.

Prior to C++17, the diagnostic message must be supplied as the second parameter. Since C++17, providing a diagnostic message is optional.


## ⚠️注意

1. 一般情况下，assert仅在debug模式下生效。
	`assert` 宏在每一次检查中都有一些性能消耗。因此，开发者们更偏向于仅在debug模式下使用断言。为此，C++制定了一种关闭断言的方案：
	
    ***If the macro `NDEBUG` is defined, the assert macro gets disabled.*** 
    
    一些编译器会在release模式中默认定义`NDEBUG`，比如 Visual Studio中the following preprocessor definitions are set at the project level: `WIN32;NDEBUG;_CONSOLE`. 如果希望在release模式下使用断言，需要从设置中移除`NDEBUG`。

2. 谨防内存泄漏。
	断言使用的 `abort()` function 会立刻终止程序。Because of this, asserts should be used only in cases where corruption isn’t likely to occur if the program terminates unexpectedly.



