
#### ***1. 基类没有定义虚析构函数***

在 C++ 中，我们可以使用基类指针来指向派生类对象。例如：

```cpp
CPPCopyclass Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() {}
};

int main() {
    Base* ptr = new Derived();
    delete ptr;
    return 0;
}
```

在上面的示例中，我们定义了一个基类 `Base` 和一个派生类 `Derived`，然后在 `main` 函数中，创建了一个 `Derived` 类型的对象，并使用基类指针 `ptr` 指向它。最后，我们通过 `delete` 关键字删除了 `ptr`，这会调用 `Base` 类的析构函数。由于 `Base` 类的析构函数是虚函数，因此会先调用 `Derived` 类的析构函数，然后再调用 `Base` 类的析构函数。

这种使用基类指针来指向派生类对象的方式是多态的一种体现，它允许我们在运行时动态地确定对象的类型，并调用正确的方法。但是，如果基类没有定义虚析构函数，那么在删除基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，这可能会导致派生类的资源没有被正确地释放，从而产生内存泄漏或资源泄漏等问题。

因此，使用一个指向派生类对象的基类指针来删除对象，需要确保基类定义了虚析构函数，以确保在删除对象时会调用正确的析构函数。

