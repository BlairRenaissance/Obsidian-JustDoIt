
## 头文件

**1. 头文件保护**

所有头文件都应该使用 `#define` 或 `#pragma once` 来防止头文件被多重包含。其中`#define`的命名格式当是： `<PROJECT>_<PATH>_<FILE>_H_`。

**2. 头文件应该自足**

**3. 避免使用前置声明**

尽可能地避免使用前置声明。使用 `#include` 包含需要的头文件。
前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。极端情况下，用前置声明代替 `include` 甚至都会不知情的情况下改变代码的含义：
```
// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
```

如果 `#include` 被 `B` 和 `D` 的前置声明替代，我们只有B和D的前置声明，编译器无法确定D是B的派生类，因为它没有完整的定义。因此，编译器会选择匹配参数类型更精确的函数，即f(void*)。`test()` 就会调用 `f(void*)`：
```
// bad_user.cc:
struct B;
struct D;
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(void*)
```

**4. 内联函数不包循环**

只有当函数只有 10 行甚至更少时才将其定义为内联函数。

谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！

另一个实用的经验准则：内联那些包含循环或 `switch` 语句的函数常常是得不偿失 (除非在大多数情况下，这些循环或 `switch` 语句从不被执行)。

重要的是知道，有些函数即使声明为内联函数，也不一定总会被编译器内联。例如：虚函数和递归函数一般不会被正常内联。

**5.  `#include` 的路径及顺序**

使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：`本文件的相关头文件`、`C 库`、`C++ 库`、`其他库的 .h`、`本项目内的 .h`。


## 作用域

**1. 命名空间**

命名空间中注意不要使用缩进。

禁止在头文件的全局作用域中使用using namespace foo，会污染命名空间。

不要在命名空间 `std` 内声明任何东西，包括标准库的类前置声明。在 `std` 命名空间声明实体是未定义的行为，会导致不可移植。正确的做法是包含对应的头文件来使用标准库的实体，例如 `#include <iostream>`，而不是在 `std` 命名空间内进行前置声明。这样可以确保代码的可移植性。

**2. 局部变量**

应使用初始化的方式替代声明再赋值。

**3. 静态和全局变量**

静态和全局变量必须是可平凡析构的。基本类型（如指针和 `int`）及其数组都是可平凡析构的。请注意，标有 `constexpr` 的变量是都可平凡析构的。

具有静态存储期的对象从其初始化到程序结束一直存在。这些对象包括命名空间作用域的变量（“全局变量”），类的静态成员变量或函数内的静态局部变量。

使用动态初始化或具有非平凡析构函数的全局变量和静态变量容易导致难以发现的错误——不同的翻译单元之间动态初始化没有标准的顺序保证，析构也一样。

**4. 全局函数**

尽量不要用裸的全局函数。 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。

## 类

**1. 构造函数**

不要在构造函数中使用虚函数。

- 如果在构造函数内调用了自身的虚函数，这类调用是不会重定向到派生类的虚函数实现的。即使当前没有派生类化实现，将来仍是隐患。
- 在没有使程序崩溃或者使用异常（因为已经被禁用了）的条件下，构造函数很难上报错误。
- 如果执行失败，会返回一个初始化失败的对象，这个对象有可能进入不正常的状态，常常需要使用 `bool IsValid()` 或类似的机制才能检查出来
- 构造函数的地址是无法被取得的，因此，由构造函数完成的工作是无法以简单的方式交给其他线程的。
- 如果有人创造该类型的全局变量，构造函数将先 main() 一步被调用，这有可能破坏构造函数中隐含的假设条件。

**2. 隐式类型转换**

`explicit` 关键字可以用于构造函数或（在 C++11 引入）类型转换运算符，以保证只有当目的类型在调用点被显式写明时才能进行类型转换，例如使用 `cast`。

在类型定义中，类型转换运算符和单参数构造函数都应当用 `explicit` 进行标记。一个例外是，拷贝和移动构造函数不应当被标记为 `explicit`， 因为它们并不执行类型转换。

**3. 可拷贝类型和可移动类型**

让你的自定义类型支持拷贝/移动。否则，把隐式产生的拷贝和移动函数禁用。

为基类提供拷贝 / 赋值操作是有害的，因为在使用它们时会造成[对象切割](https://en.wikipedia.org/wiki/Object_slicing) 。

由于存在对象切割的风险，不要为任何有可能有派生类的对象提供赋值操作或者拷贝/移动构造函数（当然也不要继承有这样的成员函数的类）。
- 对象切割（object slicing）是指将派生类对象赋值给基类对象或进行基类对象的拷贝/移动构造时，派生类对象的派生部分被丢弃的情况。这可能导致数据丢失和行为不一致的问题。
- 为了避免对象切割的风险，建议不要为任何有可能有派生类的对象提供赋值操作或拷贝/移动构造函数。这意味着不要在基类中定义这些成员函数，也不要从其他类继承这些成员函数。

如果你的基类需要可复制属性，请提供一个 `public virtual Clone()` 和一个 `protected` 的拷贝构造函数以供派生类实现。

1. `Clone()` 函数：这是一个公共的虚拟函数，用于创建并返回当前对象的副本。每个派生类都可以根据自己的特定需求实现 `Clone()` 函数。通过在基类中定义 `Clone()` 函数，并在派生类中进行实现，可以确保每个派生类都能够正确地创建自己的副本。
```
class MyBaseClass { 
public: 
    virtual MyBaseClass* Clone() const = 0; 
}; 

class MyDerivedClass : public MyBaseClass { 
public: 
    MyDerivedClass* Clone() const override { 
        return new MyDerivedClass(*this); 
    } 
};
```

2. 受保护的拷贝构造函数：这是一个受保护的构造函数，只能被派生类访问。它用于在派生类的 `Clone()` 函数中进行对象的复制。通过将拷贝构造函数声明为受保护的，可以确保只有派生类能够访问和使用该构造函数，从而在派生类的 `Clone()` 函数中进行对象的复制。
```
class MyBaseClass { 
protected:     
	MyBaseClass(const MyBaseClass& other) {
		// 进行对象的复制     
	} 
};
```

这样的设计可以避免对象切割的风险，并确保在需要复制对象时，每个派生类都能够正确地复制自己的数据。

**4. 继承**

所有继承必须是 `public` 的。如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式。

不要过度使用实现继承。组合常常更合适一些，尽量做到只在"是一个"的情况下使用继承：如果 `Bar` 的确"是一个" `Foo`，`Bar` 才能继承 `Foo`。

必要的话，析构函数声明为 `virtual`。如果你的类有虚函数，则析构函数也应该为虚函数。

对于可能被派生类访问的成员函数，不要过度使用 `protected` 关键字。注意，数据成员都必须是`私有的`。

对于覆盖基类虚函数或虚析构函数的，使用 `override` 或（较不常用的）`final` 关键字显式地进行标记。标记为 `override` 或 `final` 的函数，如果不是对基类虚函数的覆盖，编译会报错，这有助于捕获常见的错误。如果省略这些关键字，代码阅读者不得不检查所有基类，以判断该函数是否是虚函数。