




---
### Q&A

**`condition.wait` 里的那个 lambda 是干嘛的？**

```C++
cv.wait(lock, [this]{ return stop || !tasks.empty(); });
```

- **作用**：**“门卫”**。用于防止 **“虚假唤醒 (Spurious Wakeup)”**。
- **原理**：操作系统偶尔会抽风，或者有信号干扰，导致线程在没人 `notify` 的情况下莫名其妙醒来。
- **逻辑**：如果没有这个 Lambda，线程一醒来就去取任务，结果队列是空的，直接崩盘。有了它，线程醒来后会先问门卫：“真的有活吗？”。如果门卫说“假的”，线程会立刻**回笼觉**。

---
**`wait` 的 Lambda 返回 `false` 代表什么？**

- **误区**：以为 `false` 代表“不用等了，往下走”。
- **真相**：恰恰相反！`true` = 条件**满足** = 放行。`false` = 条件**不满足** = 继续等。

---
**`condition.wait` 的lock为什么要用 `std::unique_lock` 而不是 `lock_guard`？**

- **区别**：    
    - `std::lock_guard`：是死板的“RAII 保镖”，在构造中上锁、在析构中解锁，**中途无法手动解锁**。
    - `std::unique_lock`：是灵活的“遥控锁”，允许 `wait` 函数在内部**随时解锁和重新加锁**。
    
- 原因：`condition_variable::wait()` 函数有一个硬性要求：线程在进入睡眠前，必须解锁（否则它睡着了还占着位置，别人没法加任务）；线程醒来后，又必须重新加锁（为了安全地检查队列）。

---
**`condition.notify_one()` vs `condition.notify_all()` 什么时候用？**

- **`notify_one()`**：**发任务时用**。
    - 因为一个任务只能被一个人领走。叫醒所有人会导致 **“惊群效应 (Thundering Herd)”**——大家全醒了，抢作一团，结果只有一个人抢到，其他人骂骂咧咧回去接着睡，严重浪费 CPU。
    
- **`notify_all()`**：**倒闭停工 (`stop=true`) 时用**。
    - 因为所有线程都需要执行“退出循环”的逻辑（下班回家），所以必须广播通知所有人起床。

---
**为什么析构函数里 `stop=true` 也要加锁？**

- **误区**：认为 `bool` 赋值是一瞬间的事，不需要锁。
    
- **真相**：
    1. **数据竞争 (Data Race)**：会被多线程读写的非原子变量，C++ 标准规定必须加锁，否则未定义行为。
    2. **丢失唤醒 (Lost Wakeup)**：这是最致命的。如果不加锁，可能发生“Worker 刚检查完 `stop` 是 false，正准备躺下睡觉，但在躺下的一瞬间，主线程把 `stop` 改成了 true 并喊了一声”。Worker 躺下得太晚，**完美错过了**这最后一声呐喊，从此长眠不醒（死锁）。

---
**F. Lambda 捕获为什么要用 `[this]` 而不是 `[&]`？**

- **风险**：`[&]` 是**引用捕获**。如果线程里用了主线程栈上的局部变量（比如循环变量 `i`），而主线程跑得快，函数结束把栈销毁了，后台线程就会访问**悬垂指针**导致崩溃。
    
- **最佳实践**：
    - 访问类成员变量 -> 用 `[this]`。
    - 访问局部变量（如 ID） -> 用 `[i]` (显式拷贝)。
    - **永远不要在跨线程 Lambda 中使用 `[&]`。**


> [!warning]
> 永远不要在跨线程 Lambda 中使用 `[&]`。

