
## 堆栈信息是问号的情况coredump分析

**策略一**

虽然堆栈被写乱，多数情况下还是可以查看到最近栈的寄存器状态。gdb打开core文件后，`info reg`可以看到寄存器存储的信息，其中rbp寄存器中存储的是当前帧的内存地址。rpb内存中存储的是上一帧的rbp的内存地址，上一帧的内存存储的是上上帧的rbp内存地址。rbp+8 栈上一帧返回函数地址。

`x /x addr` 获得 addr 处的值。在 GDB 中，`x` 命令用于查看内存中的数据，`/x` 则是指定以十六进制格式显示数据。通过将 `addr` 替换为要查看的内存地址，可以获取该地址处的值。利用 x 命令查看rbp+8处函数的地址信息。

info line 函数名 / 内存地址，可以根据内存地址获得代码位置。

另外也可以通过如下命令估计函数位置。

disas/disass/disassemble 函数名/起始地址[,结束地址]，可以得到函数汇编代码和地址，查看coredump上下文代码环境。

objdump –dSl c_to_elf > exe_disassembly.txt    对可执行反汇编，可以搜索内存地址对应的代码行和函数。

策略二，查看栈空间当前rsp位置，如果可以找到那些数据是非法写入的数据，则：

直接watch这个内存的值，发生变更时打印堆栈，即可知道哪里写越界。

策略三，自我检查

引起堆栈写乱通常是,memset越界，非法指针地址数据写入等引起，还可能是在栈上分配了一个SIZE超过栈大小的变量，编译会通过，但是一运行就崩溃，如此种种。

凭直觉检查代码分配size过大的地方和数据拷贝可能的位置。

策略四，土办法，二分法注释代码寻找引起崩溃的代码位置。