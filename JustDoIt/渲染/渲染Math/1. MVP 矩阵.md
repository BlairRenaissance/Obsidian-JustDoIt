
## 1. Model 矩阵
$$M = T \times R \times S$$

---
## 2. View 矩阵

View 矩阵的目的是把相机还原到原点，本质上由两部分组成：**平移**（将相机移回原点）和**旋转**（将相机的朝向对准坐标轴）。

给定输入：
- **Eye**: 相机位置
- **Center**: 相机看向的目标点
- **Up**: 世界空间的上方向（通常是 $(0,1,0)$ Y-Up）

### 计算三个基向量

1. **前向向量 ($f$ 或 $z_{axis}$)**：OpenGL 中相机看向 $-Z$ 轴，所以 $Z$ 轴正方向是从目标指向相机
$$z_{axis} = \text{normalize}(Eye - Center)$$
2. **右向量 ($r$ 或 $x_{axis}$)**：利用世界 Up 向量和 $z_{axis}$ 进行叉乘：
$$x_{axis} = \text{normalize}(\text{cross}(Up, z_{axis}))$$
3. **上向量 ($u$ 或 $y_{axis}$)**：重新计算相机的真实上方向（确保正交）：
$$y_{axis} = \text{cross}(z_{axis}, x_{axis})$$

Q：为什么叉乘顺序是 $cross(Up, Z_{axis})$？
A：在标准的 OpenGL 右手坐标系中：拇指 ($X$)为右方 (Right) ，食指 ($Y$)为上方 (Up) ，中指 ($Z$)为指向屏幕外的自己 (Back)。
根据右手定则（食指 $Y$ $\times$ 中指 $Z$ = 拇指 $X$）：$Right (+X) = Up (+Y) \times Back (+Z)$。如果把顺序反过来写成 `cross(z_axis, Up)`，根据叉乘的反交换律 ($A \times B = - (B \times A)$)，会得到指向 **$-X$ (左边)** 的向量，这会导致整个画面左右颠倒。

### 构建矩阵

想象一下：把摄像机摆放到世界某个位置 $(Eye)$ 并旋转它，这个变换叫 Camera Model Matrix ($M_c$)。
$$M_c = T \times R$$
(先旋转 $R$ 对准方向，再平移 $T$ 到位置 $Eye$)

但是，View 矩阵的作用是把世界里的所有东西做相反的变换，好让摄像机看起来像是回到了原点 $(0,0,0)$ 且看向 $-Z$。所以：
$$View = (M_c)^{-1} = (T \times R)^{-1}$$
根据矩阵求逆公式 $(AB)^{-1} = B^{-1}A^{-1}$，顺序要颠倒：
$$View = R^{-1} \times T^{-1}$$
> [!important]
> 最终矩阵形式：
> $$ View = \begin{bmatrix} r_x & r_y & r_z & -\text{dot}(r, Eye) \\ u_x & u_y & u_z & -\text{dot}(u, Eye) \\ f_x & f_y & f_z & -\text{dot}(f, Eye) \\ 0 & 0 & 0 & 1 \end{bmatrix} $$

我们来手动乘一下这两个矩阵，就能看到那个 dot 是怎么出现的了。

**$R^{-1}$ (旋转的逆)：**

旋转矩阵是正交矩阵，正交矩阵的逆等于它的转置 ($R^{-1} = R^T$)。

原来的 $R$ 是把基向量 $(r, u, f)$ 作为列，那么 $R^T$ 就是把它们变成行：
$$R^{-1} = \begin{bmatrix} r_x & r_y & r_z & 0 \\ u_x & u_y & u_z & 0 \\ f_x & f_y & f_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

**$T^{-1}$ (平移的逆)：**

平移 $(Eye_x, Eye_y, Eye_z)$ 的逆就是平移负距离：
$$T^{-1} = \begin{bmatrix} 1 & 0 & 0 & -Eye_x \\ 0 & 1 & 0 & -Eye_y \\ 0 & 0 & 1 & -Eye_z \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

我们计算 $View = R^{-1} \times T^{-1}$。

以结果矩阵的 **第一行** 为例：

- **前三列**：$(r_x, r_y, r_z)$ 乘以单位矩阵部分，保持不变。

- **第四列 (平移部分)**：    

  这是 $R^{-1}$ 的第一行 $\times$ $T^{-1}$ 的第四列：
$$ \text{Val}_{1,4} = (r_x) \cdot (-Eye_x) + (r_y) \cdot (-Eye_y) + (r_z) \cdot (-Eye_z) + 0 \cdot 1$$
  提取负号：
$$ \text{Val}_{1,4} = -(r_x Eye_x + r_y Eye_y + r_z Eye_z)$$
  这正是点积的定义：
$$ \text{Val}_{1,4} = -\text{dot}(r, Eye)$$
同理，第二行和第三行的第四列也就变成了 $-\text{dot}(u, Eye)$ 和 $-\text{dot}(f, Eye)$。

---
## 3. Projection 矩阵

透视投影（Perspective Projection）的推导通常被分解为两个步骤：

1. **挤压 (Squish)**：先把“棱台状”的视锥体（Frustum）“挤压”成一个长方体（Cuboid）。这个过程叫 $M_{persp \to ortho}$。

2. **正交投影 (Orthographic)**：把这个长方体**平移**到原点，并**缩放**到 $[-1, 1]^3$ 的标准立方体（Canonical View Volume, CVV）中。这个过程叫 $M_{ortho}$。    

公式推导就是这两个矩阵相乘：
$$M_{proj} = M_{ortho} \times M_{persp \to ortho}$$
---
### 挤压矩阵 

我们需要把棱台（Frustum）挤压成长方体。 在这个过程中，我们规定： 
1. **近平面 ($z=n$)** 的点坐标不变。 
2. **远平面 ($z=f$)** 的点坐标 $z$ 值不变，但 $x, y$ 挤压到和近平面一样大。 
3. **中心点** $(0, 0, z)$ 仍然在 z 轴上。 利用相似三角形原理（$x' = \frac{n}{z}x$），引入齐次坐标的 $w$ 分量来实现除以 $z$ 的效果，经过推导可以得到： 

> [!Important]
> $$M_{persp \to ortho} = \begin{bmatrix} n & 0 & 0 & 0 \\ 0 & n & 0 & 0 \\ 0 & 0 & n+f & -nf \\ 0 & 0 & 1 & 0 \end{bmatrix}$$

注意：最后一行是 $0, 0, 1, 0$，这意味着变换后的 $w' = z$。这就是为什么后面会有“透视除法”（除以 $w$ 即除以 $z$）的原因。

---
#### 透视除法

>[!Question]
>Q：为什么最后一行是 $0, 0, 1, 0$ 意味着变换后的 $w' = z$ ？

A：当我们将一个 4x4 的投影矩阵乘以一个齐次坐标点 $P(x, y, z, 1)$ 时：
$$\begin{bmatrix} \dots & \dots & \dots & \dots \\ \dots & \dots & \dots & \dots \\ \dots & \dots & \dots & \dots \\ \mathbf{0} & \mathbf{0} & \mathbf{1} & \mathbf{0} \end{bmatrix} \times \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} x' \\ y' \\ z' \\ \mathbf{w'} \end{bmatrix}$$
我们只看最后一行（第四行）的运算：
$$w' = (0 \cdot x) + (0 \cdot y) + (1 \cdot z) + (0 \cdot 1)$$
结果非常直接：
$$w' = z$$
所以为什么要让 $w' = z$ ？这涉及到了计算机图形学中最大的“骗局”之一：透视除法 (Perspective Divide)。

在真实世界中，物体离相机越远（$z$ 越大），看起来就越小。根据相似三角形原理（针孔相机模型），投影到屏幕上的 $x$ 坐标应该是：
$$x_{screen} = x_{world} \cdot \frac{n}{z_{world}}$$
注意这里有一个 **“除以 z”** 的操作。然而，**矩阵乘法是线性的**。矩阵只能做加法和乘法，**矩阵里没有“除法”这个功能**。没办法设计一个矩阵，让它直接算出一个 $x/z$ 的结果。

既然矩阵做不了除法，聪明的数学家决定：**先不做除法，把分母存起来，留给 GPU 最后做。** 方法就是把 z 藏在 w 里，这就是 **齐次坐标 (Homogeneous Coordinates)** 的真正威力。

在顶点着色器（Vertex Shader）运行完之后，GPU 硬件会自动执行一个标准步骤，叫做 **“透视除法”**：将 $(x', y', z', w')$ 中的所有分量都除以 $w'$。

$$\text{最终坐标 (NDC)} = \left( \frac{x'}{w'}, \frac{y'}{w'}, \frac{z'}{w'} \right)$$
> [!Tip]
> **小贴士 (关于正负号)**：
> 
> 在很多图形 API（如 OpenGL）的标准推导中，最后一行通常是 **$(0, 0, -1, 0)$**。
> 
> 这是因为在 OpenGL 的右手坐标系中，相机看向 $-Z$ 方向，物体在相机前方的 $z$ 值是负数（比如 -5, -10）。
> 
> 为了让最后的 $w$ 是一个正数（便于裁剪和深度测试），通常会乘一个 $-1$，让 $w' = -z$（即距离）。
> 
> 目前看到的 $(0, 0, 1, 0)$ 可能是基于 $z$ 为正（看向 $+Z$）的推导，或者是 GAMES101 课程中为了简化理解的中间步骤。

总结来讲，最后一行是 $(0, 0, 1, 0)$ 的原因在于：

1. **偷天换日**：它负责把顶点的深度值 $z$ 复制一份，存储到齐次坐标的 $w$ 分量中。

2. **延迟计算**：它利用齐次坐标的特性，告诉 GPU：“我现在没法做除法，但我把除数放在 $w$ 里了，请你稍后帮我除一下。”

---
#### 透视投影矩阵推导

>[!Question]
>Q：$M_{persp \to ortho}$ 矩阵是如何推导出的？

A：简单来说，推导这个矩阵的核心逻辑是：**利用齐次坐标的“扩容”特性，先凑出 $x, y$ 的正确形式，再通过解方程反推出 $z$ 的变换参数。**

首先，我们的目标是将一个棱台（Frustum）里的点 $(x, y, z)$ “挤压”成一个长方体里的点 $(x', y', z')$。

根据**相似三角形原理**（想象从侧面看），投影后的坐标 $x', y'$ 和原始坐标 $x, y, z$ 的关系是：
$$x' = \frac{n}{z} x, \quad y' = \frac{n}{z} y$$
**遇到的困难：**

矩阵乘法只能表示 $Ax + By + Cz + D$ 这种线性组合，根本表示不了“除以 $z$”这种操作。

**解决方案（齐次坐标）：**

我们利用齐次坐标的性质：$(x, y, z, 1)$ 等价于 $(kx, ky, kz, k)$。

既然==GPU会强制执行自动除以 w==，那我们可以**故意**把 $z$ 放到 $w$ 的位置上。

如果我们能构建一个矩阵，把输入点 $(x, y, z, 1)$ 变换成下面这个样子：
$$\begin{bmatrix} nx \\ ny \\ \text{unknown} \\ z \end{bmatrix}$$
那么，当进行透视除法（所有分量除以 $w$，也就是除以 $z$）后，我们就得到了：
$$\left( \frac{nx}{z}, \frac{ny}{z}, \frac{\text{unknown}}{z}, 1 \right) = \left( x', y', z', 1 \right)$$
看！$x'$ 和 $y'$ 已经完美符合 $nx/z$ 和 $ny/z$ 了。

这就确定了矩阵的**第 1、2、4 行**：
$$\begin{bmatrix} n & 0 & 0 & 0 \\ 0 & n & 0 & 0 \\ ? & ? & ? & ? \\ 0 & 0 & 1 & 0 \end{bmatrix} \times \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} nx \\ ny \\ \dots (z_{unk}) \\ z \end{bmatrix} = \begin{bmatrix} x' \\ y' \\ z' \\ 1 \end{bmatrix}$$
---

现在的难点是**第三行**。我们要找到 $z$ 变换后的值（也就是那个 "unknown"），记为 $z_{unk}$。

根据矩阵乘法，第三行的形式肯定是 $(0, 0, A, B)$。==为什么前两个是 0？因为深度的变化只应该和 z 有关，不应该受 x, y 左右位置的影响。== 所以：
$$z_{unk} = Az + B$$
**注意：** 这里的 $z_{unk}$ 还不是最终的深度，它是**除以 $z$ 之前**的值。

真正的最终深度 $z'$ 是：
$$z' = \frac{z_{unk}}{z} = \frac{Az + B}{z}$$

我们有两个非常强的约束条件（性质）来解出 A 和 B：

1. **近平面上的点不动**：如果一个点本来就在近平面上 ($z = n$)，挤压后它还在近平面上 ($z' = n$)。

2. **远平面上的点不动**：如果一个点本来就在远平面上 ($z = f$)，挤压后它还在远平面上 ($z' = f$)。

代入公式 $z' = \frac{Az+B}{z}$：
$$n = \frac{An + B}{n} \implies An + B = n^2 \quad \text{--- (式1)}$$
$$f = \frac{Af + B}{f} \implies Af + B = f^2 \quad \text{--- (式2)}$$
---

现在我们是一个简单的二元一次方程组：
$$\begin{cases} An + B = n^2 \\ Af + B = f^2 \end{cases}$$
$$Af - An = f^2 - n^2$$
$$A(f - n) = (f - n)(f + n)$$
得到：
$$\mathbf{A = n + f}$$
把 A 代回 (式1)：
$$(n + f)n + B = n^2$$
$$n^2 + fn + B = n^2$$
$$\mathbf{B = -nf}$$

把求出的 A 和 B 填回矩阵的第三行，就得到了那个经典矩阵：

$$M_{persp \to ortho} = \begin{bmatrix} n & 0 & 0 & 0 \\ 0 & n & 0 & 0 \\ 0 & 0 & \mathbf{n+f} & \mathbf{-nf} \\ 0 & 0 & 1 & 0 \end{bmatrix}$$
--- 
### 正交投影矩阵 

我们已经有了一个长方体，它的范围是：
- $x$ 轴：$[l, r]$ (left, right)    
- $y$ 轴：$[b, t]$ (bottom, top)
- $z$ 轴：$[n, f]$ (near, far) _注：这里假设是右手坐标系，相机看向 -Z，所以 n, f 通常是负值_

要把这个任意长方体变成标准立方体 $[-1, 1]^3$，我们需要做两件事：

1. **平移 (Translate)**：把长方体的中心点移到原点 $(0,0,0)$。
    
    - 中心点坐标：$(\frac{r+l}{2}, \frac{t+b}{2}, \frac{n+f}{2})$
        
    - 平移向量就是这个坐标的相反数。
        
2. **缩放 (Scale)**：把长方体的宽高深缩放到长度为 2（从 -1 到 1）。
    
    - 缩放因子：$(\frac{2}{r-l}, \frac{2}{t-b}, \frac{2}{n-f})$
        

矩阵形式如下：
$$ M_{ortho} = \begin{bmatrix} \frac{2}{r-l} & 0 & 0 & 0 \\ 0 & \frac{2}{t-b} & 0 & 0 \\ 0 & 0 & \frac{2}{n-f} & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \times \begin{bmatrix} 1 & 0 & 0 & -\frac{r+l}{2} \\ 0 & 1 & 0 & -\frac{t+b}{2} \\ 0 & 0 & 1 & -\frac{n+f}{2} \\ 0 & 0 & 0 & 1 \end{bmatrix} $$
---
### 最终

透视投影矩阵 $M_{proj}$ 将上面两个矩阵相乘 $M_{ortho} \times M_{persp \to ortho}$。 为了简化公式，我们通常假设视锥体是对称的（相机正对中心），即 $r = -l$，$t = -b$。 这样 $r+l=0$, $t+b=0$，平移部分会简化很多。 最终得到的通用透视投影矩阵（OpenGL 风格）是： $$M_{proj} = \begin{bmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\ 0 & 0 & \frac{n+f}{n-f} & -\frac{2nf}{n-f} \\ 0 & 0 & 1 & 0 \end{bmatrix}$$ 如果是完全对称的 ($r=-l, t=-b$)，且使用 $FOV$ (视场角) 和 $Aspect$ (宽高比)  $\cot(\frac{fov}{2}) = \frac{2n}{t-b}$  $Aspect = \frac{r-l}{t-b}$ 来表示：

矩阵可以简化为最常见的形式： $$M_{proj} = \begin{bmatrix} \frac{1}{Aspect \cdot \tan(fov/2)} & 0 & 0 & 0 \\ 0 & \frac{1}{\tan(fov/2)} & 0 & 0 \\ 0 & 0 & \frac{n+f}{n-f} & -\frac{2nf}{n-f} \\ 0 & 0 & 1 & 0 \end{bmatrix}$$
