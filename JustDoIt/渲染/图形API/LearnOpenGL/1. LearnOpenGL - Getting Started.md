
> æ¢¦å¼€å§‹çš„åœ°æ–¹hhhã€‚

ğŸ”— è¶…å¥½ç”¨çš„OpenGLå‡½æ•°è¯­æ³•Docï¼š https://docs.gl/

ğŸ”— OpenGLå®˜æ–¹æ–‡æ¡£ï¼š https://www.khronos.org/opengl/wiki

---

åœ¨OpenGLä¸­ï¼Œç€è‰²å™¨ç¨‹åºçš„åˆ›å»ºå’Œä½¿ç”¨è¿‡ç¨‹åŒ…æ‹¬äº†ä¸€ç³»åˆ—çš„æ­¥éª¤ï¼š

> `glCreateShader` -> `glShaderSource` -> `glCompileShader` -> `glCreateProgram` -> `glAttachShader` -> `glLinkProgram` -> `glDetachShader` -> `glDeleteShader` -> draw using this shader program -> and when I don't need this shader anymore `glDeleteProgram`

1. **glCreateShader**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„ç€è‰²å™¨å¯¹è±¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªéé›¶å€¼çš„ç€è‰²å™¨IDã€‚ä½ éœ€è¦æŒ‡å®šç€è‰²å™¨çš„ç±»å‹ï¼Œå¦‚GL_VERTEX_SHADERï¼ˆé¡¶ç‚¹ç€è‰²å™¨ï¼‰æˆ–GL_FRAGMENT_SHADERï¼ˆç‰‡æ®µç€è‰²å™¨ï¼‰ã€‚

2. **glShaderSource**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºå°†ç€è‰²å™¨æºä»£ç é™„åŠ åˆ°ç€è‰²å™¨å¯¹è±¡ä¸Šã€‚ä½ å¯ä»¥ä¸€æ¬¡æ€§æä¾›å¤šä¸ªå­—ç¬¦ä¸²ä½œä¸ºæºä»£ç ã€‚

3. **glCompileShader**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºç¼–è¯‘é™„åŠ åˆ°ç€è‰²å™¨å¯¹è±¡ä¸Šçš„æºä»£ç ã€‚

4. **glCreateProgram**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„ç¨‹åºå¯¹è±¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªéé›¶å€¼çš„ç¨‹åºIDã€‚

5. **glAttachShader**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºå°†ä¸€ä¸ªå·²ç»ç¼–è¯‘çš„ç€è‰²å™¨é™„åŠ åˆ°ç¨‹åºå¯¹è±¡ä¸Šã€‚

6. **glLinkProgram**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºé“¾æ¥é™„åŠ åˆ°ç¨‹åºå¯¹è±¡ä¸Šçš„æ‰€æœ‰ç€è‰²å™¨ï¼Œç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„å¯æ‰§è¡Œç¨‹åºã€‚è¿™ä¸ªè¿‡ç¨‹ä¼šæ£€æŸ¥æ‰€æœ‰çš„ç€è‰²å™¨æ˜¯å¦èƒ½å¤Ÿä¸€èµ·å·¥ä½œï¼ˆä¾‹å¦‚ï¼Œé¡¶ç‚¹ç€è‰²å™¨è¾“å‡ºçš„å˜é‡æ˜¯å¦èƒ½è¢«ç‰‡æ®µç€è‰²å™¨æ¥æ”¶ï¼‰ï¼Œå¹¶è¿›è¡Œä¸€äº›ä¼˜åŒ–ã€‚

7. **glDetachShader**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºå°†ç€è‰²å™¨ä»ç¨‹åºå¯¹è±¡ä¸Šåˆ†ç¦»ã€‚è¿™é€šå¸¸åœ¨é“¾æ¥å®Œæˆåè¿›è¡Œï¼Œå› ä¸ºä¸€æ—¦é“¾æ¥å®Œæˆï¼Œç€è‰²å™¨å°±ä¸å†éœ€è¦äº†ã€‚

8. **glDeleteShader**ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºåˆ é™¤ç€è‰²å™¨å¯¹è±¡ã€‚è¿™é€šå¸¸åœ¨ç€è‰²å™¨å·²ç»è¢«é™„åŠ å¹¶é“¾æ¥åˆ°ç¨‹åºåè¿›è¡Œã€‚

9. **Draw using this shader program**ï¼šä½¿ç”¨`glUseProgram`å‡½æ•°æ¥å¯ç”¨ä½ çš„ç€è‰²å™¨ç¨‹åºï¼Œç„¶åè¿›è¡Œç»˜åˆ¶æ“ä½œã€‚

10. **glDeleteProgram**ï¼šå½“ä½ ä¸å†éœ€è¦è¿™ä¸ªç€è‰²å™¨ç¨‹åºæ—¶ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥åˆ é™¤å®ƒã€‚

---

ç¼“å†²åŒºçš„åˆ›å»ºå’Œä½¿ç”¨è¿‡ç¨‹åŒ…æ‹¬äº†ä¸€ç³»åˆ—çš„æ­¥éª¤ï¼š

> VBOï¼š`glGenBuffers` -> `glBindBuffer` -> `glBufferData`
> EBOï¼š`glGenBuffers` -> `glBindBuffer` -> `glBufferData
> VAOï¼š`glGenVertexArrays` -> `glBindVertexArray` -> `glVertexAttribPointer` -> `glEnableVertexAttribArray`

``` C++
Â  Â  unsigned int VBO, VAO, EBO;

Â  Â  glGenBuffers(1, &VBO);
Â  Â  glBindBuffer(GL_ARRAY_BUFFER, VBO);
Â  Â  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);


Â  Â  glGenBuffers(1, &EBO);
Â  Â  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
Â  Â  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);


Â  Â  // æ³¨æ„è¿™é‡Œä¸æ˜¯GenBufferï¼è€Œæ˜¯GenVertexArraysï¼ï¼
Â  Â  glGenVertexArrays(1, &VAO);
Â  Â  glBindVertexArray(VAO);
Â  Â  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
Â  Â  glEnableVertexAttribArray(0);
Â  Â  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
Â  Â  glEnableVertexAttribArray(1);
```

---

çº¹ç†çš„åˆ›å»ºå’Œä½¿ç”¨åŒ…æ‹¬äº†ä¸€ç³»åˆ—çš„æ­¥éª¤ï¼š

> `glGenTextures` -> `glBindTexture` -> `glTexParameteri` -> `glTexImage2D` -> `glUseProgram` -> `glUniform1i` -> (render loop)`glActiveTexture` -> `glBindTexture`

``` C++
Â  Â  unsigned int texture1, texture2;
Â  Â  int width, height, nrChannels;

#pragma mark çº¹ç†1
Â  Â  glGenTextures(1, &texture1);
Â  Â  glBindTexture(GL_TEXTURE_2D, texture1);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
Â  Â  unsigned char* data = stbi_load("../Resource/container.jpg", &width, &height, &nrChannels, 0);

Â  Â  if(data){
Â  Â  Â  Â  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
Â  Â  }else{
Â  Â  Â  Â  std::cout << "Failed to load texture1" << std::endl;
Â  Â  }
Â  Â  stbi_image_free(data);

#pragma mark çº¹ç†2
Â  Â  glGenTextures(1, &texture2);
Â  Â  glBindTexture(GL_TEXTURE_2D, texture2);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
Â  Â  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
Â  Â  data = stbi_load("../Resource/awesomeface.png", &width, &height, &nrChannels, 0);
Â  Â  
Â  Â  // å›¾ç‰‡åŸç‚¹åœ¨å·¦ä¸Šè§’ï¼Œä½†OpenGLçš„åŸç‚¹åœ¨å·¦ä¸‹è§’
Â  Â  stbi_set_flip_vertically_on_load(true);

Â  Â  if(data){
Â  Â  Â  Â  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
Â  Â  }else{
Â  Â  Â  Â  std::cout << "Failed to load texture2" << std::endl;
Â  Â  }
Â  Â  stbi_image_free(data);


Â  Â  transformShader.use();
Â  Â  // é€šè¿‡glUniform1iè®¾ç½®æ¯ä¸ªç€è‰²å™¨é‡‡æ ·å™¨å±äºå“ªä¸ªçº¹ç†å•å…ƒ(GL_TEXTURE0/1/../15)
Â  Â  glUniform1i(glGetUniformLocation(transformShader.shaderProgramID, "texture1"), 0);
Â  Â  glUniform1i(glGetUniformLocation(transformShader.shaderProgramID, "texture2"), 1);


Â  Â  // æ¸²æŸ“loopä¸­
Â  Â  glActiveTexture(GL_TEXTURE0);
Â  Â  glBindTexture(GL_TEXTURE_2D, texture1);
Â  Â  glActiveTexture(GL_TEXTURE1);
Â  Â  glBindTexture(GL_TEXTURE_2D, texture2);
```