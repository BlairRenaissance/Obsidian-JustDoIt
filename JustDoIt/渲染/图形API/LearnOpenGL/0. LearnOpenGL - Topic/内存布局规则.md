## 内存布局对比

| 特性     | std140                                   | std430 | packed |
| ------ | ---------------------------------------- | ------ | ------ |
| 对齐要求   | 严格                                       | 较宽松    | 无保证    |
| 数组元素对齐 | 16字节                                     | 元素自然对齐 | 不可预测   |
| 性能     | 一般                                       | 更高     | 可能最低   |
| 适用场景   | [[4. LearnOpenGL - Advanced OpenGL#UBO]] | SSBO   | 兼容旧硬件  |
### 为什么需要内存对齐？

现代 GPU 的内存访问有严格的性能优化要求：
1. **SIMD 架构**：需要数据按特定宽度对齐（如 16 字节）
2. **缓存行优化**：对齐数据可减少缓存行碎片
3. **驱动兼容**：避免不同厂商硬件的差异导致数据错位

## `std140`

`std140` 是 OpenGL 中定义的一种显式 Uniform 缓冲对象 (UBO) 的内存布局规则，用于确保 CPU 和 GPU 之间的数据结构严格对齐。掌握 `std140` 布局是高性能图形编程的基础，它的核心作用是解决跨硬件平台的数据兼容性问题，它能帮助开发者写出跨平台稳定的渲染代码。

### std140 对齐规则速查表

| 数据类型    | 成员对齐基数 | 大小（字节） | 示例说明           |
| ------- | ------ | ------ | -------------- |
| `float` | 4      | 4      | 单个浮点数          |
| `vec2`  | 8      | 8      | 二维向量           |
| `vec3`  | ==16== | 12     | 三维向量但占16字节     |
| `vec4`  | 16     | 16     | 四维向量           |
| `mat3`  | 16     | 48     | 按列存储，每列视为 vec4 |
| `mat4`  | 16     | 64     | 标准 4x4 矩阵      |
| 标量数组    | 16     | N*16   | 每个元素占 16 字节    |
| 结构体     | 最大成员   | 累计对齐   | 按最大成员对齐        |
| 嵌套结构体   | 16     | 累计对齐   | 外层结构体按 16 字节对齐 |

* **成员对齐基数**：每个数据类型在内存中分配时必须满足的起始地址倍数。
```
struct Example {
    float a;    // 对齐基数=4
    vec3 b;     // 对齐基数=16
    mat4 c;     // 对齐基数=16
};
```
该结构体的成员最大对齐基数是16（来自vec3 b和mat4 c）。

- **结构体对齐基数**：整个结构体在内存中的起始地址必须满足的倍数，等于其所有成员中对齐基数的最大值。

- **结构体总大小要求**：结构体占用的总字节数必须是其对齐基数的整数倍。如果实际内容不足，会进行累计对齐。

### 双端对齐很关键

> GLSL会遵循std140规则进行字节对齐，然而C++的编译器却不会自动填充。如果不严格按规则手动布局，会直接导致数据读取错位。

#### 示例分析一

场景1：纯GLSL代码
```
// GLSL着色器中的uniform块
layout(std140) uniform Example {
    vec3 a;    // 偏移0-11
    float b;   // 偏移16-19
};
```
- **现象**：如果不手动写填充字段，b仍然会正确对齐到16字节。
- **真相**：这不是编译器在填充，而是std140规则强制要求成员b必须从16开始。
- **本质区别**：GLSL中的对齐是通过 偏移约束 实现的，而不是物理内存填充。

场景2：C++端结构体
```
// 错误：依赖编译器自动填充
struct Example {
    float a[3]; // 模拟vec3 (0-11)
    float b;    // 编译器实际会从12开始！不符合std140
};

// 正确：手动填充
struct Example_Std140 {
    float a[3];
    float _padding; // 手动填充(12-15)
    float b;        // 16-19
};
```
- **关键点**：C++编译器不知道你要对接std140布局，只会按CPU对齐规则处理。

#### 示例分析二

GLSL 定义
```glsl
layout(std140) uniform LightData {
    vec3 position;     // 起始偏移 0，占12字节
    float intensity;   // 偏移 16（不能紧接vec3后），占4字节
    vec4 color;        // 偏移 32（需对齐到16字节），占16字节
    bool enabled;      // 偏移 48，占4字节（布尔按int处理）
}; // 总大小：48 + 4 + 16 = 68 → 实际分配 80 字节（对齐到16的倍数）
```
1. 基础对齐原则：
	- 每个成员的偏移量必须是其 对齐基数 的整数倍
	- vec3 的对齐基数是 16 字节（与 vec4 相同）
2. vec3的特殊处理：
```
vec3 position;  // 占用 0-11 字节（12字节）
				// 但要求下一个成员必须从 16 字节开始，应该是因为GPU一下子读16字节
```
3. 后续成员的约束：
```
float intensity; // 需要对齐到 4 字节边界
                 // 但必须满足 16 字节的父级对齐要求
```

C++ 对应结构体
```cpp
struct LightData_Std140 {
    // vec3 position
    float position[3]; 
    float _padding1;  // 填充到16字节！非常关键！
    
    // float intensity
    float intensity;
    float _padding2[3]; // 填充到下一个16字节
    
    // vec4 color
    struct {
        float r, g, b, a;
    } color;
    
    // bool enabled
    int enabled;       // GLSL bool对应4字节
    float _padding3[3]; // 填充到总大小为80字节
};
```

#### 示例分析三

```
layout (std140) uniform ExampleBlock
{
                     // 基准对齐量       // 对齐偏移量
    float value;     // 4               // 0 
    vec3 vector;     // 16              // 16  (必须是16的倍数，所以 4->16)
    mat4 matrix;     // 16              // 32  (列 0)
                     // 16              // 48  (列 1)
                     // 16              // 64  (列 2)
                     // 16              // 80  (列 3)
    float values[3]; // 16              // 96  (values[0])
                     // 16              // 112 (values[1])
                     // 16              // 128 (values[2])
    bool boolean;    // 4               // 144
    int integer;     // 4               // 148
};
```

### 常见问题解决方案

1. **数据错位问题**：
   - 现象：渲染时颜色/位置显示异常
   - 调试：使用 `NSight` 或 `RenderDoc` 查看缓冲数据
   - 工具验证：`glGetUniformBlockIndex` + `glGetActiveUniformsiv`

2. **性能优化技巧**：
   ```cpp
   // 使用编译器指令强制对齐（GCC/Clang）
   struct alignas(16) LightData {
       // ...
   };
   
   // 验证结构体大小
   static_assert(sizeof(LightData) == 80, "Alignment error");
   ```

3. **动态数组处理**：
   ```glsl
   layout(std140) buffer StorageBuffer {
       vec4 dynamicArray[]; // 最后一个成员可以是未定义大小的数组
   };
   ```

