https://km.woa.com/articles/show/606262?kmref=dailymail_top&jumpfrom=daily_mail
# 五、管线

GPU专门为多数据单指令的计算而优化，因此GPU的硬件上存在专门的设计，它对处理的数据，和对数据的处理方式存在专门的约定，这种专门的约定意味着我们不能像处理CPU上C++编程一样随意的写代码逻辑，而是要遵循他的约定，按照约定调用图形API来完成。这就是GPU的管线。GPU管线即包括为了绘制出一张Image的渲染管线，也包括为通用性并行计算而设计的计算管线等。

##   

## 5.1 管线的整体结构

![](https://km.woa.com/asset/000100022406003a34550b35be446b02?height=1220&width=1200)

上图展示了GPU管线的最粗略的样子，它是一个由若干个处理节点按时序连接而成的数据处理系统，数据经过这个管线被处理后输出另一种数据（图形管线的输出是将数据写入到frame buffer，而计算管线的输出是将数据写入到image或者buffer）。

这个管线至少包含4个部份：

● 可编程的处理模块

这些模块需要我们自己编写运行代码，即shader，然后设置到管线上

● 固定的处理模块

这些模块是硬件固化的，我们不能改变逻辑，但是驱动暴露了很多开关和参数，允许我们调控

● 资源挂点

同CPU上的程序不同，目前主流的GPU管线上不能通过索引指针地址的方式访问资源，只能通过从固定的有限个数的资源挂接点处访问资源，一个资源若想被管线访问，必须先讲它绑定到某个资源挂点上。

● 资源对象

那些需要被绑在资源挂点上的资源对象。虽然资源挂点数量有限，但是资源对象的创建数量并没有限制，因为我们可以切换资源的绑定。

  

从这4个部份也说明，我们若想通过API来操作GPU管线，通常要做以下4件事件：

● 设置管线的shader

● 调控固定管线的开关和参数

● 创建资源

● 绑定资源

以下分别讨论这四个问题再API上的实现。

  

## 5.2 管线的shader设置

  

### 5.2.1 从 shader、program到pipeline

  

整个管线上是由多个可编程的shader组成的，一般把每一个单独的shader叫做一个shader，而把整个组成当前管线的这些shader集合叫做一个program。所以这里要先创建shader，再创建program。

我们一般从源码创建shader，这个过程叫做shader的编译，编译的结果shader一般会被表示成一个中间文件，他不能被执行，需要将当前管线上前后的所有shader放在一起再次进行链接才能产生最终可执行的机型特定的二进制文件，即program。

对于vulkan和metal来说，program的创建又通常需要知道其他的固定管线参数，所以在vulkan和metal上，有了shader之后，需要创建的是整个pipeline对象。

  

![](https://km.woa.com/asset/0001000224060036e9192ee63140f702?height=692&width=1678)

  

这样看来program的创建是一个耗时的操作，所以一些API都提供了直接从一个离线编译好的二进制文件直接创建program的操作，但是由于program一般是和机器强相关的machine code，所以binary文件不能跨机器使用，一般需要在当前机器上产生，下次复用在该机器上，而不能有一个跨机器通用的形式。

![](https://km.woa.com/asset/00010002240600fb130aeef22a477a02?height=1214&width=1658)

  

### 5.2.2 shader的创建和编译

  

shader也是一种gpu上的对象，在使用之前需要先创建出来。

Gles下需先使用glCreateShader(type)先创建这个shader对象，然后用glShaderSource（）装填它的代码，最后用glCompileShader()将这个shader编译。

Vulkan下一般使用vkCreateShaderModule（）来创建并编译一个shader，参数里面需要指定shader的源码和类型，它产生的结果是一个VkShaderModule对象，代表一个shader。

Metal下的一个shader被称为一个MtlFunction，metal下为了优化一般把1个或多个mtlfunction打包再一起，称做一个MtlLibrary。我们需要先创建MtlLibrary，然后从这个libray创建MtlFunction。

使用Mtldevice的newLibraryWithSource接口可以从源码创建library，这个源码可以包含多个shader 的source，再使用MtlLibrary的接口newFunctionWithName从里面找到相应名字的shader，创建成mtlfunction。

Metal下面允许直接通过接口newLibraryWithData加载一个已经离线编译好的二进制的mtllibrary文件，而不用运行时编译，且这个二进制文件因为只是中间文件，所以可以机型通用

只有metal在shader编译这一层也提供了从二进制加载的方案。vulkan和gles只能在program/pipeline这一层提供了binary机制。

metal的shader创建这一步稍微复杂，如图。

![](https://km.woa.com/asset/000100022406002e08c38ae1884d0102?height=872&width=1206)

  

### 5.2.3 创建Program或Pipeline

  

有了shader后，我们基于shader创建program，对于vulkan和metal来说，是联合其他固管参数创建pipeline。

Gles下，先使用glCreateProgram创建这个program对象，然后用glAttachShader往里加入shader，最后用glLinkProgram创建program。

  

Vulkan下，使用vkCreateGraphicsPipelines（或vkCreateComputePipelines）这个接口创建一个pipeline对象，传入的重要参数为VkGraphicsPipelineCreateInfo，它的定义如下

  

```
typedef struct VkGraphicsPipelineCreateInfo {    VkStructureType                                  sType;    const void*                                      pNext;    VkPipelineCreateFlags                            flags;    uint32_t                                         stageCount;    const VkPipelineShaderStageCreateInfo*           pStages;    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;    const VkPipelineTessellationStateCreateInfo*     pTessellationState;    const VkPipelineViewportStateCreateInfo*         pViewportState;    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;    const VkPipelineDynamicStateCreateInfo*          pDynamicState;    VkPipelineLayout                                 layout;    VkRenderPass                                     renderPass;    uint32_t                                         subpass;    VkPipeline                                       basePipelineHandle;    int32_t                                          basePipelineIndex;} VkGraphicsPipelineCreateInfo;
```

可以看出一个pipeline的创建，不仅要设置shader，还要设置其使用的其他固定管线参数（文章后面会讲到）。

其中VkPipelineShaderStageCreateInfo stages这个结构里面就是要设置的所有shader的VkShaderModule。

Metal下使用MtlDevice的newRenderPipelineStateWithDescriptor（或newComputePipelineStateWithDescriptor）

接口来创建一个Pipeline，里面需要传入的重要参数是MTLRenderPipelineDescriptor，设置它的vertexFunction等变量来设置其所用的shader function。

  

### 5.2.4 Program Binary

  

几乎所有API都能支持不经过前面的shader编译，link这两步，而直接从机型相关的二进制文件创建pipeline，这样效率是最高的。因为binary file是机器相关，所以都需要预先从当前设备上生成。（所以一些游戏上经常需要在首次启动时预先编译一些常用的programe/pipeline存储下来）

  

gles下面使用glGetProgramBinary获取一个program的binary 数据，保存后，下次使用glProgramBinary加载。

  

vulkan下面的binary文件保存的不只是program，而是整个pipeline，它已考虑一个叫做pipeline cache的机制。首先运行时需要通过vkCreatePipelineCache创建一个pipeline cache对象，然后在前面创建pipeline的接口vkCreateGraphicsPipelines中将此cache传入，即将pipeline同这个cache关联，通过vkGetPipelineCacheData可以获取这个cache中的所有pipeline的binary，可以保存下来。

复用的时候，调用函数是一样的，先vkCreatePipelineCache创建pipeline cache对象，只是其中的参数要传入之前的binary数据，后面创建pipeline的时候，将这个cache传入创建的API，就可以直接基于这个cache创建了。

  

Metal下面也是保存整个pipeline， 它的pipeline cache机制称作binary archive，这是一个IOS14以上才能支持的较新特性，首先第一次我们需要运行时调用MtlDevice的newBinaryArchiveWithDescriptor接口创建一个MtlBinaryArchive，然后使用它的API addRenderPipelineFunctionsWithDescriptor 等将创建好的pipeline加入进去，最后用serializeToURL将binary file写出。

复用的时候，我们同样先用newBinaryArchiveWithDescriptor创建archieve，只是要将一个binary file的路径传入，等需要创建pipeline时，在上面原有的创建步骤基础上，对于传入的MTLRenderPipelineDescriptor，设置它的binaryArchives中包含这个archieve，这样就可以从这个archive中直接找到现有的binary复用了。

  

### 5.2.5设置Program或pipeline

  

当programe/pipeline对象创建好后，需要设置给当前的管线。

  

gles下使用glUseProgram来设置

vulkan下使用 vkCmdBindPipeline将pipeline绑定

metal下使用 MtlRenderCommandEncoder的setRenderPipelineState函数设置

  

  

### 5.2.6 Metal中的Dynamic Library

  

由于shader中也会像C++程序一样经常复用大量的代码（如一些公共函数等），而program的编译是一个个独立进行的，这些共用代码等于被反复重复编译了。为了解决这个问题,metal使用dynamic library机制将这些代码抽离出来，并允许动态加载，它自ios15以上支持。

首先我们将这些抽出来的shader代码打到一个单独的mtllibrary中，使用mtldevice的newDynamicLibrary函数从这个mtllibrary创建出MTLDynamicLibrary。（需要注意的是MTLDynamicLibrary名字虽然是library，其实是一个binary的code，所以它是机器特定的，不能跨机器使用），在创建pipeline的时候，需要将pipelinedescriptor的fragmentPreloadedLibraries中包含这个MTLDynamicLibrary以动态加载这个binary，这可以进一步提高链接生成pipeline的速度。

  

由于metal中设计shader和pipeline编译的概念众多，有时很难分清Binary Library，Binary Archive，Dynamic Library各自的作用，这里用一张图来直观表示

![](https://km.woa.com/asset/00010002240600e2a47c44d62f4f3b02?height=826&width=1151)

  

## 5.3固定管线参数设置

  

GPU管线上有着复杂而庞大的固定管线逻辑，这些逻辑是硬件和驱动预设好的，我们只能控制这些逻辑的开关和参数，而不能对其进行编程

  

### 5.3.1 管线流程

  

  

  

![](https://km.woa.com/asset/00010002240600a10046836a8e471602?height=1045&width=830)

对于计算管线来说很简单，就一个单独的可编程的计算shader。

对于图形管线来说就复杂的多，可以分为以下几个大的范围阶段：

● Vertex Processing 顶点处理

● Post Vertex Processing 顶点后处理

● Rasterization 光栅化

● Early Per-Fragment Test 像素处理前的像素测试

● Fragment Processing 像素处理

● Per-Fragment Test 像素处理后多像素测试

● Framebuffer Operation 帧缓存上的像素操作

  

这里面的每一步都有很多的参数和开关供我们调整，后面我们将逐个介绍，在这之前，我们先介绍各大API如何设计对固定管线参数的设置API的。

  

### 5.3.2 固定管线设置的API

  

对于固定管线参数的设置，一般有两种模式：

一是通过一个个独立的API去分别设置这些参数

另外一种是现代API使用的，将所有的固管参数（包括管线使用的shader）打包在一起，作为pipeline创建的参数，在创建pipeline时一起指定，这样固管参数同shader一起抽象出来的pipeline的数据，可以作为一个整体，进一步被序列化保存下来，可以被cache进行复用，这个pipeline也被称为pipeline state object （PSO）。

  

Gles只能使用分散的独立API设置

Vulkan和Metal都支持以整体的方式在创建pipeline的时候设置所有的固管参数，同时也还支持使用独立的API设置某个单独的参数。

  

Vulkan中创建pipeline的时候需要传入的VkGraphicsPipelineCreateInfo结构中包含了所有要使用的固管参数

metal在创建pipeline时传入的MTLRenderPipelineDescriptor也是类似的结构，但是metal的PSO（MTLRenderPipelineDescriptor)能包含的固管参数相比vulkan显得有限，还是有很多固管参数在metal上需要调用它的rendercommandencoder的相关API单独设置，而不能作为PSO创建的一部分。

  

如下是三大API可以设置的主要固定管线参数的对比

  

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|||Gles<br><br>（单独API设置）|Metal<br><br>（封装在MTLRenderPipelineDescriptor的部分）|Metal<br><br>（只能通过encoder单独设置的部分）|Vulkan<br><br>（封装在VkGraphicsPipelineCreateInfo）|
|shader/<br><br>program||glUseProgramglProgramBinary|MTLRenderPipelineDescriptor||VkPipelineShaderStageCreateInfo|
|Tessellation Control|||TessellationFactor||VkPipelineTessellationStateCreateInfoT|
|post vertex processing|viewport|glViewPort||setviewport|VkPipelineViewportStateCreateInfo|
|rasterizaiton|Rasterization Enabled|glenable (RASTERIZER_DISCARD)||rasterizeEnabled|VkPipelineRasterizationStateCreateInfo|
|sample shading|glenable（SAMPLE_SHADING）glMinSampleShading|Not Supported||VkPipelineMultisampleStateCreateInfo|
|Depth Offset|glLineWidth|Not Supported||VkPipelineRasterizationStateCreateInfo|
|FrontFace/CullingMode|glFrontFaceglCullFace||setFrontFacingWinding<br><br>setCullMode|VkPipelineRasterizationStateCreateInfo|
|Polygon Depth Offset|glenable(POLYGON_OFFSET_FILL)<br><br>glPolygonOffset()||SetDepthBias|VkPipelineRasterizationStateCreateInfo|
|Early Per-Fragment Test|ScissorTest|glScissor||SetScissorRect|VkPipelineViewportStateCreateInfo|
|Sample Coverage Mask|glSampleMask<br><br>glSampleCoverage|Not Supported||VkPipelineMultisampleStateCreateInfo|
|Post Per-Fragment Test|AlphaToCoverage|glenable （SAMPLE_ALPHA_TOCOVERAGE)|alphaToCoverageEnabled||VkPipelineMultisampleStateCreateInfo|
|Post （or Early）Per-Fragment Test|AlphaToOne|Not Supported|alphaToOneEnabled||VkPipelineMultisampleStateCreateInfo|
|DepthBoundTest|Not Supported|Not Supported||VkPipelineDepthStencilStateCreateInfo+vkCmdSetDepthBounds|
|StencilTest|glStencilFuncglStencilOpglStencilMask||setDepthStencilState|VkPipelineDepthStencilStateCreateInfo|
|DepthTest|glEnable(GL_DEPTH_TEST)+glDepthFuncglDepthMask||setDepthStencilState|VkPipelineDepthStencilStateCreateInfo|
|（Color）Framebuffer Operations|Blending(float)|glBlendFunc|作为colorAttachments的成员||VkPipelineColorBlendStateCreateInfo|
|Logic Operation(int)|Not Supported|||VkPipelineColorBlendStateCreateInfo|
|Color Write Mask|glColorMask|作为colorAttachments的成员||VkPipelineColorBlendStateCreateInfo|

  

下面将逐个讨论这些固管流程和用到的API（具体的API都在上表中统一列出，下面文本中不再重复），限于本文不是一个图形学教程，因此重点只讨论API的设计和使用，图形学原理不做深入讲解。

  

### 5.3.3 Vertex Processing

  

所有用于产生供硬件光栅化的顶点和图形原语的阶段都统一叫做vertex 阶段（或geometry阶段），不知包含最重要的vertex shading，还包括geometry，tesselation,mesh等shading。

  

Vertex Shading 阶段

Vertex Shader阶段的固定管线设置主要是设置顶点数据流的获取方式，详细见5.4.2

  

Tesselation 相关参数

Tesselation阶段是vs之后的阶段，它是一个可以选择不配置的阶段，用于在原有的几何图原上扩充出新的图原，即加密网格。

Tesselation阶段还要细分成3个阶段。

● 首先是一个可编程多shader 叫做Tesselation Control Shader，metal上则是用一个computeshader实现，并且叫做Tesselation Factor Compute Kernel。它的输入是一个个patch，输出是每个patch的一些用于细分的参数，如内外level等，以及逐顶点和逐patch的其他变量。

● 然后是固定管线的Tesselation Generation阶段，管线基于前面输出的细分参数对patch进行细分，得到细分后到顶点。

● 最后一步是一个可编程等shader叫做Tesselation Eveluation Shader,用来对每个patch细分出来的新的顶点（可附带控制点）做一次顶点处理，计算最终的顶点属性（如位置等）。

注意在metal上，并没有一个单独的Tesselation Eveluation Shader概念，metal上还是复用Vertex Shader，也就是说在metal上，如果开启了tesselation，那么会先执行tesselation，再执行vertex shader。

![](https://km.woa.com/asset/00010002240600b980e4e85f7b411202?height=1288&width=284)

  

经过Tesselation之后，管线基于当前的图原类型将顶点组装成图原。

Tesselation阶段除了指定所需的两个shader外，我们能控制的参数比较少。

  

在gles上没有什么参数可以设置。

在vk上，只能设置控制点数量，即VkPipelineTessellationStateCreateInfo中的patchControlPoints。

在metal上，可以在MTLRenderPipelineDescriptor上设置一些关于控制点和内外factor相关的参数。

  

Gemotry Shader

大部份API在Primtive装配好之后，还有一个可编程的shader阶段，Geometry Shader，它对整个图原即primitive进行变换，输入是一个primitive，输出新的（可能是更多的）pritimive和新的的顶点，同时输出的primitive可以选择输出到特定layer的viewport上。因为可以对一个primitive 反复输出多次，我们也可以利用gs来达到做instancing 绘制的目的。

  

metal上没有这个阶段，但是metal存在一个类似的叫做vertex amplifacation的机制，它相当于在vs之后，生成多个一样的图原，并可以在shader中改变不同图原的顶点属性，也可以设置某个图原发送到哪个viewport。在MTLRenderPipelineDescriptor设置setMaxVertexAmplificationCount来设置重复的次数。

  

基于GS而不是GPU Instancing做instance 绘制的方法的好处是节省了Vertex Shader的处理时间，顶点只处理了一次。

GS阶段没有管线参数给我们设置。

  

### 5.3.4 Post Vertex Processing

  

顶点阶段之后,需要对处理后的顶点做一些固定管线操作，才能继续进行光栅化。

![](https://km.woa.com/asset/00010002240600c288615f312144c702?height=886&width=330)

  

transform feeback

我们可以把管线到此时输出的顶点属性存储到一个buffer中，我们可以设置记录哪些属性，以及是否开启。事实上这个固定管线行为只在较老的API下存在，因为新的API下，我们可以在VS中直接将数据写到一个buffer中，所以Vulkan和metal都没有这个部份，不过vulkan确实有VK_EXT_transform_feedback这样一个扩展。

  

在gles下使用TransformFeedbackVaryings设置记录哪些属性，使用Begin/End/Pause/ResumeTransformFeedback控制开启这个流程。

  

Flat Shading

我们可以设置对于某个顶点属性或者变量，在一个图原上的所有顶点都设置成一样的（设成该图原的第一个顶点），这样光栅化也不会对其进行插值，这叫做flat shading，这个步骤就是做这个把一个primitive的所有顶点的值设成一致。一般int/uint形式的变量也都是flat shading的。这里没有可设置的管线参数。

  

Primitive Clipping

基于顶点阶段输出的顶点位置，剪裁掉那些不在视锥内的顶点，并在图原同视锥的交叉处产生新的顶点。这里没有可设置的管线参数

  

Coordinate Transformation

这步将剪裁坐标系下的坐标映射到frame buffer上的像素坐标。

这里我们可以设置两个重要参数：

1 在Framebuffer上的绘制区域，我们并不一定要画满整个framebuffer，而是选取它的一个矩形区域绘制场景，这个区域也叫做viewport，它的单位是像素，默认是整个framebuffer，viewport决定了我们光栅化的规模，即光栅化出来多少个像素。

2 深度映射关系，前面一步剪裁后的深度范围一般是诡异化的-1，1，这一步可以选择在framebuffer上这个深度值的范围，默认是到0，1。

  

在gles上，设置viewport绘制区域使用glViewport，设置深度映射使用glDepthRangef.

在Vulkan上，则在VkGraphicsPipelineCreateInfo里的结构VkPipelineViewportStateCreateInfo上设置，里面的VkViewport结构如下

```
typedef struct VkViewport {    float    x;    float    y;    float    width;    float    height;    float    minDepth;    float    maxDepth;} VkViewport;
```

  

x y width height 表达视口，minDepth，maxDepth表达映射到到深度范围。

在metal上通过单独API设置。

  

### 5.3.5 Rasterization

  

![](https://km.woa.com/asset/0001000224060069d4bfec081941f902?height=652&width=848)

  

  

光栅化的流程中负责从顶点数据装配图元，然后将clip坐标范围内的图元根据viewport的像素大小离散成像素。

注意VS中标记成flat shading的output，不会被光栅化，而是给primitive的每个vertice相同的output

  

Rasterization Discard

一些图元允许不走光栅化及其之后的管线，例如做transform feedback时。

API见前面表格

Rasterization

考虑对point，line，polygon三种图元进行光栅化

● Point：point不是一个点，而是被光栅化成有一定大小的正方形，并且正方形内所有的像素的插值结果都是一样的，正方形的大小不是在api中指定的，而是在vs里面给built-in的变量赋值，默认是1，如gles中这个变量是gl_PositionSize

● Line：一般使用Breinham画线算法对线段进行离散化，可以指定线的宽度。

gles中glLinewidth，vk设置VkPipelineRasterizationStateCreateInfo 的lineWidth，metal中不能设置线条宽度，若设置宽度，只能用plolygon模拟。

● polygon:因为一个多边形有正面和背面两个面，要考虑指定绘制哪个面，以及怎样定义正面。

定义正面：CCW规则-按顺序读取polygon的顶点（window坐标系下），如果他们是逆时针的，则面向我们的面是正面。CW规则则相反。

在非opengl系统下，一般默认是CW规则，模型在制作阶段也是按照CW规则保存顶点序列的，但是opengl下面，因为3D坐标系是Z轴朝外,和其他系统相反，所以为了保证一致，opengl下面默认要使用CCW规则认为是面朝向我们。

API见前面表格

  

depthoffset：可以将光栅化的多边形整体在深度上加微小位移（如解决z flipping的问题），这里面一般需要两个参数（m,n)得到这个位移：

m × factor + r × unit

factor是polygon整体在深度上的斜率，unit则是在光栅化阶段能够度量的最小的差异。

使用这种方式指定位移和直接在vs里面偏移深度是不一样的，vs里面对深度的偏移不知道当前硬件最小可以偏移多少。

API见前面表格

  

### 5.3.6 MultiSample

  

multisample是光栅化中的一个重要概念，光栅化阶段可能对同一个pixel再细化为多个sample，这就是MSAA（multi sample anti aliasing）

  

开启的条件

开启的条件是当前的framebuffer设置的sample数量大于1。具体到API上：

gles下面RenderBufferObject的SAMPLES 数量> 1 ,gles下面只有RBO（而不是FBO）可以做为multisample rt。

vk下面：VkAttachmentDescription 的samples > 1,同VkPipelineMultisampleStateCreateInfo 中的rasterizationSamples相等

metal下面：mtltexture的sample >1,同MTLRenderPipelineDescriptor的rasterSampleCount

相等

  

sample coverage

对于msaa的情况，每个pixel要有一个和sample数量相同bit位的值，称为sample coverage，标记某个sample被primitive覆盖的情况，这个sample coverage也是在光栅化产生的，这个coverage也用来被计算最终这个pixel的value。（例如最终需要将msaa的rt resolve成单sample的rt时，对每个sample来说，用coverage对其sample的value做加权平均）

  

sample 个数，sample的位置，sample的shading 量

在移动端，假设msaa的倍数为N，则实际上这个pixel有N个sample,每个sample有固定的位置，可以通过api查询，但是不能设置，实际上对sample shading的次数并不一定等于N，sample数量<=N（比如非边缘地区只需要产生1次sample shading，那其他的sample都都赋予相同的值）。我们可以强行控制对于1个pixel最少进行的sample shading数量，gles和vulkan设置见上表API，metal不能定义最小sample shading量。

  

  

### 5.3.7 Early Per-Fragment Test

  

![](https://km.woa.com/asset/00010002240600763c5049033e4b6102?height=801&width=669)

这是在Fragment Shader前后发生的两批固定光线阶段（Early Per- Fragment Tests 和 Per- Fragment Tests )。

管线可以控制将Per- Fragment Tests中的操作(除了alphatocoverage和alphatoone）也全都挪到Early Per- Fragment Tests中执行，即所有的 Per- Fragment Tests全在Fragment Shader 之前执行，因为在ps之前事实上就已经能获得了深度。

gles，vulkan，metal都是通过在shader中声明early_fragment_tests 打开这个特性。

不过early test并不一定因为声明了就一定打开，例如在ps里面显示的写入了深度值，则一般会导致early z失败，因为这要求ps一定要得到执行之后才能获得深度。

  

如果不打开Early Tests，则这个early per fragment test阶段只包含如下两个固管流程：

Scissor Test

对FrameBuffer上的像素基于一个矩形区域做裁剪。

apI见前面表格

  

Sample Coverage Mask

（在msaa下）对于pixel的每一个sample进行mask测试，即将一个mask值同当前sample的coverage按位与，这样可以裁剪掉一些我们不想要的sample。

gles和vulkan的API见上表，metal没有这个阶段。

  

### 5.3.8 Post Per-Fragment Test

  

alpha to coverage /alpha to one

  

第一步可选择将（color0 的）alpha值转化为coverage，我们知道msaa只对不透明物体的边缘有效，对alphatest的镂空边没有效果，这里对alphatest物件，将其alpha值转化到coverage之后，其镂空边部分也从全覆盖转成了半覆盖，在resolve最终color时同其他物体混合，在msaa下相当于对alphatest也做了类似msaa效果。

  

下一步可选择将（color0 的）alpha值统一转化为1，这样我们可以实现对alpha test的物体首先用alpha表示coverage，然后再转成1，以使得后面半透明对其blending时仍然把他当作不透明物体来看。

  

API见上表。注意gles不能支持alpha to one。

  

下面几个阶段都可以放在early test阶段。

  

Depth Bounds Test

裁剪处于一些depth 区间内的像素。只有Vulkan可以支持，API见上表。

  

Stencil Test And Write

按照stencil的值进行剪裁，然后写入stencil值。

即按照写入的bit位进行剪裁，通过API设置stencil的测试函数和测试之后的写入函数。

  

Depth Test And Write

按照depth的值进行剪裁。

通过API设置depth的测试函数和是否写入。

注意因为depth测试在后，Depth测试失败，依然会写入正确的stencil。

  

Sample Count Query

如果这个Primitive绘制前开启了occlusion query，那么在这里它的occlustion query sampler counter 就会为每个coverage为1的sampler增加1个。在后面就可以查到这个primtive通过了遮挡。

  

### 5.3.8 Framebuffer Operation

  

![](https://km.woa.com/asset/000100022406003072a541ca5e4c7402?height=363&width=1180)

  

这是最后的一个固定管线阶段，完成color的framebuffer的合成。

  

Blending

将PS的输出的RT通道，同现有的Framebuffer上的值做混合。

只有float类型的RT才支持混和。

如果RT的格式时SRGB（存储gammar空间颜色），则要先将结果转化成linear颜色空间，再混合，最后再转为gammar空间存储。

此处需要API设置混合的函数，见前面表格。 其中gles的rgb和alpha放在一起指定混合函数，vk和metal可以分开指定。

  

LogicOperation

将当前的管线输出结果同现有framebuffer上的值做logic运算。

只有int类型才支持logic运算，这弥补了int类型不能进行blending的不足。

gles不支持logic 运算。vk和metal需要设置API指定运算方式，见上面的表格。

  

Color Write Masks

最后一步将color写入framebuffer。（depth stencil已经在前面test之后写入了）

这里还可以通过API控制哪个通道的哪个RGB component参与写入。即color mask。API见上面的表。

  

# 六、管线数据

  

GPU管线在运行的过程中，会访问各种存在于GPU上的内存数据，或GPU上的对象。

  

## 6.1管线可绑定的数据类型

  

管线由固定管线，可编程shader组成，当我们配置好了固定管线参数，设置好了shader代码之后，管线的骨架就已经形成了，这时我们还需要向管线中运送数据，以实现数据的处理。管线中需要运送数据的位置有如下：

![](https://km.woa.com/asset/00010002240600cc6358632b864c6702?height=1001&width=905)

  

##   

数据绑定

这些数据需要绑定到管线的特定的绑定点上,才能被管线获取使用，且这些数据大多数都是提供给可编程的shader部分使用，绑定的原始数据通常是在在Device上创建的，也称为资源，这些绑定点及其绑定的资源有：

  

顶点数据：

● Vertex Data : 顶点流数据，绑定buffer资源，

● Index Data： primitive的索引数据，绑定buffer资源

  

基于Buffer和Texture资源的数据：

● Uniform Buffer：按照一定的格式/数据布局只读的buffer，他其实是一个各种基本类型的参数的集合。在gles下面我们可以使用gluniform（）去单个设置shader 参数，但是在vk和metal上，都只能将这些参数打包成一个大的集合,存储在buffer中的形式提供给Shader。这里之所以叫做Uniform，是说这些参数在shader的每个线程中值都是一样的，因为是cpu传入进来后就不会被改变。

  

● Storage Buffer： 无序访问的可读又可写的Buffer，这个buffer的大小通常比较大（至少16M），所以它一般存储在GPU Memory上，而不是GPU 片上的L2 cache，它的读取效率差于Uniform Buffer，但是容量够大。虽然Vertex Buffer也同SSBO的存储特点类似（事实上很多硬件的VBO就是SSBO），但是通常Vertex Buffer会有专门的硬件读取优化（所以例如把instance buffer放在VBO里面从顶点流读入要比放在SSBO里面读取或fetch要快）、

  

● （Sampled）Texture： 按照pixel format 只读访问的一块内存。不同于普通buffer，这块内存是以某种Poixel format编码存储的。Texture只能被采样（sample）或读取原始位置的信息（fetch），在硬件实现上，texuture的sample走TPU（Texture Processing Unit），而fetch走LSU（Load/Store Unit),所以sample的性能要好且适配性更好，且sample只能在PS中使用。

  

● Image：按照pixel format可读又可写入的一块内存，即texture的可写入版本。Image的访问只能从原始资源load/store，效率要比Texture的sample和fetch差、

  

● Buffer Texture:本质上是一个buffer，但是它按照一定的pixel format去sample或fetch其中的数据，就像sample或fetch一个texture 一样，是对buffer的封装，也叫buffer view。

  

● Storage Buffer Texture：本质上是一个buffer，但是它按照一定的pixel format去同时随机load /store其中的数据，就像load/store一个texture 一样，也是一种buffer view

  

这些基于buffer和texture的资源再在不同的平台还有其他的名字，如SRV，UAV等，其关系如下

![](https://km.woa.com/asset/0001000224060029d41f1c7cfc47cf02?height=771&width=817)

首先最根本的资源只有buffer和texture。一切都是在他们上面的封装。

  

Uniform Buffer通常特殊看待，因为大小有限（如十几K），以方便利用L2 cache，加速访问，携带CPU传递给shader的只读的参数。

  

其他的资源类型都可以很大，存在与GPU 显存上。一种是只读的（sample，fetch），也叫SRV，包括texture和基于buffer封装的buffer texture。

  

一种是可以同时被随机读写的，主要用在CS管线中，叫做UAV，包括storage buffer，image，和基于buffer封装的storage buffer texture。

  

另外从另一个维度来看，这里buffer的资源形式只有绿色的两种（只读和读写），texture的资源形式有黄色的四种（除了常规的两种，还包括从buffer翻译归来的两种）

  

  

  

其他：

● Framebuffer：表示fragment shader的输出，它一般来自于一个Texture（只有再gles上可以来自于一个buffer，即Render Buffer Object）。能用作Frame Buffer的Texture类型和能用做Texture sample的类型的集合是不等同的。

● samplers：用来定义如何对texture进行采样，多个texture可以复用一个

● Indirect Buffer：用来存储Indirect Draw/Dispatch的参数，一般由CS进行写入。

● Query Object：存储查询结果

● Barriers/Sync Object：用来插入渲染指令流中，做指令执行和内存的同步

  

下面我们对于这几种类型的管线数据逐个说明API上的设计和使用。

  

## 6.2顶点数据绑定

  

![](https://km.woa.com/asset/0001000224060023e7c1d2c6a94e3102?height=317&width=752)

  

VS是整个管线的第一步，它的功能是从顶点数据流中读入顶点数据，对于每个顶点运行我们编好程序的vertex shader，输出逐顶点的输出数据。

这里有两个关键的数据要描述，数据流本身，以及顶点属性。

  

Vertex Data Stream ：顶点数据流，管线上预设了几个数据绑定点vertex input bind point，来接入读取源（buffer），我们要在这个绑定点上定义这个数据源的一些属性

● strider两个元素之间的间隔bytes（这不必然等于其中一个元素的属性大小长度）

● InputRate 用于定于逐instance的属性

  

Vertex Attribute：顶点属性，每个定点的数据还有多个属性（如位置，法线，颜色等），因此API定义了一组Vertex Attribute Slot，每个Slot对应一个属性，我们要为每个Vertex Attribute Slot定义它这个属性数据对于每一个顶点来说它在shader中的slotid，它的格式，数据大小，和这个属性数据在该顶点的所有数据中的偏移。

  

同一个buffer也可以同时绑定到多个bind point上形成多个数据源

一个Vertex Data Stream可以只关联一个Vertex Attribute，但是通常会关联多个顶点属性，如下图

![](https://km.woa.com/asset/000100022406007092b7974ec34da002?height=550&width=1272)

这个bind point上绑定的Buffer交叉存储来定点颜色rgb和定点的uv，且都是16bit的，则对于一个定点数据来说，它的stride是20个字节，对于第一个color的attribute来说，它的一个顶点读取的数据size是12个字节，offset为0，而对于第二个UV的attribute来说，它的一个顶点读取的数据size是8个字节，它读取到一个完整的20个字节的定点数据后，因为前面有12各位字节是color，要从第13个开始读取，所以它的offset是12。

  

逐instance的属性

当API支持GPU Instancing之后（即一个drawcall同时绘制多编图形），就需要一个特殊的Vertex Buffer存储逐instance而非逐vertex的属性，因为需要将两种类型的vertex stream区分开来，就要再vertex stream上增加额外的标记，多数API需要额外定义两个信息

● InputRateFunction ：标记这个顶点流是逐instance还是逐vertex数据

● InputRate：或叫做divisor，标记逐个数据是经过多少个（instance或vertex）之后才能拿到下一个数据

  

Vertex Buffer还是Storage Buffer？

通常在一些实现中我们也可以不使用固定管线的vertex stream去装填instance数据，而是使用storage buffer，在VS中从storage buffer中读取，这样更加灵活自由，但是移动端的storage buffer主动读取相比vertex buffer的”硬件填喂“可能性能更差一些。

甚至不止instance buffer，所有的逐顶点数据也可以在vs中从storage buffer中获取，尤其在PC端的现代的基于GPU scene的管线下，Vertex Buffer的作用和地位逐渐被storage buffer取代了（这时VB只包含一个极其简单图形的顶点数据，而一个完整模型被拆成了大量的简单图形，api中只是对逐个简单图形绘制多个instance，在vs中，从 storage buffer中根据当前的instance id和顶点id获取正确的顶点和instance属性，这就是cluster rendering的实现基础）。

  

  

Index buffer

我们可以直接从顶点组装成图原，但是为了复用顶点，一般会先从一个索引buffer中读取顶点在vertexstream中的索引，即index buffer，管线中只存在一个可以绑定index buffer的bind point，管线从这里获取图原的索引数据。

  

在API中还支持设置一个值叫做vertex restart index，它标志着在使用traingle_fan等类型绘制primitive的时候，读取到某个特定的索引值，就重启一个新的三角形（而不是继续接连在之前的三角形上）。

  

Vertex Attribute，Vertex Data Stream，Index buffer，图原类型，vertex restart index 是vertex shader运行时要设置的全部管线参数。

  

Vulkan

Vulkan中VkGraphicsPipelineCreateInfo里面的参数VkPipelineVertexInputStateCreateInfo用来描述vertex属性相关的这些信息

```
typedef struct VkPipelineVertexInputStateCreateInfo {    VkStructureType                             sType;    const void*                                 pNext;    VkPipelineVertexInputStateCreateFlags       flags;    uint32_t                                    vertexBindingDescriptionCount;    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;    uint32_t                                    vertexAttributeDescriptionCount;    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;} VkPipelineVertexInputStateCreateInfo;
```

其中VkVertexInputBindingDescription描述Vertex Data Stream，

VkVertexInputAttributeDescription描述Vertex Attribute，vkCmdBindVertexBuffers用来给某个binding 绑定buffer数据。

VkGraphicsPipelineCreateInfo里面的参数VkPipelineInputAssemblyStateCreateInfo则用来描述图原类型和restart index。

  

```
typedef struct VkPipelineInputAssemblyStateCreateInfo {    VkStructureType                            sType;    const void*                                pNext;    VkPipelineInputAssemblyStateCreateFlags    flags;    VkPrimitiveTopology                        topology;    VkBool32                                   primitiveRestartEnable;} VkPipelineInputAssemblyStateCreateInfo;
```

  

vkCmdBindIndexBuffer用来绑定buffer到index buffer上，index buffer不像vertex binding有多个流，它只有一个

  

Vk的VkVertexInputAttributeDescription只能描述逐个stream是顶点数据还是逐instance数，并不能描述inputrate，需要使用扩展VK_EXT_vertex_attribute_divisor。

  

Metal

Metal中MTLRenderPipelineDescriptor里面的参数结构MTLVertexDescriptor描述了Vertex data stream（layouts）和Vertex Attribute信息（attributes），用Encoder的SetVertexBuffer来绑定顶点的buffer数据

Metal的IndexBuffer不是预先绑定的，而是在调用绘制API 如drawIndexedPrimitives

时在参数中指定。

MTLRenderPipelineDescriptor里面的MTLRenderPipelineDescriptor描述图原类型。而metal中始终使用一个特殊的索引值0xFFFFFFFF表示restart。

  

GLES

gles中有多种方式定义顶点数据，且API较多。

1.  不使用vertex buffer，gles2.0的方式，直接使用API VertexAttrib{1234}f把数据从CPU传送给GPU上的某个attribute

2.  gles 2.0的方式，只支持使用单个vertex buffer（即gles上的generic vertex buffer）：

a.  先创建vertex buffer和index buffer，并用glBindBuffer将其绑定

b.  定义attributer并同buffer绑定：使用VertexAttribPointer( uint index, int size, enum type,boolean normalized, sizei stride, constvoid *pointer )，其中pointer是绑定再generic vertex buffer point上的buffer的数据位移

3.  gles3.0的方式，支持使用多个 vertex buffer

a.  创建buffer本身：首先gles中用于vertex buffer的buffer 类型叫做ARRAY_BUFFER,用于index buffer的buffer类型叫做ELEMENT_ARRRAY_BUFFER,首先需要使用glbuffer()来创建buffer。

b.  绑定buffer到vertex bindpoint：这里不再使用通用的glbindbuffer（）（因为这个API不能指定bind point index，它只能绑定在generic bind point上），这里用glBindVertexBuffer才能将某个buffer绑定到一个vertex input bind point上，并同时指定这个stream的属性。

c.  定义attribute：用VertexAttribFormat 定义vertex attribute的属性。

d.  attribute同bindpoint绑定：用vertexattribbinding将某个vertex input bind point同某个vertex attribute相连。

e.  绑定index buffer，index buffer只有一个绑定点，所以使用通用的glbuffer绑定indexbuffer

4.  使用host一侧的buffer作为顶点数据：同样使用VertexAttribPointer( uint index, int size, enum type,boolean normalized, sizei stride, constvoid *pointer )，但是此时不要绑定vertex buffer，即将ARRAY_BUFFER绑定点绑定为0，pointer就是指向CPU上的内存。

  

另外要通过EnableVertexAttribArray来启用某个attribute，用VertexAttribDivisor来设置stream是逐instance的，。

用Enable/Disable(PRIMITIVE_RESTART_FIXED_INDEX.)来开启primitve restart。

gles下面设置图原类型的方式是包在了调用绘制指令时如glDrawElements。

  

## 6.3 Buffer和Texture来源的数据绑定

  

从上面的分类可以看出，Buffer 和 Texture一般是主要的渲染数据来源，所以我们谈渲染资源，一般狭义讲的就是buffer和texture。

  

绑定buffer和texture资源有两种方式：

● 单个绑定，通过单个API逐个资源进行

● 整体绑定，通过一个整体的（包含多个甚至整个管线所使用的全部资源）数据结构，一次性绑定，这是高级API支持的效能更高的方式

  

### 6.3.1 Metal和Argument Buffer

  

#### 6.3.1.1 Metal上Buffer和texture的创建

Metal上可以直接创建资源，也可以从一个堆MtlHeap创建资源（后者对内存的利用性能更好）

  

创建buffer

[device newBufferWithLength: bufferSize options: MTLResourceStorageModeShared];

[heap newBufferWithLength:bufferSize options:MTLResourceStorageModePrivate];

  

创建texture

newTextureViewWithPixelFormat:(MTLPixelFormat pixelFormat)

heap newTextureWithDescriptor:(MTLPixelFormat pixelFormat)

  

创建buffertexture

在创建了buffer之后，再通过

MtlBuffer::newTextureWithDescriptor 创建。

  

#### 6.3.1.2 Metal 上buffer和texture的管线绑定

  

在Metal中，没有在API层面区分各种不同用处的vertex和 buffer，如uniform buffer 和storage buffer，或者texture和image，统一叫做buffer和texture，其设置给管线的API是一致的，至于具体怎样分类存储metal在底层自动进行，比如shader中使用const 修饰的buffer，metal就会认为是一个uniform buffer。

  

单个绑定

绑定给管线的接口是直接调用encoder的

setFragmentBuffer

setFragmentTexture

等接口

这里不能将基本数据类型单个绑定，需要将他们打包成uniformbuffer。

  

整体绑定

即ArgumentBuffer，它用一种特殊的buffer包含所有数据。典型用法

● 基于shader function创建一个argumentencoder，用来向argumentbuffer填充数据

  

```
id <MTLArgumentEncoder> argumentEncoder =    [fragmentFunction newArgumentEncoderWithBufferIndex:bufferindex];
```

  

其中bufferindex是整个argumentbuffer再shader中定义的index

● 基于argumentencoder的长度信息创建arugmentbuffer，并设置给这个encoder

  

```
_fragmentShaderArgumentBuffer = [_device newBufferWithLength:argumentEncoder.encodedLength options:0];argumentEncoder setArgumentBuffer:_fragmentShaderArgumentBuffer offset:0
```

  

● 往buffer里面设置管线数据

  

```
[argumentEncoder setTexture:_texture atIndex:AAPLArgumentBufferIDExampleTexture];[argumentEncoder setSamplerState:_sampler atIndex:AAPLArgumentBufferIDExampleSampler];[argumentEncoder setBuffer:_indirectBuffer offset:0 atIndex:AAPLArgumentBufferIDExampleBuffer];
```

  

可以设置的管线数据包括所有可以在uniformabuffer中定义的数据，以及buffer，texture，还包括indirect command buffer。

● 将argumentbuffer整体绑定给shader，就像设置一个普通的buffer一样

  

```
[renderEncoder setFragmentBuffer:_fragmentShaderArgumentBuffer                          offset:0 atIndex:bufferindex];
```

  

### 6.3.2 Vulkan和Descriptor

  

#### 6.3.2.1 Vulkans上Buffer和Texture的创建

  

创建Buffer

vkCreateBuffer( VkBufferCreateInfo* pCreateInfo )

  

```
typedef struct VkBufferCreateInfo {    VkStructureType        sType;    const void*            pNext;    VkBufferCreateFlags    flags;    VkDeviceSize           size;    VkBufferUsageFlags     usage;    VkSharingMode          sharingMode;    uint32_t               queueFamilyIndexCount;    const uint32_t*        pQueueFamilyIndices;} VkBufferCreateInfo;
```

  

其中VkBufferUsageFlagBits要设置成正确的buffer资源用途，如

  

```
VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
```

  

创建buffertexture

  

vk里面把buffer texture叫做buffer view。创建bufferview通过在已有的一个buffer上调用

VkResult vkCreateBufferView( VkDevice ，const VkBufferViewCreateInfo const VkAllocationCallbacks VkBufferView* ，device, pCreateInfo, pAllocator, pView);

  

```
typedef struct VkBufferViewCreateInfo {    VkStructureType            sType;    const void*                pNext;    VkBufferViewCreateFlags    flags;    VkBuffer                   buffer;    VkFormat                   format;    VkDeviceSize               offset;    VkDeviceSize               range;} VkBufferViewCreateInfo;
```

  

创建Texture

vulkan中最底层的Texture对象是VkImage，但是他不能直接当成资源用，要创建基于VkImage的VkImageView，才能设置给管线。

创建VKImage

vkCreateImage( VkImageCreateInfo* pCreateInfo, VkImage)

  

```
typedef struct VkImageCreateInfo {    VkStructureType          sType;    const void*              pNext;    VkImageCreateFlags       flags;    VkImageType              imageType;    VkFormat                 format;    VkExtent3D               extent;    uint32_t                 mipLevels;    uint32_t                 arrayLayers;    VkSampleCountFlagBits    samples;    VkImageTiling            tiling;    VkImageUsageFlags        usage;    VkSharingMode            sharingMode;    uint32_t                 queueFamilyIndexCount;    const uint32_t*          pQueueFamilyIndices;    VkImageLayout            initialLayout;} VkImageCreateInfo;
```

其中的VkimagUsageFlags需要描述正确的用途，如采样，写入还是关联Framebuffer

```
VK_IMAGE_USAGE_SAMPLED_BITVK_IMAGE_USAGE_STORAGE_BITVK_IMAGE_USAGE_COLOR_ATTACHMENT_BITVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BITVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
```

创建ImageView

VkResult vkCreateImageView(

VkDevice device,

const VkImageViewCreateInfo* pCreateInfo,）

  

```
typedef struct VkImageViewCreateInfo {    VkStructureType            sType;    const void*                pNext;    VkImageViewCreateFlags     flags;    VkImage                    image;    VkImageViewType            viewType;    VkFormat                   format;    VkComponentMapping         components;    VkImageSubresourceRange    subresourceRange;} VkImageViewCreateInfo;
```

  

#### 6.3.2.2 Vulkan上Buffer和textuer的管线绑定

  

Vulkan上完全抛弃了单独绑定资源的接口，必须整体绑定，它与metal中argument buffer对应的概念叫做Resource Descriptor。

  

相比metal，vulkan的概念更抽象和解耦。

首先要定义一个资源的布局，他表示shader中一批资源的类型和位置，叫descripter set layout，其中包含了一些descripter的集合，每个descripter表示一个资源。

对于特定的一个drawcall，需要基于这个布局创建一个资源组的实例，其中每个成员是一个具体的要绑定的资源。

最终将descripter set整体绑定给shader

  

![](https://km.woa.com/asset/000100022406000a5501e69f5f413c02?height=498&width=837)

  

一个shader的所有的资源被分解到多个不同的descripter set layout上。

  

Descriptor要包含

● binding index，shader 中的binding index

● arraylement和count，如果是数组，它的起始位置和长度

● type 类型

  

所有的descripter type有：

● sampled image :texture for sample/fetch

● Combined image sampler: a sampler+ a sampled image

● Storage Image ：load/store/atomic op image

● sampler

● unitform texel buffer : buffer texture for sample/fetch

● storage texel buffer: buffer texture for load,store,atomic op

● uniform buffer

● storage buffer :buffer for load, store, atomic

● dynamic uniform buffer: uniformbuffer+offset ，dynamic buffer需要再绑定descripterset的时候指定它的offset

● dynamic storage buffer:storage buffer+offset

● inline uniform block: uniformbuffer 不来自一个普通的buffer，而是直接来自这个descripter set本身

● Input attachment : image view for subpass local load

  

我们对比vulkan的descripter和metal的augument buffer在存储数据上有一个最大的区别是，argument buffer中没有uniform buffer，而是直接写入各种基本类型及其数组，而descripter中不包含基本类型，要将他们统一封成uniform buffer。

  

创建DescripterSetLayout

VkResult vkCreateDescriptorSetLayout(

VkDevice device,

const VkDescriptorSetLayoutCreateInfo* pCreateInfo,

const VkAllocationCallbacks* pAllocator,

VkDescriptorSetLayout* pSetLayout);

  

  

```
typedef struct VkDescriptorSetLayoutCreateInfo {    VkStructureType                        sType;    const void*                            pNext;    VkDescriptorSetLayoutCreateFlags       flags;    uint32_t                               bindingCount;    const VkDescriptorSetLayoutBinding*    pBindings;} VkDescriptorSetLayoutCreateInfo;typedef struct VkDescriptorSetLayoutBinding {    uint32_t              binding;    VkDescriptorType      descriptorType;    uint32_t              descriptorCount;    VkShaderStageFlags    stageFlags;    const VkSampler*      pImmutableSamplers;} VkDescriptorSetLayoutBinding
```

  

需要定义这个setlayout里面的每个descripter的binding（位置），type，count（数量）

创建Descripter Set

Descripter Set使用池VKdescriptorPool来维护。

首先需要创建一个池

vkCreateDescriptorPool

  

然后从池子里面创建或回收descriptor set

vkAllocateDescriptorSets

  

填充DescriptorSet的数据，有write和copy，template三种方式

write和copy这两种方式通过同一个API

vkUpdateDescriptorSets

  

```
void vkUpdateDescriptorSets(    VkDevice                                    device,    uint32_t                                    descriptorWriteCount,    const VkWriteDescriptorSet*                 pDescriptorWrites,    uint32_t                                    descriptorCopyCount,    const VkCopyDescriptorSet*                  pDescriptorCopies);
```

其中VkWriteDescriptorSet代表write进去的，VkCopyDescriptorSet为copy进去的。

  

write的结构

  

```
typedef struct VkWriteDescriptorSet {    VkStructureType                  sType;    const void*                      pNext;    VkDescriptorSet                  dstSet;    uint32_t                         dstBinding;    uint32_t                         dstArrayElement;    uint32_t                         descriptorCount;    VkDescriptorType                 descriptorType;    const VkDescriptorImageInfo*     pImageInfo;    const VkDescriptorBufferInfo*    pBufferInfo;    const VkBufferView*              pTexelBufferView;} VkWriteDescriptorSet;
```

  

其中image和sampler放在piamgeinfor里，buffer放在pbufferinfo里

  

copy的结构

```
typedef struct VkCopyDescriptorSet {    VkStructureType    sType;    const void*        pNext;    VkDescriptorSet    srcSet;    uint32_t           srcBinding;    uint32_t           srcArrayElement;    VkDescriptorSet    dstSet;    uint32_t           dstBinding;    uint32_t           dstArrayElement;    uint32_t           descriptorCount;} VkCopyDescriptorSet;
```

  

它从一个descripterset 拷贝到另外一个。

  

基于模板更新

有的时候，我们需要在多个descripterset之间复用一些数据，就可以把这些公用的数据抽象到一个template里面

![](https://km.woa.com/asset/0001000224060062a8f0138904481902?height=470&width=976)

我们先创建一个cpu一侧的buffer，并写入这些公用数据，其中包含了要写入descripterset中的内容（buffer，image的handle）

  

再定义这个模板和数据的映射关系

vkCreateDescriptorUpdateTemplate

  

```
typedef struct VkDescriptorUpdateTemplateCreateInfo {    VkStructureType                           sType;    const void*                               pNext;    VkDescriptorUpdateTemplateCreateFlags     flags;    uint32_t                                  descriptorUpdateEntryCount;    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;    VkDescriptorUpdateTemplateType            templateType;    VkDescriptorSetLayout                     descriptorSetLayout;    VkPipelineBindPoint                       pipelineBindPoint;    VkPipelineLayout                          pipelineLayout;    uint32_t                                  set;} VkDescriptorUpdateTemplateCreateInfo;typedef struct VkDescriptorUpdateTemplateEntry {    uint32_t            dstBinding;    uint32_t            dstArrayElement;    uint32_t            descriptorCount;    VkDescriptorType    descriptorType;    size_t              offset;    size_t              stride;} VkDescriptorUpdateTemplateEntry;
```

  

其中每个endtry代表一个映射关系，表示shader中的一个资源，包括它的binding位置，type等。还要定义他在前面的公用数据中对应的数据的offset和stride。

  

最后通过

void vkUpdateDescriptorSetWithTemplate(

VkDevice device,

VkDescriptorSet descriptorSet,

VkDescriptorUpdateTemplate descriptorUpdateTemplate,

const void* pData);

  

完成这个更新

  

将descripter set绑定到管线

API是

  

```
void vkCmdBindDescriptorSets(    VkCommandBuffer                             commandBuffer,    VkPipelineBindPoint                         pipelineBindPoint,    VkPipelineLayout                            layout,    uint32_t                                    firstSet,    uint32_t                                    descriptorSetCount,    const VkDescriptorSet*                      pDescriptorSets,    uint32_t                                    dynamicOffsetCount,    const uint32_t*                             pDynamicOffsets);
```

  

这里可以同时绑定多个descripterset给一个shader。

最后的pDynamicOffsets则是用来表述set中的dynamic buffer的offset

  

另外我们在创建vulkan pipeline的时候，需要提供这个pipeline所有shader stage用到的descriptersetlayout的集合，即pipelinelayout，通过API

vkCreatePipelineLayout

  

### 6.3.3 Gles

  

在gles中，只能逐个资源单独绑定到管线上，且每种资源的绑定API差异很大。

  

uniform

只有gles下允许修改shader中没有定义在任何uniform 里面的单个基本数据类型值，如其中定义的一个float。

通过

ProgramUniform(program, location,v)

Uniform(location,v)

这样的接口

  

事实上gles下面所有的uniform都必须要在shader中定义在一个uniform block里面，这些没有定义在uniform block中的uniform其实是在default block里面

  

uniform buffer

对于定义在uniform block中的uniform，通过uniform buffer的形式更新整个uniform block

● 首先生成buffer，然后将那个buffer绑定到某个index上的uniform buffer bond point上，通过

  

```
void glBindBufferBase(	GLenum target, 	GLuint index, 	GLuint buffer);
```

● 将uniformbuffer绑定给某个uniform block

```
void glUniformBlockBinding(	GLuint program, 	GLuint uniformBlockIndex, 	GLuint uniformBlockBinding);
```

其中uniformblockindex是block的index，uniformblockbinding是绑定点的index

  

Storage Buffer

在gles中称为SSBO（Shader Storage Buffer Object）

SSBO同Uniform的API区别是，只需要生成并通过glBindBufferBase绑定SSBO到某个buffer绑定点上，不需要API将他绑定到ssbo的block上。因为在shader中，需要为ssbo的block声明它对应的buffer binding index。

  

Texture

● 首先设置当前要绑定的是哪个贴图绑定点

void glActiveTexture(GLenum texture)

其中的texture形式如GL_TEXTUREi

● 将贴图绑定到当前active的贴图绑定点上

void glBindTexture(GLenum target, GLuint texture);

  

Image

先创建好texture

使用API绑定

  

```
void glBindImageTexture(	GLuint unit, 	GLuint texture, 	GLint level, 	GLboolean layered, 	GLint layer, 	GLenum access, 	GLenum format);
```

  

其中要指定image的绑定点和绑定的texture

  

Buffer Texture和Storage Buffer Texture

对于绑定操作同普通的texture在API上是一致的，

只是在创建Texture时，调用glBindTexture时的target使用 GL_TEXTURE_BUFFER。

然后调用API

  

```
void glTexBuffer(	GLenum target, 	GLenum internalFormat, 	GLuint buffer);
```

  

将一个buffer同当前绑定的texture关联。

  

Sampler

使用API

```
void glBindSampler(	GLuint unit, 	GLuint sampler);
```

  

  

将这个sampler绑定给unit位置的texture使用。

可以把一个sampler绑定给多个texture unit。

  

# 七、 绘制和Dispath指令

  

在管线设置好之后，需要启动绘制和dipatch指令来启动管线，这就好比准备好一切之后按下启动按钮，GPU收到绘制和dispatch指令后真正的执行工作。

  

## 7.1 Draw

  

对于绘制指令，按照是否使用了index buffer，分为两种。

按照是否使用gpu buffer存储指令参数，又分为直接绘制和间接绘制

  

### 7.1.1 直接绘制

  

#### 7.1.1.1 不基于index buffer

  

基于当前绑定的vertex stream，描述从流中绘制哪个范围的顶点数据，以及instancing的数量。我们通常要指定：

● vertex offset/first vertex ：在vertex stream中的offset

● vertex count ：顶点数量

● instance offset/first instance：如果stream是逐instance的，那么在其中获取的元素的偏移

● instance count：实例绘制数量

  

![](https://km.woa.com/asset/00010002240600e36e08d5ed5847d302?height=487&width=717)

  

  

Vulkan

使用 vkCmdDraw （uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance）

  

Metal

调用rendercommandencoder的drawPrimitives

  

Gles

使用

```
void glDrawArraysInstanced(	GLenum mode, 	GLint first, 	GLsizei count, 	GLsizei primcount);
```

  

  

注意gles从core版本中不能支持在不基于indexbuffer的绘制时指定instance的偏移，但是在扩展EXT_base_instance中定义了DrawArraysInstancedBaseInstanceEXT这样的API。

####   

#### 7.1.1.2基于index buffer

  

这时vertex 不是直接按顺序从vertex stream中拿到，而是先从index buffer中得到待绘制vertex在vertex stream中的index，再从该index处得到vertex数据，这样可以复用顶点数据。

![](https://km.woa.com/asset/0001000224060056a8f59839d9484a02?height=647&width=584)

  

这时候我们通常要指定

● firstindex：在index buffer中的起始序号

● indexcount：绘制的顶点数

● vertexoffset：每次根据index拿顶点时在index上额外增加的偏移

● firstinstance：如果stream是逐instance的，那么在其中获取的元素的偏移

● instance count：instance的绘制数量

  

Vulkan

使用 vkCmdDrawIndexed （uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance）

  

  

Metal

调用rendercommandencoder的drawIndexedPrimitives

  

Gles

使用

```
void glDrawElementsInstancedBaseVertexBaseInstance(	GLenum mode, 	GLsizei count, 	GLenum type, 	void *indices, 	GLsizei instancecount, 	GLint basevertex, 	GLuint baseinstance);
```

  

其中Indices是indice的offset。如果当前没有绑定index buffer（即ELEMENT_ARRAY_BUFFER绑定给0），那么indices就是指向CPU一侧的index buffer（通常很少这样做了，这是为了兼容老版本）。

  

### 7.1.2 间接绘制（基于Indirect Draw Bufer）

  

为了能够读取CS计算写出的绘制指令，而不是直接从cpu提供参数，api提供了间接绘制，通过CS上的逻辑计算需要绘制的具体的内容，是现代基于gpu的pipeline的实现基础，这里的drawindirect只是用来告诉gpu从哪个buffer上获得绘制参数，实际并不包含要绘制的信息。这里的Buffer也叫做Indirect Draw Buffer（IDB）.这种间接绘制也叫做基于Indirect Draw Buffer的间接绘制。

![](https://km.woa.com/asset/00010002240600e1a6131729b245cf02?height=815&width=594)

如上图，如果没有Indirect Draw机制，CPU要想根据CS计算的结果去判断该绘制什么，就要等待GPU执行完后回读CS的结果，导致CPU对GPU的强依赖。

API的Indirect Draw所需的参数通常就是一个gpu buffer(indirect draw buffer)，但是我们要按照API的规则填充整个buffer的内容。有些API可以在这个buffer中描述多个drawcall（称为multi inidrect draw），有些API只能描述一个。MultiIndirectdraw机制允许我们将同一个管线状态下多个不连续区段的vertex在一个drawcall中绘制，是一种可以利用做跨mesh的合批机制。

  

Vulkan

Vulkan的IDB中可以指定多个drawcall。基于非index buffer绘制的API为

  

```
void vkCmdDrawIndirect(    VkCommandBuffer                             commandBuffer,    VkBuffer                                    buffer,    VkDeviceSize                                offset,    uint32_t                                    drawCount,    uint32_t                                    stride);
```

  

其中指定了IDB的buffer，buffer上的offset，buffer上又多少个drawcall，每个drawcall距离下一个的数据长度。

其中buffer中的数据结构必须定义如下

  

```
typedef struct VkDrawIndirectCommand {    uint32_t    vertexCount;    uint32_t    instanceCount;    uint32_t    firstVertex;    uint32_t    firstInstance;} VkDrawIndirectCommand;
```

  

  

类似，还有基于index buffer间接绘制的API

vkCmdDrawIndexed和对应的buffer结构VkDrawIndexedIndirectCommand

  

此外VuvkCmdDrawIndirectCountlkan还能指定绘制数量本身从另一个buffer中读取，给出了两个API

和vkCmdDrawIndexedIndirectCount

  

Gles

Gles的Core API中只能支持定义1个drawcall在IDB 中。

API为glDrawElementsIndirect和glDrawArraysIndirect

  

Gles通过扩展EXT_multi_draw_indirect支持multi indirect draw，给出了两个API

MultiDrawArraysIndirectEXT和MultiDrawElementsIndirectEXT

  

Metal

metal中基于IDB的间接绘制也只能指定一个drawcall（但是Metal中，更推荐的方式是更强大的基于ICB的 间接绘制，可以支持多个drawcall,见下一小节）。

同样是通过RenderEncoder的API

drawPrimitives和drawIndexedPrimitives。

  

  

### 7.1.3 基于Indirect Command Buffer的间接绘制

  

前面基于IDB的间接绘制是让drawcall的参数从GPU buffer上获取。

还有另一种间接绘制，是让整个Command Buffer的内容从GPU buffer上获取，这个command buffer叫做indirect command buffer（ICB）。

我们传统的绘制是在CPU encode一个commandbuffer，gpu执行，在ICB下，这个commandbuffer是允许在GPU上由CS根据计算结果填充的，它比IDB的能力更加灵活，ICB不仅可以由GPU决定一系列的完整的drawcall的参数，还包括这些drawcall的管线状态。

只有Metal支持基于ICB的间接绘制。

  

![](https://km.woa.com/asset/00010002240600988e6925ef1b400302?height=826&width=634)

如上图，基于ICB相比IDB对于管线的效率又有了提升，例如在典型的gpu scene的绘制中，对与上面的IDB来说，我们并不能提前在cpu上知道裁剪结果，所以必须为每个材质都提交一个indirect draw，IDB中会被CS充填每个管线下instance的数量和index，即使这个管线的所有instance都被裁剪掉也要提交，只是最终绘制的instance count为0，这增加了不必要的drawcall。

在ICB下，cpu永远只有一个drawcall，因为所有的绘制结果都直接在gpu上编码进入buffer了。

  

Metal中的API

1 创建ICB

使用MTLIndirectCommandBufferDescriptor来创建

  

```
MTLIndirectCommandBufferDescriptor* icbDescriptor = [MTLIndirectCommandBufferDescriptor new];        // Indicate that the only draw commands will be standard (non-indexed) draw commands.        icbDescriptor.commandTypes = MTLIndirectCommandTypeDraw;        // Indicate that buffers will be set for each command IN the indirect command buffer.        icbDescriptor.inheritBuffers = NO;        // Indicate that a max of 3 buffers will be set for each command.        icbDescriptor.maxVertexBufferBindCount = 3;        icbDescriptor.maxFragmentBufferBindCount = 0;#if defined TARGET_MACOS || defined(__IPHONE_13_0)        // Indicate that the render pipeline state object will be set in the render command encoder        // (not by the indirect command buffer).        // On iOS, this property only exists on iOS 13 and later.  It defaults to YES in earlier        // versions        if (@available(iOS 13.0, *)) {            icbDescriptor.inheritPipelineState = YES;        }#endif        _indirectCommandBuffer = [_device newIndirectCommandBufferWithDescriptor:icbDescriptor                                                                 maxCommandCount:AAPLNumObjects                                                                         options:0];
```

  

  

2 在CPU一侧或GPU一侧填充ICB

ICB上的每个drawcall抽象称为一个数据结构MTLIndirectRenderCommand。

  

CPU一侧

在ICB上生成MTLIndirectRenderCommand，并且调用api设置个dc的渲染管线状态和绘制参数

  

```
id<MTLIndirectRenderCommand> ICBCommand =        [_indirectCommandBuffer indirectRenderCommandAtIndex:objIndex];    [ICBCommand setVertexBuffer:_objectParameters                         offset:0                    atIndex:AAPLVertexBufferIndexObjectParams];    [ICBCommand drawPrimitives:MTLPrimitiveTypeTriangle                   vertexStart:0                   vertexCount:vertexCount                 instanceCount:1                  baseInstance:objIndex];
```

  

GPU一侧

把ICB传给shader，在shader中获取某个位置的rendercommand，并设置管线状态和绘制参数

  

```
render_command cmd(icb_container->commandBuffer, objectIndex);    if(visible)    {        cmd.set_vertex_buffer(object_params,         cmd.draw_primitives(primitive_type::triangle,        object_params[objectIndex].startVertex,object_params[objectIndex].numVertices, 1,                            objectIndex);    }
```

3 执行ICB

调用RenderEncoder的API executeCommandsInBuffer，这就是真正的drawcall

同时还需要说明GPU在这个ICB中需要访问的资源

  

```
[renderEncoder executeCommandsInBuffer:_indirectCommandBuffer withRange:NSMakeRange(0, AAPLNumObjects)];[renderEncoder useResource:_objectParameters usage:MTLResourceUsageRead];
```

## 7.2 Dispatch

  

Dispatch用来启动一个Compute 管线。

它也分为直接dispatch和间接dispatch两种。

Compute执行时要描述KernelThread的数量布局：

● warp的维度

● warp内thread的维度

他们一般都是三维的

  

Warp（或叫做Local WorkGroups、Frontwave...）是CS的kenal工作时的重要概念。

![](https://km.woa.com/asset/0001000224060099bbd19058874de002?height=244&width=238)

一个warp内的thread是指令流一致的，并且共享一些group内的高速缓存（即L1cache），跨warp的thread之间就只能共享全局的内存了（如L2 cache)。在dispatch的时候都要指定这个warp内的三个维度，如果是间接的dispatch，就是从一个buffer中读取这个维度值，用另一个cs决定这个cs的warp 维度。

  

  

Vulkan和Gles只需要在API层面声明Warp的维度，而warp内thread的维度是在Shader中声明的。

  

Vulkan

vkCmdDispatch

vkCmdDispatchIndirect

  

Gles

glDispatchComputeglDispatchComputeIndirect

  

Metal

需要同时声明warp和warp内thread的两种维度，使用computeencoder的API

dispatchThreads

dispatchThreadgroups

如果是indirect的则使用

dispatchThreadgroupsWithIndirectBuffer，它只能从buffer中读取warp的维度值，而thread 的维度值需要直接指定

  

同render command类似，metal也支持对于cs的dispatch录制到ICB上。

首先在ICB上使用indirectComputeCommandAt创建一个MTLIndirectComputeCommand。然后设置这个cs管线的状态和warp，thread维度。

最后用Compute Encoder 的API executeCommandsInBuffer 执行这个ICB。