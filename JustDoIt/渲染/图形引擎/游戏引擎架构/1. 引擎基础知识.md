# 1.1 引擎组成

游戏引擎由很多个模块组成，包括基础组件、输入设备、渲染管线、图形API、动画、物理引擎、粒子系统、UI、资源管理、音频、AI、脚本、网络等。以下是游戏引擎各模块的详细作用及举例。
1) 基础组件：是引擎最基础常用的代码部分，包括线程、委托、智能指针、常用数学、容器、算法、反射、宏与模板、离线代码生成、文件IO库等。
2) 输入设备：处理来自键盘、鼠标、触摸屏、游戏手柄等输入设备的数据。例如，在一款射击游戏中，输入设备模块会处理玩家按下的触发键，使角色发射子弹。
3) 渲染管线：处理游戏中的图形渲染，包括几何处理、光照计算、阴影绘制、纹理贴图、后处理效果等。例如，在一款赛车游戏中，渲染管线会负责绘制赛车、道路、环境等元素，并添加光照、阴影等效果。
4) 图形API：提供底层的图形硬件访问接口，如OpenGL、DirectX、Vulkan等。这使得游戏引擎能够充分利用显卡资源进行高效渲染。例如，通过图形API，游戏引擎可以实现更高级的渲染技术，如光线追踪。
5) 动画模块：处理游戏角色和物体的动画效果，包括骨骼动画、顶点动画、精灵动画等。例如，在一款动作游戏中，动画模块负责使主角在攻击时播放相应的动作动画。
6) 物理引擎：模拟游戏世界中的物理现象，如碰撞检测、刚体动力学、布料模拟、流体模拟等。例如，在一款足球游戏中，物理引擎会负责计算球员与足球的碰撞，以及足球在空中的运动轨迹。
7) 粒子系统：模拟大量小粒子组成的效果，如火焰、烟雾、雨滴等。例如，在一款魔法类游戏中，粒子系统可以用来展示法术施放时的粒子特效。
8) UI模块：负责游戏界面的设计和显示，包括按钮、文本、图像等界面元素的布局和渲染。例如，在一款策略游戏中，UI模块会负责显示玩家的资源、建筑菜单等信息。
9) 资源管理：负责游戏资源（如模型、纹理、声音等）的加载、释放和内存管理。例如，在一款角色扮演游戏中，资源管理模块负责在需要时加载新场景的资源，并在不再需要时释放旧场景的资源。
10) 音频：处理游戏中的声音效果，包括背景音乐、音效、语音等。例如，在一款恐怖游戏中，音频模块负责根据游戏情境播放紧张的背景音乐和突发的惊吓音效。
11) AI模块：处理游戏中的非玩家角色（NPC）的行为和决策，如寻路、策略、战斗等。例如，在一款即时战略游戏中，AI模块负责控制。
12) 脚本模块：脚本模块为游戏开发者提供编写游戏逻辑的接口，通常使用脚本语言如Lua、Python等，便于快速迭代和调试。
13) 网络模块：网络模块负责处理游戏中的网络通信，如客户端与服务器之间的数据传输、多人游戏同步等。


# 1.2 引擎运行时架构

游戏引擎通常由工具套件和运行时组件两部分构成。这里我们主要说运行时组件部分。整个游戏引擎架构可以分为13个层级（运行时架构），每个层级都是只依赖下层，这13个层级分别为：目标硬件层、设备驱动层、操作系统层、平台独立层、第三方中间件、核心库、资产管理层、低阶渲染层、引擎核心层、引擎应用层、业务基础层、游戏框架层、游戏业务层。

![](https://raw.githubusercontent.com/BlairRenaissance/ImageHost/main/20241017113811.png)


# 1.3 引擎容器

一般引擎都会提供许多自定义容器，这些容器能帮助引擎开发者提高开发效率同时也提升性能。

我们知道C++中有很多第三方的容器库可使用，比如STL，Boost，Loki都是非常棒的三方库。STL库最常用，它功能丰富、可移植能力强，但性能差一些包括内存分配效率和容器中的算法性能。Boost库比STL拥有更多功能的容器，同时效率也很高，只是发布许可证有些问题。Loki库功能丰富，复杂度较高，性能未知。

有现成的这么好用的第三方容器库引擎为什么还要开发自己的自定义容器呢？道理很简单，容器使用的业务场景比较复杂，第三方库常常无法满足业务需求，有时是功能、有时是逻辑、有时是算法、有时是性能，因此引擎自己定制容器成了家常便饭。在建立自定义容器需要重点关注三个点，**运用场景、性能、多线程安全。**
1) 运用场景：我们常见的容器包括数组（Array）、动态数组（Dynamic Array）、链表（Linked List）、堆栈（Stack）、队列（Queue）、双端队列（Double-ended Queue）、优先队列（Priority Queue）、树（Tree）、二叉查找树（Binary Search Tree，BST）、二叉堆（Binary Heap）、字典（Dictionary）、集合（Set）、图（Graph）、有向无环图（Directed Acyclic Graph，DAG）等，容器常用操作包括：插入、移除、顺序访问（迭代）、随机访问、查找、排序等，自定义容器在开发时匹配需求便可。
2) 性能：容器的性能主要关注它的算法，算法又分数据结构和逻辑算法，数据结构包括多端缓存、链表、树形结构等，逻辑算法包括排序、散列、索引、映射关系、哈希、红黑树等。
3) 多线程安全：容器的多线程安全主要关注多个线程同时使用一个容器时的逻辑安全，在确保逻辑有效的情况下减少多线程冲突提升多线程计算性能。


UE里有许多容器。它们包括：TArray、TArrayView、TBasicArray、FBinaryHeap、TBitArray、TChunkedArray、TCircularBuffer、TCircularQueue、TDiscardableKeyValueCache、TResourceArray、FHashTable、TIndirectArray、TLinkedList、TIntrusiveLinkedList、TDoubleLinkedList、TList、FLockFreePointerList、TMapBase、TSortableMapBase、TQueue、FScriptArray、TSet、TSortedMap、TSparseArray、TStaticArray、TStaticBitArray、TTripleBuffer、TUnion等等。

通过容器的命名我们一看就能了解它大概的用途：
- **TArray**：动态数组，类似于 C++ 的 `std::vector`。它可以动态地增长和缩小，提供快速的随机访问。
- TArrayView：数组视图，提供对 `TArray` 或其他类型的数组的非拥有引用。
- FBinaryHeap：二叉堆，它是一种特殊的树形数据结构，可以用于实现优先队列。
- TBitArray：位数组，用于存储位级别的布尔值。
- TChunkedArray：分块数组，用于存储大量数据，它将数据存储在多个数组中，以减少内存分配和复制的开销。
- TCircularBuffer和TCircularQueue：环形缓冲区和环形队列，环形缓冲使用一个固定大小的缓冲区，当缓冲区满时新的元素将继续循环从头开始缓存，此时新元素将会覆盖旧的元素。而无锁环形队列是线程安全的但仅支持单生产单消费。
- TDiscardableKeyValueCache：可丢弃的键值缓存，它是一种特殊的缓存，可以根据需要丢弃某些元素。
- TResourceArray：资源数组，用于存储需要上传到 GPU 的数据。
- THashTable：哈希表，这个容器只承载数据，Hash计算方法还需要依赖Hash函数。
- TIndirectArray：间接数组，用于存储指向元素的指针，而不是元素本身。
- TLinkedList：非侵入式链表的一个节点，该节点直接包含元素对象。
- TIntrusiveLinkedList：侵入式链表，它是一种特殊的链表，其中的节点包含了链表的链接信息。
- TDoubleLinkedList：双向链表，每个节点都有指向前一个节点和后一个节点的指针。
- TList：列表，类似于 C++ 的 `std::list`。
- **TLockFreePointerList**：无锁指针列表，它是一种线程安全的列表。
- TQueue：队列，类似于 C++ 的 `std::queue`。
- TSet：集合，类似于 C++ 的 std::unordered_set。
- TSortedMap：排序映射，它是一种键值对的容器，其中的元素按键排序。
- **TSparseArray**：稀疏数组，用于存储稀疏的元素，其中未使用的索引不占用存储空间。
- TStaticArray 和 TStaticBitArray：静态数组和静态位数组，它们是固定大小的数组。
- **TTripleBuffer**：三重缓冲区，用于在多线程环境中交换数据。
- TUnion：联合，类似于 C++ 的 `union`，它可以存储多种不同类型的数据，但一次只能存储一种。

Unity的容器中属于LockFree的容器并不太多，可能是由于Unity只需要关注引擎内部实现便可，业务层的容器交给了Mono和IL2CPP，对比UE和Unity虽然各自也都有一些特殊用途的容器，但Unity的这些容器代码分散较开，因此容器部分的架构Unity在编排上会相对简单一些。


# 1.4 引擎的宏与模板技巧

## 1.4.1 宏技巧

引擎当中我们常看到一些眼花缭乱的宏的使用，总结后总共14种宏的用法，下面我们来讲讲宏的一般用法和高级用法，以便帮助我们在看引擎代码和编写引擎时能一目了解它的用意。它们包括：定义、函数、常量表达式、条件编译、嵌套、不定长参数、代码拼接、代码转字符串、代码简化（简化定义和逻辑）、编译优化、预编译静态断言、指针偏移、类型转换、递归。

1. **宏定义**
```
#define PI 3.14159
```

2. **宏函数**
```
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

3. **宏常量表达式**
```
#define SIZE 1024*1024
```

4. **宏条件编译**
```
// 预编译宏1 
#if TEST // 宏必须为大于0 
	printf("TEST: information\n"); 
#else 
	printf("Normal: information\n"); 
#endif 

// 预编译宏2 
#ifdef _DEBUG // 不管值只要定义就算有效 
	printf("This is debug version\n"); 
#endif // 区分debug 版和 release 版
```
注意 if 和 ifdef是不同的，前者会判定宏是否为0，后者则判定宏是否被定义（无论它是否为0只要被定义过就算通过）。

5. **宏嵌套**
```
#define AATEST(a) a * PI
```

6. **不定长参数宏**
7. 代码拼接
8. 代码转字符串
9. 代码简化
10. 编译优化
11. 预编译静态断言
12. 指针偏移
13. 类型转换
14. 递归

## 1.4.2 模板技巧


# 1.5 引擎离线生成代码

离线代码生成，即在编译前因为业务需求生成的代码。

在Unreal Engine中，离线生成代码主要涉及 UnrealHeaderTool（UHT）、UnrealBuildTool（UBT）、 ShaderCompileWorker（SCW）三个工具。 
- UnrealHeaderTool（UHT）负责生成反射数据，以便在运行时用于各种引擎功能，如垃圾回收和序列化。
- UnrealBuildTool（UBT）负责处理所有的编译、链接和部署步骤。
- ShaderCompileWorker（SCW）负责编译渲染着色器，可以并行处理多个着色器编译任务，以提高编译速度。

Unity引擎中使用离线生成代码的地方，包括C#与C++的接口绑定、IL2CPP代码生成、着色器变体生成等。

游戏业务上，使用离线生成代码的地方，例如网络协议（Protocol Buffer等）代码生成、xml或json数据格式转代码生成、反射代码生成、C++调用接口代码生成、序列化和反序列化代码生成、等等。